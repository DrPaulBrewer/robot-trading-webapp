!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('2', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic('3', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('4', ['3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('3');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic('5', ['2', '6', '4'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('2'),
      core = $__require('6'),
      ctx = $__require('4'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
$__System.registerDynamic("7", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
$__System.registerDynamic("8", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
$__System.registerDynamic('9', ['8'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defined = $__require('8');
  module.exports = function (it) {
    return Object(defined(it));
  };
});
$__System.registerDynamic("a", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('b', ['a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('a');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
$__System.registerDynamic("c", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('d', ['7', '9', 'b', 'c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('7'),
      toObject = $__require('9'),
      IObject = $__require('b');
  module.exports = $__require('c')(function () {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
    return T;
  } : Object.assign;
});
$__System.registerDynamic('e', ['5', 'd'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('5');
  $export($export.S + $export.F, 'Object', { assign: $__require('d') });
});
$__System.registerDynamic('6', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('f', ['e', '6'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('e');
  module.exports = $__require('6').Object.assign;
});
$__System.registerDynamic("10", ["f"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("f"), __esModule: true };
});
$__System.registerDynamic('11', ['12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      $export = $__require('13'),
      DESCRIPTORS = $__require('14'),
      createDesc = $__require('15'),
      html = $__require('16'),
      cel = $__require('17'),
      has = $__require('18'),
      cof = $__require('19'),
      invoke = $__require('1a'),
      fails = $__require('1b'),
      anObject = $__require('1c'),
      aFunction = $__require('1d'),
      isObject = $__require('1e'),
      toObject = $__require('1f'),
      toIObject = $__require('20'),
      toInteger = $__require('21'),
      toIndex = $__require('22'),
      toLength = $__require('23'),
      IObject = $__require('24'),
      IE_PROTO = $__require('25')('__proto__'),
      createArrayMethod = $__require('26'),
      arrayIndexOf = $__require('27')(false),
      ObjectProto = Object.prototype,
      ArrayProto = Array.prototype,
      arraySlice = ArrayProto.slice,
      arrayJoin = ArrayProto.join,
      defineProperty = $.setDesc,
      getOwnDescriptor = $.getDesc,
      defineProperties = $.setDescs,
      factories = {},
      IE8_DOM_DEFINE;
  if (!DESCRIPTORS) {
    IE8_DOM_DEFINE = !fails(function () {
      return defineProperty(cel('div'), 'a', { get: function () {
          return 7;
        } }).a != 7;
    });
    $.setDesc = function (O, P, Attributes) {
      if (IE8_DOM_DEFINE) try {
        return defineProperty(O, P, Attributes);
      } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
      if ('value' in Attributes) anObject(O)[P] = Attributes.value;
      return O;
    };
    $.getDesc = function (O, P) {
      if (IE8_DOM_DEFINE) try {
        return getOwnDescriptor(O, P);
      } catch (e) {}
      if (has(O, P)) return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
    };
    $.setDescs = defineProperties = function (O, Properties) {
      anObject(O);
      var keys = $.getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i) $.setDesc(O, P = keys[i++], Properties[P]);
      return O;
    };
  }
  $export($export.S + $export.F * !DESCRIPTORS, 'Object', {
    getOwnPropertyDescriptor: $.getDesc,
    defineProperty: $.setDesc,
    defineProperties: defineProperties
  });
  var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
      keys2 = keys1.concat('length', 'prototype'),
      keysLen1 = keys1.length;
  var createDict = function () {
    var iframe = cel('iframe'),
        i = keysLen1,
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict.prototype[keys1[i]];
    return createDict();
  };
  var createGetKeys = function (names, length) {
    return function (object) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
      while (length > i) if (has(O, key = names[i++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };
  };
  var Empty = function () {};
  $export($export.S, 'Object', {
    getPrototypeOf: $.getProto = $.getProto || function (O) {
      O = toObject(O);
      if (has(O, IE_PROTO)) return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    },
    getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
    create: $.create = $.create || function (O, Properties) {
      var result;
      if (O !== null) {
        Empty.prototype = anObject(O);
        result = new Empty();
        Empty.prototype = null;
        result[IE_PROTO] = O;
      } else result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    },
    keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
  });
  var construct = function (F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
  };
  $export($export.P, 'Function', { bind: function bind(that) {
      var fn = aFunction(this),
          partArgs = arraySlice.call(arguments, 1);
      var bound = function () {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype)) bound.prototype = fn.prototype;
      return bound;
    } });
  $export($export.P + $export.F * fails(function () {
    if (html) arraySlice.call(html);
  }), 'Array', { slice: function (begin, end) {
      var len = toLength(this.length),
          klass = cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array') return arraySlice.call(this, begin, end);
      var start = toIndex(begin, len),
          upTo = toIndex(end, len),
          size = toLength(upTo - start),
          cloned = Array(size),
          i = 0;
      for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      return cloned;
    } });
  $export($export.P + $export.F * (IObject != Object), 'Array', { join: function join(separator) {
      return arrayJoin.call(IObject(this), separator === undefined ? ',' : separator);
    } });
  $export($export.S, 'Array', { isArray: $__require('28') });
  var createArrayReduce = function (isRight) {
    return function (callbackfn, memo) {
      aFunction(callbackfn);
      var O = IObject(this),
          length = toLength(O.length),
          index = isRight ? length - 1 : 0,
          i = isRight ? -1 : 1;
      if (arguments.length < 2) for (;;) {
        if (index in O) {
          memo = O[index];
          index += i;
          break;
        }
        index += i;
        if (isRight ? index < 0 : length <= index) {
          throw TypeError('Reduce of empty array with no initial value');
        }
      }
      for (; isRight ? index >= 0 : length > index; index += i) if (index in O) {
        memo = callbackfn(memo, O[index], index, this);
      }
      return memo;
    };
  };
  var methodize = function ($fn) {
    return function (arg1) {
      return $fn(this, arg1, arguments[1]);
    };
  };
  $export($export.P, 'Array', {
    forEach: $.each = $.each || methodize(createArrayMethod(0)),
    map: methodize(createArrayMethod(1)),
    filter: methodize(createArrayMethod(2)),
    some: methodize(createArrayMethod(3)),
    every: methodize(createArrayMethod(4)),
    reduce: createArrayReduce(false),
    reduceRight: createArrayReduce(true),
    indexOf: methodize(arrayIndexOf),
    lastIndexOf: function (el, fromIndex) {
      var O = toIObject(this),
          length = toLength(O.length),
          index = length - 1;
      if (arguments.length > 1) index = Math.min(index, toInteger(fromIndex));
      if (index < 0) index = toLength(length + index);
      for (; index >= 0; index--) if (index in O) if (O[index] === el) return index;
      return -1;
    }
  });
  $export($export.S, 'Date', { now: function () {
      return +new Date();
    } });
  var lz = function (num) {
    return num > 9 ? num : '0' + num;
  };
  $export($export.P + $export.F * (fails(function () {
    return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
  }) || !fails(function () {
    new Date(NaN).toISOString();
  })), 'Date', { toISOString: function toISOString() {
      if (!isFinite(this)) throw RangeError('Invalid time value');
      var d = this,
          y = d.getUTCFullYear(),
          m = d.getUTCMilliseconds(),
          s = y < 0 ? '-' : y > 9999 ? '+' : '';
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
    } });
});
$__System.registerDynamic('29', ['12'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12');
  module.exports = function (it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) keys.push(key);
    }
    return keys;
  };
});
$__System.registerDynamic('2a', ['12', '2b', '18', '14', '13', '2c', '1b', '2d', '2e', '25', '2f', '30', '31', '29', '28', '1c', '20', '15', '32'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      global = $__require('2b'),
      has = $__require('18'),
      DESCRIPTORS = $__require('14'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      $fails = $__require('1b'),
      shared = $__require('2d'),
      setToStringTag = $__require('2e'),
      uid = $__require('25'),
      wks = $__require('2f'),
      keyOf = $__require('30'),
      $names = $__require('31'),
      enumKeys = $__require('29'),
      isArray = $__require('28'),
      anObject = $__require('1c'),
      toIObject = $__require('20'),
      createDesc = $__require('15'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function () {
    return _create(setDesc({}, 'a', { get: function () {
        return setDesc(this, 'a', { value: 7 }).a;
      } })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto) setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function (value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function (it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN)) setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _create(D, { enumerable: createDesc(0, false) });
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i) if (!has(AllSymbols, key = names[i++]) && key != HIDDEN) result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i) if (has(AllSymbols, key = names[i++])) result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it)) return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i) args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function () {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this)) throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function (it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !$__require('32')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function (key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function () {
      setter = true;
    },
    useSimple: function () {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function (it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, { Symbol: $Symbol });
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', { stringify: $stringify });
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
});
$__System.registerDynamic('33', ['13', '34'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', { assign: $__require('34') });
});
$__System.registerDynamic('35', ['13', '36'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Object', { is: $__require('36') });
});
$__System.registerDynamic('37', ['13', '38'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Object', { setPrototypeOf: $__require('38').set });
});
$__System.registerDynamic('39', ['3a', '2f', '2c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var classof = $__require('3a'),
      test = {};
  test[$__require('2f')('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    $__require('2c')(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
});
$__System.registerDynamic('3b', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('freeze', function ($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
});
$__System.registerDynamic('3d', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('seal', function ($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(it) : it;
    };
  });
});
$__System.registerDynamic('3e', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('preventExtensions', function ($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
    };
  });
});
$__System.registerDynamic('3f', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('isFrozen', function ($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
});
$__System.registerDynamic('40', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('isSealed', function ($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
});
$__System.registerDynamic('41', ['1e', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  $__require('3c')('isExtensible', function ($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
});
$__System.registerDynamic('42', ['20', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('20');
  $__require('3c')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
});
$__System.registerDynamic('43', ['1f', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toObject = $__require('1f');
  $__require('3c')('getPrototypeOf', function ($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
});
$__System.registerDynamic('44', ['1f', '3c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toObject = $__require('1f');
  $__require('3c')('keys', function ($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
});
$__System.registerDynamic('3c', ['13', '45', '1b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        core = $__require('45'),
        fails = $__require('1b');
    module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
            fn(1);
        }), 'Object', exp);
    };
});
$__System.registerDynamic('31', ['20', '12'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('20'),
      getNames = $__require('12').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function (it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]') return getWindowNames(it);
    return getNames(toIObject(it));
  };
});
$__System.registerDynamic('46', ['3c', '31'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('3c')('getOwnPropertyNames', function () {
    return $__require('31').get;
  });
});
$__System.registerDynamic('47', ['12', '15', '18', '14'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var setDesc = $__require('12').setDesc,
        createDesc = $__require('15'),
        has = $__require('18'),
        FProto = Function.prototype,
        nameRE = /^\s*function ([^ (]*)/,
        NAME = 'name';
    NAME in FProto || $__require('14') && setDesc(FProto, NAME, {
        configurable: true,
        get: function () {
            var match = ('' + this).match(nameRE),
                name = match ? match[1] : '';
            has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
            return name;
        }
    });
});
$__System.registerDynamic('48', ['12', '1e', '2f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      isObject = $__require('1e'),
      HAS_INSTANCE = $__require('2f')('hasInstance'),
      FunctionProto = Function.prototype;
  if (!(HAS_INSTANCE in FunctionProto)) $.setDesc(FunctionProto, HAS_INSTANCE, { value: function (O) {
      if (typeof this != 'function' || !isObject(O)) return false;
      if (!isObject(this.prototype)) return O instanceof this;
      while (O = $.getProto(O)) if (this.prototype === O) return true;
      return false;
    } });
});
$__System.registerDynamic('49', ['1e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
});
$__System.registerDynamic('4a', ['12', '2b', '18', '19', '49', '1b', '4b', '14', '2c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      global = $__require('2b'),
      has = $__require('18'),
      cof = $__require('19'),
      toPrimitive = $__require('49'),
      fails = $__require('1b'),
      $trim = $__require('4b').trim,
      NUMBER = 'Number',
      $Number = global[NUMBER],
      Base = $Number,
      proto = $Number.prototype,
      BROKEN_COF = cof($.create(proto)) == NUMBER,
      TRIM = 'trim' in String.prototype;
  var toNumber = function (argument) {
    var it = toPrimitive(argument, false);
    if (typeof it == 'string' && it.length > 2) {
      it = TRIM ? it.trim() : $trim(it, 3);
      var first = it.charCodeAt(0),
          third,
          radix,
          maxCode;
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN;
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66:
          case 98:
            radix = 2;
            maxCode = 49;
            break;
          case 79:
          case 111:
            radix = 8;
            maxCode = 55;
            break;
          default:
            return +it;
        }
        for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
          code = digits.charCodeAt(i);
          if (code < 48 || code > maxCode) return NaN;
        }
        return parseInt(digits, radix);
      }
    }
    return +it;
  };
  if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
      var it = arguments.length < 1 ? 0 : value,
          that = this;
      return that instanceof $Number && (BROKEN_COF ? fails(function () {
        proto.valueOf.call(that);
      }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
    };
    $.each.call($__require('14') ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function (key) {
      if (has(Base, key) && !has($Number, key)) {
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    });
    $Number.prototype = proto;
    proto.constructor = $Number;
    $__require('2c')(global, NUMBER, $Number);
  }
});
$__System.registerDynamic('4c', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });
});
$__System.registerDynamic('4d', ['13', '2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        _isFinite = $__require('2b').isFinite;
    $export($export.S, 'Number', { isFinite: function isFinite(it) {
            return typeof it == 'number' && _isFinite(it);
        } });
});
$__System.registerDynamic('4e', ['13', '4f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { isInteger: $__require('4f') });
});
$__System.registerDynamic('50', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Number', { isNaN: function isNaN(number) {
            return number != number;
        } });
});
$__System.registerDynamic('4f', ['1e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e'),
      floor = Math.floor;
  module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
});
$__System.registerDynamic('51', ['13', '4f'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        isInteger = $__require('4f'),
        abs = Math.abs;
    $export($export.S, 'Number', { isSafeInteger: function isSafeInteger(number) {
            return isInteger(number) && abs(number) <= 0x1fffffffffffff;
        } });
});
$__System.registerDynamic('52', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });
});
$__System.registerDynamic('53', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });
});
$__System.registerDynamic('54', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { parseFloat: parseFloat });
});
$__System.registerDynamic('55', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Number', { parseInt: parseInt });
});
$__System.registerDynamic('56', ['13', '57'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        log1p = $__require('57'),
        sqrt = Math.sqrt,
        $acosh = Math.acosh;
    $export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', { acosh: function acosh(x) {
            return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
        } });
});
$__System.registerDynamic('58', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }
  $export($export.S, 'Math', { asinh: asinh });
});
$__System.registerDynamic('59', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Math', { atanh: function atanh(x) {
            return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
        } });
});
$__System.registerDynamic('5a', ['13', '5b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        sign = $__require('5b');
    $export($export.S, 'Math', { cbrt: function cbrt(x) {
            return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
        } });
});
$__System.registerDynamic('5c', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Math', { clz32: function clz32(x) {
            return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
        } });
});
$__System.registerDynamic('5d', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        exp = Math.exp;
    $export($export.S, 'Math', { cosh: function cosh(x) {
            return (exp(x = +x) + exp(-x)) / 2;
        } });
});
$__System.registerDynamic('5e', ['13', '5f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Math', { expm1: $__require('5f') });
});
$__System.registerDynamic('60', ['13', '5b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      sign = $__require('5b'),
      pow = Math.pow,
      EPSILON = pow(2, -52),
      EPSILON32 = pow(2, -23),
      MAX32 = pow(2, 127) * (2 - EPSILON32),
      MIN32 = pow(2, -126);
  var roundTiesToEven = function (n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };
  $export($export.S, 'Math', { fround: function fround(x) {
      var $abs = Math.abs(x),
          $sign = sign(x),
          a,
          result;
      if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result) return $sign * Infinity;
      return $sign * result;
    } });
});
$__System.registerDynamic('61', ['13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      abs = Math.abs;
  $export($export.S, 'Math', { hypot: function hypot(value1, value2) {
      var sum = 0,
          i = 0,
          $$ = arguments,
          $$len = $$.length,
          larg = 0,
          arg,
          div;
      while (i < $$len) {
        arg = abs($$[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    } });
});
$__System.registerDynamic('62', ['13', '1b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        $imul = Math.imul;
    $export($export.S + $export.F * $__require('1b')(function () {
        return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
    }), 'Math', { imul: function imul(x, y) {
            var UINT16 = 0xffff,
                xn = +x,
                yn = +y,
                xl = UINT16 & xn,
                yl = UINT16 & yn;
            return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        } });
});
$__System.registerDynamic('63', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Math', { log10: function log10(x) {
            return Math.log(x) / Math.LN10;
        } });
});
$__System.registerDynamic("57", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 20.2.2.20 Math.log1p(x)
  module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };
});
$__System.registerDynamic('64', ['13', '57'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Math', { log1p: $__require('57') });
});
$__System.registerDynamic('65', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Math', { log2: function log2(x) {
            return Math.log(x) / Math.LN2;
        } });
});
$__System.registerDynamic("5b", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 20.2.2.28 Math.sign(x)
  module.exports = Math.sign || function sign(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
});
$__System.registerDynamic('66', ['13', '5b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Math', { sign: $__require('5b') });
});
$__System.registerDynamic('67', ['13', '5f', '1b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        expm1 = $__require('5f'),
        exp = Math.exp;
    $export($export.S + $export.F * $__require('1b')(function () {
        return !Math.sinh(-2e-17) != -2e-17;
    }), 'Math', { sinh: function sinh(x) {
            return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
        } });
});
$__System.registerDynamic("5f", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 20.2.2.14 Math.expm1(x)
  module.exports = Math.expm1 || function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  };
});
$__System.registerDynamic('68', ['13', '5f'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        expm1 = $__require('5f'),
        exp = Math.exp;
    $export($export.S, 'Math', { tanh: function tanh(x) {
            var a = expm1(x = +x),
                b = expm1(-x);
            return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
        } });
});
$__System.registerDynamic('69', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Math', { trunc: function trunc(it) {
            return (it > 0 ? Math.floor : Math.ceil)(it);
        } });
});
$__System.registerDynamic('6a', ['13', '22'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        toIndex = $__require('22'),
        fromCharCode = String.fromCharCode,
        $fromCodePoint = String.fromCodePoint;
    $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', { fromCodePoint: function fromCodePoint(x) {
            var res = [],
                $$ = arguments,
                $$len = $$.length,
                i = 0,
                code;
            while ($$len > i) {
                code = +$$[i++];
                if (toIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
                res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
            }
            return res.join('');
        } });
});
$__System.registerDynamic('6b', ['13', '20', '23'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        toIObject = $__require('20'),
        toLength = $__require('23');
    $export($export.S, 'String', { raw: function raw(callSite) {
            var tpl = toIObject(callSite.raw),
                len = toLength(tpl.length),
                $$ = arguments,
                $$len = $$.length,
                res = [],
                i = 0;
            while (len > i) {
                res.push(String(tpl[i++]));
                if (i < $$len) res.push(String($$[i]));
            }
            return res.join('');
        } });
});
$__System.registerDynamic('6c', ['4b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  $__require('4b')('trim', function ($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });
});
$__System.registerDynamic('6d', ['6e', '6f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $at = $__require('6e')(true);
  $__require('6f')(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
});
$__System.registerDynamic('70', ['13', '6e'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        $at = $__require('6e')(false);
    $export($export.P, 'String', { codePointAt: function codePointAt(pos) {
            return $at(this, pos);
        } });
});
$__System.registerDynamic('71', ['13', '23', '72', '73'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        toLength = $__require('23'),
        context = $__require('72'),
        ENDS_WITH = 'endsWith',
        $endsWith = ''[ENDS_WITH];
    $export($export.P + $export.F * $__require('73')(ENDS_WITH), 'String', { endsWith: function endsWith(searchString) {
            var that = context(this, searchString, ENDS_WITH),
                $$ = arguments,
                endPosition = $$.length > 1 ? $$[1] : undefined,
                len = toLength(that.length),
                end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
                search = String(searchString);
            return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
        } });
});
$__System.registerDynamic('74', ['13', '72', '73'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        context = $__require('72'),
        INCLUDES = 'includes';
    $export($export.P + $export.F * $__require('73')(INCLUDES), 'String', { includes: function includes(searchString) {
            return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
        } });
});
$__System.registerDynamic('75', ['13', '76'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.P, 'String', { repeat: $__require('76') });
});
$__System.registerDynamic('72', ['77', '78'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isRegExp = $__require('77'),
      defined = $__require('78');
  module.exports = function (that, searchString, NAME) {
    if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
});
$__System.registerDynamic('73', ['2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var MATCH = $__require('2f')('match');
  module.exports = function (KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {}
    }
    return true;
  };
});
$__System.registerDynamic('79', ['13', '23', '72', '73'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        toLength = $__require('23'),
        context = $__require('72'),
        STARTS_WITH = 'startsWith',
        $startsWith = ''[STARTS_WITH];
    $export($export.P + $export.F * $__require('73')(STARTS_WITH), 'String', { startsWith: function startsWith(searchString) {
            var that = context(this, searchString, STARTS_WITH),
                $$ = arguments,
                index = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length)),
                search = String(searchString);
            return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
        } });
});
$__System.registerDynamic('7a', ['7b', '13', '1f', '7c', '7d', '23', '7e', '7f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ctx = $__require('7b'),
      $export = $__require('13'),
      toObject = $__require('1f'),
      call = $__require('7c'),
      isArrayIter = $__require('7d'),
      toLength = $__require('23'),
      getIterFn = $__require('7e');
  $export($export.S + $export.F * !$__require('7f')(function (iter) {
    Array.from(iter);
  }), 'Array', { from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    } });
});
$__System.registerDynamic('80', ['13', '1b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13');
  $export($export.S + $export.F * $__require('1b')(function () {
    function F() {}
    return !(Array.of.call(F) instanceof F);
  }), 'Array', { of: function of() {
      var index = 0,
          $$ = arguments,
          $$len = $$.length,
          result = new (typeof this == 'function' ? this : Array)($$len);
      while ($$len > index) result[index] = $$[index++];
      result.length = $$len;
      return result;
    } });
});
$__System.registerDynamic('81', ['82'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('82')('Array');
});
$__System.registerDynamic('83', ['1f', '22', '23'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var toObject = $__require('1f'),
      toIndex = $__require('22'),
      toLength = $__require('23');
  module.exports = [].copyWithin || function copyWithin(target, start) {
    var O = toObject(this),
        len = toLength(O.length),
        to = toIndex(target, len),
        from = toIndex(start, len),
        $$ = arguments,
        end = $$.length > 2 ? $$[2] : undefined,
        count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
        inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O) O[to] = O[from];else delete O[to];
      to += inc;
      from += inc;
    }
    return O;
  };
});
$__System.registerDynamic('84', ['13', '83', '85'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.P, 'Array', { copyWithin: $__require('83') });
  $__require('85')('copyWithin');
});
$__System.registerDynamic('86', ['1f', '22', '23'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var toObject = $__require('1f'),
        toIndex = $__require('22'),
        toLength = $__require('23');
    module.exports = [].fill || function fill(value) {
        var O = toObject(this),
            length = toLength(O.length),
            $$ = arguments,
            $$len = $$.length,
            index = toIndex($$len > 1 ? $$[1] : undefined, length),
            end = $$len > 2 ? $$[2] : undefined,
            endPos = end === undefined ? length : toIndex(end, length);
        while (endPos > index) O[index++] = value;
        return O;
    };
});
$__System.registerDynamic('87', ['13', '86', '85'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.P, 'Array', { fill: $__require('86') });
  $__require('85')('fill');
});
$__System.registerDynamic('88', ['13', '26', '85'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13'),
      $find = $__require('26')(5),
      KEY = 'find',
      forced = true;
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', { find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    } });
  $__require('85')(KEY);
});
$__System.registerDynamic('89', ['13', '26', '85'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13'),
      $find = $__require('26')(6),
      KEY = 'findIndex',
      forced = true;
  if (KEY in []) Array(1)[KEY](function () {
    forced = false;
  });
  $export($export.P + $export.F * forced, 'Array', { findIndex: function findIndex(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    } });
  $__require('85')(KEY);
});
$__System.registerDynamic('77', ['1e', '19', '2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e'),
      cof = $__require('19'),
      MATCH = $__require('2f')('match');
  module.exports = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
});
$__System.registerDynamic('8a', ['12', '2b', '77', '8b', '14', '1b', '2f', '2c', '82'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      global = $__require('2b'),
      isRegExp = $__require('77'),
      $flags = $__require('8b'),
      $RegExp = global.RegExp,
      Base = $RegExp,
      proto = $RegExp.prototype,
      re1 = /a/g,
      re2 = /a/g,
      CORRECT_NEW = new $RegExp(re1) !== re1;
  if ($__require('14') && (!CORRECT_NEW || $__require('1b')(function () {
    re2[$__require('2f')('match')] = false;
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var piRE = isRegExp(p),
          fiU = f === undefined;
      return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p : CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
    };
    $.each.call($.getNames(Base), function (key) {
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function () {
          return Base[key];
        },
        set: function (it) {
          Base[key] = it;
        }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    $__require('2c')(global, 'RegExp', $RegExp);
  }
  $__require('82')('RegExp');
});
$__System.registerDynamic('8b', ['1c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var anObject = $__require('1c');
  module.exports = function () {
    var that = anObject(this),
        result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };
});
$__System.registerDynamic('8c', ['12', '14', '8b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12');
  if ($__require('14') && /./g.flags != 'g') $.setDesc(RegExp.prototype, 'flags', {
    configurable: true,
    get: $__require('8b')
  });
});
$__System.registerDynamic('8d', ['8e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('8e')('match', 1, function (defined, MATCH) {
    return function match(regexp) {
      'use strict';

      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    };
  });
});
$__System.registerDynamic('8f', ['8e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('8e')('replace', 2, function (defined, REPLACE, $replace) {
    return function replace(searchValue, replaceValue) {
      'use strict';

      var O = defined(this),
          fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    };
  });
});
$__System.registerDynamic('90', ['8e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('8e')('search', 1, function (defined, SEARCH) {
    return function search(regexp) {
      'use strict';

      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    };
  });
});
$__System.registerDynamic('8e', ['91', '2c', '1b', '78', '2f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var hide = $__require('91'),
      redefine = $__require('2c'),
      fails = $__require('1b'),
      defined = $__require('78'),
      wks = $__require('2f');
  module.exports = function (KEY, length, exec) {
    var SYMBOL = wks(KEY),
        original = ''[KEY];
    if (fails(function () {
      var O = {};
      O[SYMBOL] = function () {
        return 7;
      };
      return ''[KEY](O) != 7;
    })) {
      redefine(String.prototype, KEY, exec(defined, SYMBOL, original));
      hide(RegExp.prototype, SYMBOL, length == 2 ? function (string, arg) {
        return original.call(string, this, arg);
      } : function (string) {
        return original.call(string, this);
      });
    }
  };
});
$__System.registerDynamic('92', ['8e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('8e')('split', 2, function (defined, SPLIT, $split) {
    return function split(separator, limit) {
      'use strict';

      var O = defined(this),
          fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    };
  });
});
$__System.registerDynamic("36", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.9 SameValue(x, y)
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
});
$__System.registerDynamic('93', ['1c', '1d', '2f'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var anObject = $__require('1c'),
        aFunction = $__require('1d'),
        SPECIES = $__require('2f')('species');
    module.exports = function (O, D) {
        var C = anObject(O).constructor,
            S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
    };
});
$__System.registerDynamic('94', ['2b', '95', '19', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var global = $__require('2b'),
        macrotask = $__require('95').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('19')(process) == 'process',
        head,
        last,
        notify;
    var flush = function () {
      var parent, domain, fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain) domain.enter();
        fn();
        if (domain) domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent) parent.enter();
    };
    if (isNode) {
      notify = function () {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function () {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function () {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('96'));
});
$__System.registerDynamic('97', ['12', '32', '2b', '7b', '3a', '13', '1e', '1c', '1d', '98', '99', '38', '36', '2f', '93', '94', '14', '9a', '2e', '82', '45', '7f', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var $ = $__require('12'),
        LIBRARY = $__require('32'),
        global = $__require('2b'),
        ctx = $__require('7b'),
        classof = $__require('3a'),
        $export = $__require('13'),
        isObject = $__require('1e'),
        anObject = $__require('1c'),
        aFunction = $__require('1d'),
        strictNew = $__require('98'),
        forOf = $__require('99'),
        setProto = $__require('38').set,
        same = $__require('36'),
        SPECIES = $__require('2f')('species'),
        speciesConstructor = $__require('93'),
        asap = $__require('94'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        empty = function () {},
        Wrapper;
    var testResolve = function (sub) {
      var test = new P(empty),
          promise;
      if (sub) test.constructor = function (exec) {
        exec(empty, empty);
      };
      (promise = P.resolve(test))['catch'](empty);
      return promise === test;
    };
    var USE_NATIVE = function () {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, { constructor: { value: P2 } });
        if (!(P2.resolve(5).then(function () {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('14')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', { get: function () {
              thenableThenGotten = true;
            } }));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function (a, b) {
      if (LIBRARY && a === P && b === Wrapper) return true;
      return same(a, b);
    };
    var getConstructor = function (C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function (it) {
      var then;
      return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function (C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function (exec) {
      try {
        exec();
      } catch (e) {
        return { error: e };
      }
    };
    var notify = function (record, isReject) {
      if (record.n) return;
      record.n = true;
      var chain = record.c;
      asap(function () {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function (reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok) record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else resolve(result);
            } else reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i) run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject) setTimeout(function () {
          var promise = record.p,
              handler,
              console;
          if (isUnhandled(promise)) {
            if (isNode) {
              process.emit('unhandledRejection', value, promise);
            } else if (handler = global.onunhandledrejection) {
              handler({
                promise: promise,
                reason: value
              });
            } else if ((console = global.console) && console.error) {
              console.error('Unhandled promise rejection', value);
            }
          }
          record.a = undefined;
        }, 1);
      });
    };
    var isUnhandled = function (promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h) return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise)) return false;
      }
      return true;
    };
    var $reject = function (value) {
      var record = this;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function (value) {
      var record = this,
          then;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value) throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function () {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('9a')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a) record.a.push(reaction);
          if (record.s) notify(record, false);
          return promise;
        },
        'catch': function (onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: P });
    $__require('2e')(P, PROMISE);
    $__require('82')(PROMISE);
    Wrapper = $__require('45')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, { reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      } });
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, { resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this)) return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      } });
    $export($export.S + $export.F * !(USE_NATIVE && $__require('7f')(function (iter) {
      P.all(iter)['catch'](function () {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function () {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining) $.each.call(values, function (promise, index) {
            var alreadyCalled = false;
            C.resolve(promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });else resolve(results);
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function () {
          forOf(iterable, false, function (promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('96'));
});
$__System.registerDynamic('9b', ['9c', '9d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var strong = $__require('9c');
  $__require('9d')('Map', function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
});
$__System.registerDynamic('82', ['2b', '12', '14', '2f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var global = $__require('2b'),
      $ = $__require('12'),
      DESCRIPTORS = $__require('14'),
      SPECIES = $__require('2f')('species');
  module.exports = function (KEY) {
    var C = global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) $.setDesc(C, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  };
});
$__System.registerDynamic('9c', ['12', '91', '9a', '7b', '98', '78', '99', '6f', '9e', '25', '18', '1e', '82', '14'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      hide = $__require('91'),
      redefineAll = $__require('9a'),
      ctx = $__require('7b'),
      strictNew = $__require('98'),
      defined = $__require('78'),
      forOf = $__require('99'),
      $iterDefine = $__require('6f'),
      step = $__require('9e'),
      ID = $__require('25')('id'),
      $has = $__require('18'),
      isObject = $__require('1e'),
      setSpecies = $__require('82'),
      DESCRIPTORS = $__require('14'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function (it, create) {
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it)) return 'F';
      if (!create) return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function (that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F') return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function (key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS) $.setDesc(C.prototype, 'size', { get: function () {
          return defined(this[SIZE]);
        } });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index !== 'F') that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function (iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, entry.k);
        if (kind == 'values') return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
});
$__System.registerDynamic('9f', ['9c', '9d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var strong = $__require('9c');
  $__require('9d')('Set', function (get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, { add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    } }, strong);
});
$__System.registerDynamic('a0', ['12', '2c', 'a1', '1e', '18', '9d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      redefine = $__require('2c'),
      weak = $__require('a1'),
      isObject = $__require('1e'),
      has = $__require('18'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('9d')('WeakMap', function (get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key)) return frozenStore(this).get(key);
        if (has(key, WEAK)) return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function (key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      redefine(proto, key, function (a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
});
$__System.registerDynamic('28', ['19'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('19');
  module.exports = Array.isArray || function (arg) {
    return cof(arg) == 'Array';
  };
});
$__System.registerDynamic('a2', ['1e', '28', '2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e'),
      isArray = $__require('28'),
      SPECIES = $__require('2f')('species');
  module.exports = function (original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
});
$__System.registerDynamic('26', ['7b', '24', '1f', '23', 'a2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('7b'),
      IObject = $__require('24'),
      toObject = $__require('1f'),
      toLength = $__require('23'),
      asc = $__require('a2');
  module.exports = function (TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
            case 3:
              return true;
            case 5:
              return val;
            case 6:
              return index;
            case 2:
              result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
});
$__System.registerDynamic('a1', ['91', '9a', '1c', '1e', '98', '99', '26', '18', '25'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var hide = $__require('91'),
      redefineAll = $__require('9a'),
      anObject = $__require('1c'),
      isObject = $__require('1e'),
      strictNew = $__require('98'),
      forOf = $__require('99'),
      createArrayMethod = $__require('26'),
      $has = $__require('18'),
      WEAK = $__require('25')('weak'),
      isExtensible = Object.isExtensible || isObject,
      arrayFind = createArrayMethod(5),
      arrayFindIndex = createArrayMethod(6),
      id = 0;
  var frozenStore = function (that) {
    return that._l || (that._l = new FrozenStore());
  };
  var FrozenStore = function () {
    this.a = [];
  };
  var findFrozen = function (store, key) {
    return arrayFind(store.a, function (it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function (key) {
      var entry = findFrozen(this, key);
      if (entry) return entry[1];
    },
    has: function (key) {
      return !!findFrozen(this, key);
    },
    set: function (key, value) {
      var entry = findFrozen(this, key);
      if (entry) entry[1] = value;else this.a.push([key, value]);
    },
    'delete': function (key) {
      var index = arrayFindIndex(this.a, function (it) {
        return it[0] === key;
      });
      if (~index) this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        'delete': function (key) {
          if (!isObject(key)) return false;
          if (!isExtensible(key)) return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key)) return false;
          if (!isExtensible(key)) return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function (that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
});
$__System.registerDynamic('9a', ['2c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var redefine = $__require('2c');
  module.exports = function (target, src) {
    for (var key in src) redefine(target, key, src[key]);
    return target;
  };
});
$__System.registerDynamic("98", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
});
$__System.registerDynamic('7f', ['2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ITERATOR = $__require('2f')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {}
  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
});
$__System.registerDynamic('9d', ['2b', '13', '2c', '9a', '99', '98', '1e', '1b', '7f', '2e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var global = $__require('2b'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      redefineAll = $__require('9a'),
      forOf = $__require('99'),
      strictNew = $__require('98'),
      isObject = $__require('1e'),
      fails = $__require('1b'),
      $iterDetect = $__require('7f'),
      setToStringTag = $__require('2e');
  module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    var fixMethod = function (KEY) {
      var fn = proto[KEY];
      redefine(proto, KEY, KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      var instance = new C(),
          HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
          THROWS_ON_PRIMITIVES = fails(function () {
        instance.has(1);
      }),
          ACCEPT_ITERABLES = $iterDetect(function (iter) {
        new C(iter);
      }),
          BUGGY_ZERO;
      if (!ACCEPT_ITERABLES) {
        C = wrapper(function (target, iterable) {
          strictNew(target, C, NAME);
          var that = new Base();
          if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      IS_WEAK || instance.forEach(function (val, key) {
        BUGGY_ZERO = 1 / key === -Infinity;
      });
      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
      if (IS_WEAK && proto.clear) delete proto.clear;
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F * (C != Base), O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
});
$__System.registerDynamic('a3', ['a1', '9d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var weak = $__require('a1');
  $__require('9d')('WeakSet', function (get) {
    return function WeakSet() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, { add: function add(value) {
      return weak.def(this, value, true);
    } }, weak, false, true);
});
$__System.registerDynamic('a4', ['13', '1c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        _apply = Function.apply,
        anObject = $__require('1c');
    $export($export.S, 'Reflect', { apply: function apply(target, thisArgument, argumentsList) {
            return _apply.call(target, thisArgument, anObject(argumentsList));
        } });
});
$__System.registerDynamic('a5', ['12', '13', '1d', '1c', '1e', '45', '1b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      $export = $__require('13'),
      aFunction = $__require('1d'),
      anObject = $__require('1c'),
      isObject = $__require('1e'),
      bind = Function.bind || $__require('45').Function.prototype.bind;
  $export($export.S + $export.F * $__require('1b')(function () {
    function F() {}
    return !(Reflect.construct(function () {}, [], F) instanceof F);
  }), 'Reflect', { construct: function construct(Target, args) {
      aFunction(Target);
      anObject(args);
      var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
      if (Target == newTarget) {
        switch (args.length) {
          case 0:
            return new Target();
          case 1:
            return new Target(args[0]);
          case 2:
            return new Target(args[0], args[1]);
          case 3:
            return new Target(args[0], args[1], args[2]);
          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        }
        var $args = [null];
        $args.push.apply($args, args);
        return new (bind.apply(Target, $args))();
      }
      var proto = newTarget.prototype,
          instance = $.create(isObject(proto) ? proto : Object.prototype),
          result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    } });
});
$__System.registerDynamic('a6', ['12', '13', '1c', '1b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      $export = $__require('13'),
      anObject = $__require('1c');
  $export($export.S + $export.F * $__require('1b')(function () {
    Reflect.defineProperty($.setDesc({}, 1, { value: 1 }), 1, { value: 2 });
  }), 'Reflect', { defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      try {
        $.setDesc(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    } });
});
$__System.registerDynamic('a7', ['13', '12', '1c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        getDesc = $__require('12').getDesc,
        anObject = $__require('1c');
    $export($export.S, 'Reflect', { deleteProperty: function deleteProperty(target, propertyKey) {
            var desc = getDesc(anObject(target), propertyKey);
            return desc && !desc.configurable ? false : delete target[propertyKey];
        } });
});
$__System.registerDynamic('a8', ['13', '1c', 'a9'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13'),
      anObject = $__require('1c');
  var Enumerate = function (iterated) {
    this._t = anObject(iterated);
    this._i = 0;
    var keys = this._k = [],
        key;
    for (key in iterated) keys.push(key);
  };
  $__require('a9')(Enumerate, 'Object', function () {
    var that = this,
        keys = that._k,
        key;
    do {
      if (that._i >= keys.length) return {
        value: undefined,
        done: true
      };
    } while (!((key = keys[that._i++]) in that._t));
    return {
      value: key,
      done: false
    };
  });
  $export($export.S, 'Reflect', { enumerate: function enumerate(target) {
      return new Enumerate(target);
    } });
});
$__System.registerDynamic('aa', ['12', '18', '13', '1e', '1c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      has = $__require('18'),
      $export = $__require('13'),
      isObject = $__require('1e'),
      anObject = $__require('1c');
  function get(target, propertyKey) {
    var receiver = arguments.length < 3 ? target : arguments[2],
        desc,
        proto;
    if (anObject(target) === receiver) return target[propertyKey];
    if (desc = $.getDesc(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = $.getProto(target))) return get(proto, propertyKey, receiver);
  }
  $export($export.S, 'Reflect', { get: get });
});
$__System.registerDynamic('ab', ['12', '13', '1c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $ = $__require('12'),
        $export = $__require('13'),
        anObject = $__require('1c');
    $export($export.S, 'Reflect', { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
            return $.getDesc(anObject(target), propertyKey);
        } });
});
$__System.registerDynamic('ac', ['13', '12', '1c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        getProto = $__require('12').getProto,
        anObject = $__require('1c');
    $export($export.S, 'Reflect', { getPrototypeOf: function getPrototypeOf(target) {
            return getProto(anObject(target));
        } });
});
$__System.registerDynamic('ad', ['13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13');
    $export($export.S, 'Reflect', { has: function has(target, propertyKey) {
            return propertyKey in target;
        } });
});
$__System.registerDynamic('ae', ['13', '1c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        anObject = $__require('1c'),
        $isExtensible = Object.isExtensible;
    $export($export.S, 'Reflect', { isExtensible: function isExtensible(target) {
            anObject(target);
            return $isExtensible ? $isExtensible(target) : true;
        } });
});
$__System.registerDynamic('af', ['13', 'b0'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S, 'Reflect', { ownKeys: $__require('b0') });
});
$__System.registerDynamic('b1', ['13', '1c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      anObject = $__require('1c'),
      $preventExtensions = Object.preventExtensions;
  $export($export.S, 'Reflect', { preventExtensions: function preventExtensions(target) {
      anObject(target);
      try {
        if ($preventExtensions) $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    } });
});
$__System.registerDynamic('b2', ['12', '18', '13', '15', '1c', '1e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      has = $__require('18'),
      $export = $__require('13'),
      createDesc = $__require('15'),
      anObject = $__require('1c'),
      isObject = $__require('1e');
  function set(target, propertyKey, V) {
    var receiver = arguments.length < 4 ? target : arguments[3],
        ownDesc = $.getDesc(anObject(target), propertyKey),
        existingDescriptor,
        proto;
    if (!ownDesc) {
      if (isObject(proto = $.getProto(target))) {
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !isObject(receiver)) return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
  $export($export.S, 'Reflect', { set: set });
});
$__System.registerDynamic('38', ['12', '1e', '1c', '7b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var getDesc = $__require('12').getDesc,
      isObject = $__require('1e'),
      anObject = $__require('1c');
  var check = function (O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
      try {
        set = $__require('7b')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
});
$__System.registerDynamic('b3', ['13', '38'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      setProto = $__require('38');
  if (setProto) $export($export.S, 'Reflect', { setPrototypeOf: function setPrototypeOf(target, proto) {
      setProto.check(target, proto);
      try {
        setProto.set(target, proto);
        return true;
      } catch (e) {
        return false;
      }
    } });
});
$__System.registerDynamic('22', ['21'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('21'),
      max = Math.max,
      min = Math.min;
  module.exports = function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
});
$__System.registerDynamic('27', ['20', '23', '22'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('20'),
      toLength = $__require('23'),
      toIndex = $__require('22');
  module.exports = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index;
      }
      return !IS_INCLUDES && -1;
    };
  };
});
$__System.registerDynamic('b4', ['13', '27', '85'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        $includes = $__require('27')(true);
    $export($export.P, 'Array', { includes: function includes(el) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
        } });
    $__require('85')('includes');
});
$__System.registerDynamic('6e', ['21', '78'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('21'),
      defined = $__require('78');
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
});
$__System.registerDynamic('b5', ['13', '6e'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        $at = $__require('6e')(true);
    $export($export.P, 'String', { at: function at(pos) {
            return $at(this, pos);
        } });
});
$__System.registerDynamic('b6', ['13', 'b7'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        $pad = $__require('b7');
    $export($export.P, 'String', { padLeft: function padLeft(maxLength) {
            return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
        } });
});
$__System.registerDynamic('76', ['21', '78'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var toInteger = $__require('21'),
      defined = $__require('78');
  module.exports = function repeat(count) {
    var str = String(defined(this)),
        res = '',
        n = toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
    for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
    return res;
  };
});
$__System.registerDynamic('b7', ['23', '76', '78'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toLength = $__require('23'),
      repeat = $__require('76'),
      defined = $__require('78');
  module.exports = function (that, maxLength, fillString, left) {
    var S = String(defined(that)),
        stringLength = S.length,
        fillStr = fillString === undefined ? ' ' : String(fillString),
        intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength) return S;
    if (fillStr == '') fillStr = ' ';
    var fillLen = intMaxLength - stringLength,
        stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };
});
$__System.registerDynamic('b8', ['13', 'b7'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var $export = $__require('13'),
        $pad = $__require('b7');
    $export($export.P, 'String', { padRight: function padRight(maxLength) {
            return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
        } });
});
$__System.registerDynamic('b9', ['4b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  $__require('4b')('trimLeft', function ($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  });
});
$__System.registerDynamic('4b', ['13', '78', '1b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      defined = $__require('78'),
      fails = $__require('1b'),
      spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
      space = '[' + spaces + ']',
      non = '\u200b\u0085',
      ltrim = RegExp('^' + space + space + '*'),
      rtrim = RegExp(space + space + '*$');
  var exporter = function (KEY, exec) {
    var exp = {};
    exp[KEY] = exec(trim);
    $export($export.P + $export.F * fails(function () {
      return !!spaces[KEY]() || non[KEY]() != non;
    }), 'String', exp);
  };
  var trim = exporter.trim = function (string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
  module.exports = exporter;
});
$__System.registerDynamic('ba', ['4b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  $__require('4b')('trimRight', function ($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  });
});
$__System.registerDynamic('bb', ['13', 'bc'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        $re = $__require('bc')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
    $export($export.S, 'RegExp', { escape: function escape(it) {
            return $re(it);
        } });
});
$__System.registerDynamic('bd', ['12', '13', 'b0', '20', '15'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $ = $__require('12'),
        $export = $__require('13'),
        ownKeys = $__require('b0'),
        toIObject = $__require('20'),
        createDesc = $__require('15');
    $export($export.S, 'Object', { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
            var O = toIObject(object),
                setDesc = $.setDesc,
                getDesc = $.getDesc,
                keys = ownKeys(O),
                result = {},
                i = 0,
                key,
                D;
            while (keys.length > i) {
                D = getDesc(O, key = keys[i++]);
                if (key in result) setDesc(result, key, createDesc(0, D));else result[key] = D;
            }
            return result;
        } });
});
$__System.registerDynamic('be', ['13', 'bf'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        $values = $__require('bf')(false);
    $export($export.S, 'Object', { values: function values(it) {
            return $values(it);
        } });
});
$__System.registerDynamic('bf', ['12', '20'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      toIObject = $__require('20'),
      isEnum = $.isEnum;
  module.exports = function (isEntries) {
    return function (it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i) if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
      return result;
    };
  };
});
$__System.registerDynamic('c0', ['13', 'bf'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        $entries = $__require('bf')(true);
    $export($export.S, 'Object', { entries: function entries(it) {
            return $entries(it);
        } });
});
$__System.registerDynamic('c1', ['13', 'c2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.P, 'Map', { toJSON: $__require('c2')('Map') });
});
$__System.registerDynamic('c2', ['99', '3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var forOf = $__require('99'),
      classof = $__require('3a');
  module.exports = function (NAME) {
    return function toJSON() {
      if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
});
$__System.registerDynamic('c3', ['13', 'c2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.P, 'Set', { toJSON: $__require('c2')('Set') });
});
$__System.registerDynamic('c4', ['12', '13', '7b', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      $export = $__require('13'),
      $ctx = $__require('7b'),
      $Array = $__require('45').Array || Array,
      statics = {};
  var setStatics = function (keys, length) {
    $.each.call(keys.split(','), function (key) {
      if (length == undefined && key in $Array) statics[key] = $Array[key];else if (key in []) statics[key] = $ctx(Function.call, [][key], length);
    });
  };
  setStatics('pop,reverse,shift,keys,values,entries', 1);
  setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
  $export($export.S, 'Array', statics);
});
$__System.registerDynamic('c5', ['2b', '13', '1a', 'c6'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('2b'),
      $export = $__require('13'),
      invoke = $__require('1a'),
      partial = $__require('c6'),
      navigator = global.navigator,
      MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
  var wrap = function (set) {
    return MSIE ? function (fn, time) {
      return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
    } : set;
  };
  $export($export.G + $export.B + $export.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
  });
});
$__System.registerDynamic('16', ['2b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('2b').document && document.documentElement;
});
$__System.registerDynamic('17', ['1e', '2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var isObject = $__require('1e'),
        document = $__require('2b').document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function (it) {
        return is ? document.createElement(it) : {};
    };
});
$__System.registerDynamic('95', ['7b', '1a', '16', '17', '2b', '19', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var ctx = $__require('7b'),
        invoke = $__require('1a'),
        html = $__require('16'),
        cel = $__require('17'),
        global = $__require('2b'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function () {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function (event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function () {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('19')(process) == 'process') {
        defer = function (id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function (id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function (id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function (id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('96'));
});
$__System.registerDynamic('c7', ['13', '95'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13'),
      $task = $__require('95');
  $export($export.G + $export.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
});
$__System.registerDynamic('85', ['2f', '91'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var UNSCOPABLES = $__require('2f')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined) $__require('91')(ArrayProto, UNSCOPABLES, {});
  module.exports = function (key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
});
$__System.registerDynamic('c8', ['85', '9e', 'c9', '20', '6f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var addToUnscopables = $__require('85'),
      step = $__require('9e'),
      Iterators = $__require('c9'),
      toIObject = $__require('20');
  module.exports = $__require('6f')(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
});
$__System.registerDynamic('ca', ['c8', '2b', '91', 'c9', '2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('c8');
  var global = $__require('2b'),
      hide = $__require('91'),
      Iterators = $__require('c9'),
      ITERATOR = $__require('2f')('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NLProto && !NLProto[ITERATOR]) hide(NLProto, ITERATOR, ArrayValues);
  if (HTCProto && !HTCProto[ITERATOR]) hide(HTCProto, ITERATOR, ArrayValues);
});
$__System.registerDynamic('cb', ['11', '2a', '33', '35', '37', '39', '3b', '3d', '3e', '3f', '40', '41', '42', '43', '44', '46', '47', '48', '4a', '4c', '4d', '4e', '50', '51', '52', '53', '54', '55', '56', '58', '59', '5a', '5c', '5d', '5e', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '70', '71', '74', '75', '79', '7a', '80', 'c8', '81', '84', '87', '88', '89', '8a', '8c', '8d', '8f', '90', '92', '97', '9b', '9f', 'a0', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b8', 'b9', 'ba', 'bb', 'bd', 'be', 'c0', 'c1', 'c3', 'c4', 'c5', 'c7', 'ca', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('11');
  $__require('2a');
  $__require('33');
  $__require('35');
  $__require('37');
  $__require('39');
  $__require('3b');
  $__require('3d');
  $__require('3e');
  $__require('3f');
  $__require('40');
  $__require('41');
  $__require('42');
  $__require('43');
  $__require('44');
  $__require('46');
  $__require('47');
  $__require('48');
  $__require('4a');
  $__require('4c');
  $__require('4d');
  $__require('4e');
  $__require('50');
  $__require('51');
  $__require('52');
  $__require('53');
  $__require('54');
  $__require('55');
  $__require('56');
  $__require('58');
  $__require('59');
  $__require('5a');
  $__require('5c');
  $__require('5d');
  $__require('5e');
  $__require('60');
  $__require('61');
  $__require('62');
  $__require('63');
  $__require('64');
  $__require('65');
  $__require('66');
  $__require('67');
  $__require('68');
  $__require('69');
  $__require('6a');
  $__require('6b');
  $__require('6c');
  $__require('6d');
  $__require('70');
  $__require('71');
  $__require('74');
  $__require('75');
  $__require('79');
  $__require('7a');
  $__require('80');
  $__require('c8');
  $__require('81');
  $__require('84');
  $__require('87');
  $__require('88');
  $__require('89');
  $__require('8a');
  $__require('8c');
  $__require('8d');
  $__require('8f');
  $__require('90');
  $__require('92');
  $__require('97');
  $__require('9b');
  $__require('9f');
  $__require('a0');
  $__require('a3');
  $__require('a4');
  $__require('a5');
  $__require('a6');
  $__require('a7');
  $__require('a8');
  $__require('aa');
  $__require('ab');
  $__require('ac');
  $__require('ad');
  $__require('ae');
  $__require('af');
  $__require('b1');
  $__require('b2');
  $__require('b3');
  $__require('b4');
  $__require('b5');
  $__require('b6');
  $__require('b8');
  $__require('b9');
  $__require('ba');
  $__require('bb');
  $__require('bd');
  $__require('be');
  $__require('c0');
  $__require('c1');
  $__require('c3');
  $__require('c4');
  $__require('c5');
  $__require('c7');
  $__require('ca');
  module.exports = $__require('45');
});
$__System.registerDynamic('30', ['12', '20'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $ = $__require('12'),
        toIObject = $__require('20');
    module.exports = function (object, el) {
        var O = toIObject(object),
            keys = $.getKeys(O),
            length = keys.length,
            index = 0,
            key;
        while (length > index) if (O[key = keys[index++]] === el) return key;
    };
});
$__System.registerDynamic('7c', ['1c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('1c');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
});
$__System.registerDynamic('7d', ['c9', '2f'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var Iterators = $__require('c9'),
        ITERATOR = $__require('2f')('iterator'),
        ArrayProto = Array.prototype;
    module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
});
$__System.registerDynamic("21", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
});
$__System.registerDynamic('23', ['21'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('21'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
});
$__System.registerDynamic('99', ['7b', '7c', '7d', '1c', '23', '7e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('7b'),
      call = $__require('7c'),
      isArrayIter = $__require('7d'),
      anObject = $__require('1c'),
      toLength = $__require('23'),
      getIterFn = $__require('7e');
  module.exports = function (iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
      entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      call(iterator, f, step.value, entries);
    }
  };
});
$__System.registerDynamic("9e", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };
});
$__System.registerDynamic('cc', ['12', '7b', '13', '15', '34', '30', '1d', '99', 'cd', 'a9', '9e', '1e', '20', '14', '18'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      ctx = $__require('7b'),
      $export = $__require('13'),
      createDesc = $__require('15'),
      assign = $__require('34'),
      keyOf = $__require('30'),
      aFunction = $__require('1d'),
      forOf = $__require('99'),
      isIterable = $__require('cd'),
      $iterCreate = $__require('a9'),
      step = $__require('9e'),
      isObject = $__require('1e'),
      toIObject = $__require('20'),
      DESCRIPTORS = $__require('14'),
      has = $__require('18'),
      getKeys = $.getKeys;
  var createDictMethod = function (TYPE) {
    var IS_MAP = TYPE == 1,
        IS_EVERY = TYPE == 4;
    return function (object, callbackfn, that) {
      var f = ctx(callbackfn, that, 3),
          O = toIObject(object),
          result = IS_MAP || TYPE == 7 || TYPE == 2 ? new (typeof this == 'function' ? this : Dict)() : undefined,
          key,
          val,
          res;
      for (key in O) if (has(O, key)) {
        val = O[key];
        res = f(val, key, object);
        if (TYPE) {
          if (IS_MAP) result[key] = res;else if (res) switch (TYPE) {
            case 2:
              result[key] = val;
              break;
            case 3:
              return true;
            case 5:
              return val;
            case 6:
              return key;
            case 7:
              result[res[0]] = res[1];
          } else if (IS_EVERY) return false;
        }
      }
      return TYPE == 3 || IS_EVERY ? IS_EVERY : result;
    };
  };
  var findKey = createDictMethod(6);
  var createDictIter = function (kind) {
    return function (it) {
      return new DictIterator(it, kind);
    };
  };
  var DictIterator = function (iterated, kind) {
    this._t = toIObject(iterated);
    this._a = getKeys(iterated);
    this._i = 0;
    this._k = kind;
  };
  $iterCreate(DictIterator, 'Dict', function () {
    var that = this,
        O = that._t,
        keys = that._a,
        kind = that._k,
        key;
    do {
      if (that._i >= keys.length) {
        that._t = undefined;
        return step(1);
      }
    } while (!has(O, key = keys[that._i++]));
    if (kind == 'keys') return step(0, key);
    if (kind == 'values') return step(0, O[key]);
    return step(0, [key, O[key]]);
  });
  function Dict(iterable) {
    var dict = $.create(null);
    if (iterable != undefined) {
      if (isIterable(iterable)) {
        forOf(iterable, true, function (key, value) {
          dict[key] = value;
        });
      } else assign(dict, iterable);
    }
    return dict;
  }
  Dict.prototype = null;
  function reduce(object, mapfn, init) {
    aFunction(mapfn);
    var O = toIObject(object),
        keys = getKeys(O),
        length = keys.length,
        i = 0,
        memo,
        key;
    if (arguments.length < 3) {
      if (!length) throw TypeError('Reduce of empty object with no initial value');
      memo = O[keys[i++]];
    } else memo = Object(init);
    while (length > i) if (has(O, key = keys[i++])) {
      memo = mapfn(memo, O[key], key, object);
    }
    return memo;
  }
  function includes(object, el) {
    return (el == el ? keyOf(object, el) : findKey(object, function (it) {
      return it != it;
    })) !== undefined;
  }
  function get(object, key) {
    if (has(object, key)) return object[key];
  }
  function set(object, key, value) {
    if (DESCRIPTORS && key in Object) $.setDesc(object, key, createDesc(0, value));else object[key] = value;
    return object;
  }
  function isDict(it) {
    return isObject(it) && $.getProto(it) === Dict.prototype;
  }
  $export($export.G + $export.F, { Dict: Dict });
  $export($export.S, 'Dict', {
    keys: createDictIter('keys'),
    values: createDictIter('values'),
    entries: createDictIter('entries'),
    forEach: createDictMethod(0),
    map: createDictMethod(1),
    filter: createDictMethod(2),
    some: createDictMethod(3),
    every: createDictMethod(4),
    find: createDictMethod(5),
    findKey: findKey,
    mapPairs: createDictMethod(7),
    reduce: reduce,
    keyOf: keyOf,
    includes: includes,
    has: has,
    get: get,
    set: set,
    isDict: isDict
  });
});
$__System.registerDynamic('7e', ['3a', '2f', 'c9', '45'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var classof = $__require('3a'),
        ITERATOR = $__require('2f')('iterator'),
        Iterators = $__require('c9');
    module.exports = $__require('45').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
    };
});
$__System.registerDynamic('ce', ['1c', '7e', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('1c'),
      get = $__require('7e');
  module.exports = $__require('45').getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
});
$__System.registerDynamic('cd', ['3a', '2f', 'c9', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var classof = $__require('3a'),
      ITERATOR = $__require('2f')('iterator'),
      Iterators = $__require('c9');
  module.exports = $__require('45').isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
});
$__System.registerDynamic('cf', ['2b', '45', '13', 'c6'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var global = $__require('2b'),
        core = $__require('45'),
        $export = $__require('13'),
        partial = $__require('c6');
    $export($export.G + $export.F, { delay: function delay(time) {
            return new (core.Promise || global.Promise)(function (resolve) {
                setTimeout(partial.call(resolve, true), time);
            });
        } });
});
$__System.registerDynamic('d0', ['2b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('2b');
});
$__System.registerDynamic("1a", [], true, function ($__require, exports, module) {
                  var global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
});
$__System.registerDynamic('c6', ['d0', '1a', '1d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var path = $__require('d0'),
      invoke = $__require('1a'),
      aFunction = $__require('1d');
  module.exports = function () {
    var fn = aFunction(this),
        length = arguments.length,
        pargs = Array(length),
        i = 0,
        _ = path._,
        holder = false;
    while (length > i) if ((pargs[i] = arguments[i++]) === _) holder = true;
    return function () {
      var that = this,
          $$ = arguments,
          $$len = $$.length,
          j = 0,
          k = 0,
          args;
      if (!holder && !$$len) return invoke(fn, pargs, that);
      args = pargs.slice();
      if (holder) for (; length > j; j++) if (args[j] === _) args[j] = $$[k++];
      while ($$len > k) args.push($$[k++]);
      return invoke(fn, args, that);
    };
  };
});
$__System.registerDynamic('d1', ['d0', '13', '45', 'c6'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var path = $__require('d0'),
        $export = $__require('13');
    $__require('45')._ = path._ = path._ || {};
    $export($export.P + $export.F, 'Function', { part: $__require('c6') });
});
$__System.registerDynamic('d2', ['13', '1e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', { isObject: $__require('1e') });
});
$__System.registerDynamic('3a', ['19', '2f'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var cof = $__require('19'),
        TAG = $__require('2f')('toStringTag'),
        ARG = cof(function () {
        return arguments;
    }()) == 'Arguments';
    module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
    };
});
$__System.registerDynamic('d3', ['13', '3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', { classof: $__require('3a') });
});
$__System.registerDynamic('d4', ['13', 'd5'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        define = $__require('d5');
    $export($export.S + $export.F, 'Object', { define: define });
});
$__System.registerDynamic('1e', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
$__System.registerDynamic('1c', ['1e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('1e');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
$__System.registerDynamic('b0', ['12', '1c', '2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $ = $__require('12'),
        anObject = $__require('1c'),
        Reflect = $__require('2b').Reflect;
    module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
        var keys = $.getNames(anObject(it)),
            getSymbols = $.getSymbols;
        return getSymbols ? keys.concat(getSymbols(it)) : keys;
    };
});
$__System.registerDynamic('20', ['24', '78'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var IObject = $__require('24'),
      defined = $__require('78');
  module.exports = function (it) {
    return IObject(defined(it));
  };
});
$__System.registerDynamic('d5', ['12', 'b0', '20'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $ = $__require('12'),
        ownKeys = $__require('b0'),
        toIObject = $__require('20');
    module.exports = function define(target, mixin) {
        var keys = ownKeys(toIObject(mixin)),
            length = keys.length,
            i = 0,
            key;
        while (length > i) $.setDesc(target, key = keys[i++], $.getDesc(mixin, key));
        return target;
    };
});
$__System.registerDynamic('d6', ['13', 'd5', '12'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('13'),
        define = $__require('d5'),
        create = $__require('12').create;
    $export($export.S + $export.F, 'Object', { make: function (proto, mixin) {
            return define(create(proto), mixin);
        } });
});
$__System.registerDynamic("32", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = false;
});
$__System.registerDynamic("c9", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {};
});
$__System.registerDynamic('a9', ['12', '15', '2e', '91', '2f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('12'),
      descriptor = $__require('15'),
      setToStringTag = $__require('2e'),
      IteratorPrototype = {};
  $__require('91')(IteratorPrototype, $__require('2f')('iterator'), function () {
    return this;
  });
  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
});
$__System.registerDynamic("18", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
});
$__System.registerDynamic('2e', ['12', '18', '2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var def = $__require('12').setDesc,
      has = $__require('18'),
      TAG = $__require('2f')('toStringTag');
  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  };
});
$__System.registerDynamic('2d', ['2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var global = $__require('2b'),
        SHARED = '__core-js_shared__',
        store = global[SHARED] || (global[SHARED] = {});
    module.exports = function (key) {
        return store[key] || (store[key] = {});
    };
});
$__System.registerDynamic('2f', ['2d', '25', '2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var store = $__require('2d')('wks'),
        uid = $__require('25'),
        Symbol = $__require('2b').Symbol;
    module.exports = function (name) {
        return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
    };
});
$__System.registerDynamic('6f', ['32', '13', '2c', '91', '18', 'c9', 'a9', '2e', '12', '2f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('32'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      hide = $__require('91'),
      has = $__require('18'),
      Iterators = $__require('c9'),
      $iterCreate = $__require('a9'),
      setToStringTag = $__require('2e'),
      getProto = $__require('12').getProto,
      ITERATOR = $__require('2f')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function () {
    return this;
  };
  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base()));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
});
$__System.registerDynamic('d7', ['6f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  $__require('6f')(Number, 'Number', function (iterated) {
    this._l = +iterated;
    this._i = 0;
  }, function () {
    var i = this._i++,
        done = !(i < this._l);
    return {
      done: done,
      value: done ? undefined : i
    };
  });
});
$__System.registerDynamic('d8', ['13', 'bc'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13');
  var $re = $__require('bc')(/[&<>"']/g, {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  });
  $export($export.P + $export.F, 'String', { escapeHTML: function escapeHTML() {
      return $re(this);
    } });
});
$__System.registerDynamic("bc", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (regExp, replace) {
    var replacer = replace === Object(replace) ? function (part) {
      return replace[part];
    } : replace;
    return function (it) {
      return String(it).replace(regExp, replacer);
    };
  };
});
$__System.registerDynamic('d9', ['13', 'bc'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $export = $__require('13');
  var $re = $__require('bc')(/&(?:amp|lt|gt|quot|apos);/g, {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': "'"
  });
  $export($export.P + $export.F, 'String', { unescapeHTML: function unescapeHTML() {
      return $re(this);
    } });
});
$__System.registerDynamic('2b', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic("15", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
});
$__System.registerDynamic('14', ['1b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('1b')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
$__System.registerDynamic('91', ['12', '15', '14'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      createDesc = $__require('15');
  module.exports = $__require('14') ? function (object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
});
$__System.registerDynamic('25', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
});
$__System.registerDynamic('2c', ['2b', '91', '25', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('2b'),
      hide = $__require('91'),
      SRC = $__require('25')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  $__require('45').inspectSource = function (it) {
    return $toString.call(it);
  };
  (module.exports = function (O, key, val, safe) {
    if (typeof val == 'function') {
      val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      val.hasOwnProperty('name') || hide(val, 'name', key);
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe) delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});
$__System.registerDynamic('1d', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('7b', ['1d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('1d');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic('13', ['2b', '45', '91', '2c', '7b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('2b'),
      core = $__require('45'),
      hide = $__require('91'),
      redefine = $__require('2c'),
      ctx = $__require('7b'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      out = (own ? target : source)[key];
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own) redefine(target, key, out);
      if (exports[key] != out) hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  global.core = core;
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
$__System.registerDynamic("12", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
$__System.registerDynamic("78", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
$__System.registerDynamic('1f', ['78'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defined = $__require('78');
  module.exports = function (it) {
    return Object(defined(it));
  };
});
$__System.registerDynamic("19", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('24', ['19'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('19');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
$__System.registerDynamic("1b", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('34', ['12', '1f', '24', '1b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      toObject = $__require('1f'),
      IObject = $__require('24');
  module.exports = $__require('1b')(function () {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
    return T;
  } : Object.assign;
});
$__System.registerDynamic('da', ['12', '2b', '13', '34'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('12'),
      global = $__require('2b'),
      $export = $__require('13'),
      log = {},
      enabled = true;
  $.each.call(('assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,' + 'info,isIndependentlyComposed,log,markTimeline,profile,profileEnd,table,' + 'time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(','), function (key) {
    log[key] = function () {
      var $console = global.console;
      if (enabled && $console && $console[key]) {
        return Function.apply.call($console[key], $console, arguments);
      }
    };
  });
  $export($export.G + $export.F, { log: $__require('34')(log.log, log, {
      enable: function () {
        enabled = true;
      },
      disable: function () {
        enabled = false;
      }
    }) });
});
$__System.registerDynamic('45', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('db', ['cb', 'cc', '7e', 'ce', 'cd', 'cf', 'd1', 'd2', 'd3', 'd4', 'd6', 'd7', 'd8', 'd9', 'da', '45'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('cb');
  $__require('cc');
  $__require('7e');
  $__require('ce');
  $__require('cd');
  $__require('cf');
  $__require('d1');
  $__require('d2');
  $__require('d3');
  $__require('d4');
  $__require('d6');
  $__require('d7');
  $__require('d8');
  $__require('d9');
  $__require('da');
  module.exports = $__require('45');
});
$__System.registerDynamic("dc", ["db"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("db");
});
$__System.registerDynamic('dd', [], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
  (function (self) {
    'use strict';

    if (self.fetch) {
      return;
    }

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

      var isDataView = function (obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };

      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }
      return name.toLowerCase();
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value;
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function () {
          var value = items.shift();
          return { done: value === undefined, value: value };
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var list = this.map[name];
      if (!list) {
        list = [];
        this.map[name] = list;
      }
      list.push(value);
    };

    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
      var values = this.map[normalizeName(name)];
      return values ? values[0] : null;
    };

    Headers.prototype.getAll = function (name) {
      return this.map[normalizeName(name)] || [];
    };

    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = [normalizeValue(value)];
    };

    Headers.prototype.forEach = function (callback, thisArg) {
      Object.getOwnPropertyNames(this.map).forEach(function (name) {
        this.map[name].forEach(function (value) {
          callback.call(thisArg, value, name, this);
        }, this);
      }, this);
    };

    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };

    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };
        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('');
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function (body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error('unsupported BodyInit type');
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };

        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }

      this.text = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };

      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }

      this.json = function () {
        return this.text().then(JSON.parse);
      };

      return this;
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (typeof input === 'string') {
        this.url = input;
      } else {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      }

      this.credentials = options.credentials || this.credentials || 'omit';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }
      this._initBody(body);
    }

    Request.prototype.clone = function () {
      return new Request(this, { body: this._bodyInit });
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      rawHeaders.split('\r\n').forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = 'status' in options ? options.status : 200;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };

    Response.error = function () {
      var response = new Response(null, { status: 0, statusText: '' });
      response.type = 'error';
      return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }

      return new Response(null, { status: status, headers: { location: url } });
    };

    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;

    self.fetch = function (input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        var xhr = new XMLHttpRequest();

        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        }

        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }

        request.headers.forEach(function (value, name) {
          xhr.setRequestHeader(name, value);
        });

        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    };
    self.fetch.polyfill = true;
  })(typeof self !== 'undefined' ? self : this);
});
$__System.registerDynamic("de", ["dd"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("dd");
});
$__System.registerDynamic("df", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  /*! JSON Editor v0.7.28 - JSON Schema -> HTML Editor
   * By Jeremy Dorn - https://github.com/jdorn/json-editor/
   * Released under the MIT license
   *
   * Date: 2016-08-07
   */

  /**
   * See README.md for requirements and usage info
   */

  var global = this || self,
      GLOBAL = global;
  (function () {

    /*jshint loopfunc: true */
    /* Simple JavaScript Inheritance
     * By John Resig http://ejohn.org/
     * MIT Licensed.
     */
    // Inspired by base2 and Prototype
    var Class;
    (function () {
      var initializing = false,
          fnTest = /xyz/.test(function () {
        window.postMessage("xyz");
      }) ? /\b_super\b/ : /.*/;

      // The base Class implementation (does nothing)
      Class = function () {};

      // Create a new Class that inherits from this class
      Class.extend = function extend(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
          // Check if we're overwriting an existing function
          prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? function (name, fn) {
            return function () {
              var tmp = this._super;

              // Add a new ._super() method that is the same method
              // but on the super-class
              this._super = _super[name];

              // The method only need to be bound temporarily, so we
              // remove it when we're done executing
              var ret = fn.apply(this, arguments);
              this._super = tmp;

              return ret;
            };
          }(name, prop[name]) : prop[name];
        }

        // The dummy class constructor
        function Class() {
          // All construction is actually done in the init method
          if (!initializing && this.init) this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = extend;

        return Class;
      };

      return Class;
    })();

    // CustomEvent constructor polyfill
    // From MDN
    (function () {
      function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }

      CustomEvent.prototype = window.Event.prototype;

      window.CustomEvent = CustomEvent;
    })();

    // requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel
    // MIT license
    (function () {
      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
      }

      if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };

      if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
    })();

    // Array.isArray polyfill
    // From MDN
    (function () {
      if (!Array.isArray) {
        Array.isArray = function (arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };
      }
    })();
    /**
     * Taken from jQuery 2.1.3
     *
     * @param obj
     * @returns {boolean}
     */
    var $isplainobject = function (obj) {
      // Not plain objects:
      // - Any object or value whose internal [[Class]] property is not "[object Object]"
      // - DOM nodes
      // - window
      if (typeof obj !== "object" || obj.nodeType || obj !== null && obj === obj.window) {
        return false;
      }

      if (obj.constructor && !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }

      // If the function hasn't returned already, we're confident that
      // |obj| is a plain object, created by {} or constructed with new Object
      return true;
    };

    var $extend = function (destination) {
      var source, i, property;
      for (i = 1; i < arguments.length; i++) {
        source = arguments[i];
        for (property in source) {
          if (!source.hasOwnProperty(property)) continue;
          if (source[property] && $isplainobject(source[property])) {
            if (!destination.hasOwnProperty(property)) destination[property] = {};
            $extend(destination[property], source[property]);
          } else {
            destination[property] = source[property];
          }
        }
      }
      return destination;
    };

    var $each = function (obj, callback) {
      if (!obj || typeof obj !== "object") return;
      var i;
      if (Array.isArray(obj) || typeof obj.length === 'number' && obj.length > 0 && obj.length - 1 in obj) {
        for (i = 0; i < obj.length; i++) {
          if (callback(i, obj[i]) === false) return;
        }
      } else {
        if (Object.keys) {
          var keys = Object.keys(obj);
          for (i = 0; i < keys.length; i++) {
            if (callback(keys[i], obj[keys[i]]) === false) return;
          }
        } else {
          for (i in obj) {
            if (!obj.hasOwnProperty(i)) continue;
            if (callback(i, obj[i]) === false) return;
          }
        }
      }
    };

    var $trigger = function (el, event) {
      var e = document.createEvent('HTMLEvents');
      e.initEvent(event, true, true);
      el.dispatchEvent(e);
    };
    var $triggerc = function (el, event) {
      var e = new CustomEvent(event, {
        bubbles: true,
        cancelable: true
      });

      el.dispatchEvent(e);
    };

    var JSONEditor = function (element, options) {
      if (!(element instanceof Element)) {
        throw new Error('element should be an instance of Element');
      }
      options = $extend({}, JSONEditor.defaults.options, options || {});
      this.element = element;
      this.options = options;
      this.init();
    };
    JSONEditor.prototype = {
      // necessary since we remove the ctor property by doing a literal assignment. Without this
      // the $isplainobject function will think that this is a plain object.
      constructor: JSONEditor,
      init: function () {
        var self = this;

        this.ready = false;

        var theme_class = JSONEditor.defaults.themes[this.options.theme || JSONEditor.defaults.theme];
        if (!theme_class) throw "Unknown theme " + (this.options.theme || JSONEditor.defaults.theme);

        this.schema = this.options.schema;
        this.theme = new theme_class();
        this.template = this.options.template;
        this.refs = this.options.refs || {};
        this.uuid = 0;
        this.__data = {};

        var icon_class = JSONEditor.defaults.iconlibs[this.options.iconlib || JSONEditor.defaults.iconlib];
        if (icon_class) this.iconlib = new icon_class();

        this.root_container = this.theme.getContainer();
        this.element.appendChild(this.root_container);

        this.translate = this.options.translate || JSONEditor.defaults.translate;

        // Fetch all external refs via ajax
        this._loadExternalRefs(this.schema, function () {
          self._getDefinitions(self.schema);

          // Validator options
          var validator_options = {};
          if (self.options.custom_validators) {
            validator_options.custom_validators = self.options.custom_validators;
          }
          self.validator = new JSONEditor.Validator(self, null, validator_options);

          // Create the root editor
          var editor_class = self.getEditorClass(self.schema);
          self.root = self.createEditor(editor_class, {
            jsoneditor: self,
            schema: self.schema,
            required: true,
            container: self.root_container
          });

          self.root.preBuild();
          self.root.build();
          self.root.postBuild();

          // Starting data
          if (self.options.startval) self.root.setValue(self.options.startval);

          self.validation_results = self.validator.validate(self.root.getValue());
          self.root.showValidationErrors(self.validation_results);
          self.ready = true;

          // Fire ready event asynchronously
          window.requestAnimationFrame(function () {
            if (!self.ready) return;
            self.validation_results = self.validator.validate(self.root.getValue());
            self.root.showValidationErrors(self.validation_results);
            self.trigger('ready');
            self.trigger('change');
          });
        });
      },
      getValue: function () {
        if (!this.ready) throw "JSON Editor not ready yet.  Listen for 'ready' event before getting the value";

        return this.root.getValue();
      },
      setValue: function (value) {
        if (!this.ready) throw "JSON Editor not ready yet.  Listen for 'ready' event before setting the value";

        this.root.setValue(value);
        return this;
      },
      validate: function (value) {
        if (!this.ready) throw "JSON Editor not ready yet.  Listen for 'ready' event before validating";

        // Custom value
        if (arguments.length === 1) {
          return this.validator.validate(value);
        }
        // Current value (use cached result)
        else {
            return this.validation_results;
          }
      },
      destroy: function () {
        if (this.destroyed) return;
        if (!this.ready) return;

        this.schema = null;
        this.options = null;
        this.root.destroy();
        this.root = null;
        this.root_container = null;
        this.validator = null;
        this.validation_results = null;
        this.theme = null;
        this.iconlib = null;
        this.template = null;
        this.__data = null;
        this.ready = false;
        this.element.innerHTML = '';

        this.destroyed = true;
      },
      on: function (event, callback) {
        this.callbacks = this.callbacks || {};
        this.callbacks[event] = this.callbacks[event] || [];
        this.callbacks[event].push(callback);

        return this;
      },
      off: function (event, callback) {
        // Specific callback
        if (event && callback) {
          this.callbacks = this.callbacks || {};
          this.callbacks[event] = this.callbacks[event] || [];
          var newcallbacks = [];
          for (var i = 0; i < this.callbacks[event].length; i++) {
            if (this.callbacks[event][i] === callback) continue;
            newcallbacks.push(this.callbacks[event][i]);
          }
          this.callbacks[event] = newcallbacks;
        }
        // All callbacks for a specific event
        else if (event) {
            this.callbacks = this.callbacks || {};
            this.callbacks[event] = [];
          }
          // All callbacks for all events
          else {
              this.callbacks = {};
            }

        return this;
      },
      trigger: function (event) {
        if (this.callbacks && this.callbacks[event] && this.callbacks[event].length) {
          for (var i = 0; i < this.callbacks[event].length; i++) {
            this.callbacks[event][i]();
          }
        }

        return this;
      },
      setOption: function (option, value) {
        if (option === "show_errors") {
          this.options.show_errors = value;
          this.onChange();
        }
        // Only the `show_errors` option is supported for now
        else {
            throw "Option " + option + " must be set during instantiation and cannot be changed later";
          }

        return this;
      },
      getEditorClass: function (schema) {
        var classname;

        schema = this.expandSchema(schema);

        $each(JSONEditor.defaults.resolvers, function (i, resolver) {
          var tmp = resolver(schema);
          if (tmp) {
            if (JSONEditor.defaults.editors[tmp]) {
              classname = tmp;
              return false;
            }
          }
        });

        if (!classname) throw "Unknown editor for schema " + JSON.stringify(schema);
        if (!JSONEditor.defaults.editors[classname]) throw "Unknown editor " + classname;

        return JSONEditor.defaults.editors[classname];
      },
      createEditor: function (editor_class, options) {
        options = $extend({}, editor_class.options || {}, options);
        return new editor_class(options);
      },
      onChange: function () {
        if (!this.ready) return;

        if (this.firing_change) return;
        this.firing_change = true;

        var self = this;

        window.requestAnimationFrame(function () {
          self.firing_change = false;
          if (!self.ready) return;

          // Validate and cache results
          self.validation_results = self.validator.validate(self.root.getValue());

          if (self.options.show_errors !== "never") {
            self.root.showValidationErrors(self.validation_results);
          } else {
            self.root.showValidationErrors([]);
          }

          // Fire change event
          self.trigger('change');
        });

        return this;
      },
      compileTemplate: function (template, name) {
        name = name || JSONEditor.defaults.template;

        var engine;

        // Specifying a preset engine
        if (typeof name === 'string') {
          if (!JSONEditor.defaults.templates[name]) throw "Unknown template engine " + name;
          engine = JSONEditor.defaults.templates[name]();

          if (!engine) throw "Template engine " + name + " missing required library.";
        }
        // Specifying a custom engine
        else {
            engine = name;
          }

        if (!engine) throw "No template engine set";
        if (!engine.compile) throw "Invalid template engine set";

        return engine.compile(template);
      },
      _data: function (el, key, value) {
        // Setting data
        if (arguments.length === 3) {
          var uuid;
          if (el.hasAttribute('data-jsoneditor-' + key)) {
            uuid = el.getAttribute('data-jsoneditor-' + key);
          } else {
            uuid = this.uuid++;
            el.setAttribute('data-jsoneditor-' + key, uuid);
          }

          this.__data[uuid] = value;
        }
        // Getting data
        else {
            // No data stored
            if (!el.hasAttribute('data-jsoneditor-' + key)) return null;

            return this.__data[el.getAttribute('data-jsoneditor-' + key)];
          }
      },
      registerEditor: function (editor) {
        this.editors = this.editors || {};
        this.editors[editor.path] = editor;
        return this;
      },
      unregisterEditor: function (editor) {
        this.editors = this.editors || {};
        this.editors[editor.path] = null;
        return this;
      },
      getEditor: function (path) {
        if (!this.editors) return;
        return this.editors[path];
      },
      watch: function (path, callback) {
        this.watchlist = this.watchlist || {};
        this.watchlist[path] = this.watchlist[path] || [];
        this.watchlist[path].push(callback);

        return this;
      },
      unwatch: function (path, callback) {
        if (!this.watchlist || !this.watchlist[path]) return this;
        // If removing all callbacks for a path
        if (!callback) {
          this.watchlist[path] = null;
          return this;
        }

        var newlist = [];
        for (var i = 0; i < this.watchlist[path].length; i++) {
          if (this.watchlist[path][i] === callback) continue;else newlist.push(this.watchlist[path][i]);
        }
        this.watchlist[path] = newlist.length ? newlist : null;
        return this;
      },
      notifyWatchers: function (path) {
        if (!this.watchlist || !this.watchlist[path]) return this;
        for (var i = 0; i < this.watchlist[path].length; i++) {
          this.watchlist[path][i]();
        }
      },
      isEnabled: function () {
        return !this.root || this.root.isEnabled();
      },
      enable: function () {
        this.root.enable();
      },
      disable: function () {
        this.root.disable();
      },
      _getDefinitions: function (schema, path) {
        path = path || '#/definitions/';
        if (schema.definitions) {
          for (var i in schema.definitions) {
            if (!schema.definitions.hasOwnProperty(i)) continue;
            this.refs[path + i] = schema.definitions[i];
            if (schema.definitions[i].definitions) {
              this._getDefinitions(schema.definitions[i], path + i + '/definitions/');
            }
          }
        }
      },
      _getExternalRefs: function (schema) {
        var refs = {};
        var merge_refs = function (newrefs) {
          for (var i in newrefs) {
            if (newrefs.hasOwnProperty(i)) {
              refs[i] = true;
            }
          }
        };

        if (schema.$ref && typeof schema.$ref !== "object" && schema.$ref.substr(0, 1) !== "#" && !this.refs[schema.$ref]) {
          refs[schema.$ref] = true;
        }

        for (var i in schema) {
          if (!schema.hasOwnProperty(i)) continue;
          if (schema[i] && typeof schema[i] === "object" && Array.isArray(schema[i])) {
            for (var j = 0; j < schema[i].length; j++) {
              if (typeof schema[i][j] === "object") {
                merge_refs(this._getExternalRefs(schema[i][j]));
              }
            }
          } else if (schema[i] && typeof schema[i] === "object") {
            merge_refs(this._getExternalRefs(schema[i]));
          }
        }

        return refs;
      },
      _loadExternalRefs: function (schema, callback) {
        var self = this;
        var refs = this._getExternalRefs(schema);

        var done = 0,
            waiting = 0,
            callback_fired = false;

        $each(refs, function (url) {
          if (self.refs[url]) return;
          if (!self.options.ajax) throw "Must set ajax option to true to load external ref " + url;
          self.refs[url] = 'loading';
          waiting++;

          var r = new XMLHttpRequest();
          r.open("GET", url, true);
          r.onreadystatechange = function () {
            if (r.readyState != 4) return;
            // Request succeeded
            if (r.status === 200) {
              var response;
              try {
                response = JSON.parse(r.responseText);
              } catch (e) {
                window.console.log(e);
                throw "Failed to parse external ref " + url;
              }
              if (!response || typeof response !== "object") throw "External ref does not contain a valid schema - " + url;

              self.refs[url] = response;
              self._loadExternalRefs(response, function () {
                done++;
                if (done >= waiting && !callback_fired) {
                  callback_fired = true;
                  callback();
                }
              });
            }
            // Request failed
            else {
                window.console.log(r);
                throw "Failed to fetch ref via ajax- " + url;
              }
          };
          r.send();
        });

        if (!waiting) {
          callback();
        }
      },
      expandRefs: function (schema) {
        schema = $extend({}, schema);

        while (schema.$ref) {
          var ref = schema.$ref;
          delete schema.$ref;

          if (!this.refs[ref]) ref = decodeURIComponent(ref);

          schema = this.extendSchemas(schema, this.refs[ref]);
        }
        return schema;
      },
      expandSchema: function (schema) {
        var self = this;
        var extended = $extend({}, schema);
        var i;

        // Version 3 `type`
        if (typeof schema.type === 'object') {
          // Array of types
          if (Array.isArray(schema.type)) {
            $each(schema.type, function (key, value) {
              // Schema
              if (typeof value === 'object') {
                schema.type[key] = self.expandSchema(value);
              }
            });
          }
          // Schema
          else {
              schema.type = self.expandSchema(schema.type);
            }
        }
        // Version 3 `disallow`
        if (typeof schema.disallow === 'object') {
          // Array of types
          if (Array.isArray(schema.disallow)) {
            $each(schema.disallow, function (key, value) {
              // Schema
              if (typeof value === 'object') {
                schema.disallow[key] = self.expandSchema(value);
              }
            });
          }
          // Schema
          else {
              schema.disallow = self.expandSchema(schema.disallow);
            }
        }
        // Version 4 `anyOf`
        if (schema.anyOf) {
          $each(schema.anyOf, function (key, value) {
            schema.anyOf[key] = self.expandSchema(value);
          });
        }
        // Version 4 `dependencies` (schema dependencies)
        if (schema.dependencies) {
          $each(schema.dependencies, function (key, value) {
            if (typeof value === "object" && !Array.isArray(value)) {
              schema.dependencies[key] = self.expandSchema(value);
            }
          });
        }
        // Version 4 `not`
        if (schema.not) {
          schema.not = this.expandSchema(schema.not);
        }

        // allOf schemas should be merged into the parent
        if (schema.allOf) {
          for (i = 0; i < schema.allOf.length; i++) {
            extended = this.extendSchemas(extended, this.expandSchema(schema.allOf[i]));
          }
          delete extended.allOf;
        }
        // extends schemas should be merged into parent
        if (schema["extends"]) {
          // If extends is a schema
          if (!Array.isArray(schema["extends"])) {
            extended = this.extendSchemas(extended, this.expandSchema(schema["extends"]));
          }
          // If extends is an array of schemas
          else {
              for (i = 0; i < schema["extends"].length; i++) {
                extended = this.extendSchemas(extended, this.expandSchema(schema["extends"][i]));
              }
            }
          delete extended["extends"];
        }
        // parent should be merged into oneOf schemas
        if (schema.oneOf) {
          var tmp = $extend({}, extended);
          delete tmp.oneOf;
          for (i = 0; i < schema.oneOf.length; i++) {
            extended.oneOf[i] = this.extendSchemas(this.expandSchema(schema.oneOf[i]), tmp);
          }
        }

        return this.expandRefs(extended);
      },
      extendSchemas: function (obj1, obj2) {
        obj1 = $extend({}, obj1);
        obj2 = $extend({}, obj2);

        var self = this;
        var extended = {};
        $each(obj1, function (prop, val) {
          // If this key is also defined in obj2, merge them
          if (typeof obj2[prop] !== "undefined") {
            // Required and defaultProperties arrays should be unioned together
            if ((prop === 'required' || prop === 'defaultProperties') && typeof val === "object" && Array.isArray(val)) {
              // Union arrays and unique
              extended[prop] = val.concat(obj2[prop]).reduce(function (p, c) {
                if (p.indexOf(c) < 0) p.push(c);
                return p;
              }, []);
            }
            // Type should be intersected and is either an array or string
            else if (prop === 'type' && (typeof val === "string" || Array.isArray(val))) {
                // Make sure we're dealing with arrays
                if (typeof val === "string") val = [val];
                if (typeof obj2.type === "string") obj2.type = [obj2.type];

                // If type is only defined in the first schema, keep it
                if (!obj2.type || !obj2.type.length) {
                  extended.type = val;
                }
                // If type is defined in both schemas, do an intersect
                else {
                    extended.type = val.filter(function (n) {
                      return obj2.type.indexOf(n) !== -1;
                    });
                  }

                // If there's only 1 type and it's a primitive, use a string instead of array
                if (extended.type.length === 1 && typeof extended.type[0] === "string") {
                  extended.type = extended.type[0];
                }
                // Remove the type property if it's empty
                else if (extended.type.length === 0) {
                    delete extended.type;
                  }
              }
              // All other arrays should be intersected (enum, etc.)
              else if (typeof val === "object" && Array.isArray(val)) {
                  extended[prop] = val.filter(function (n) {
                    return obj2[prop].indexOf(n) !== -1;
                  });
                }
                // Objects should be recursively merged
                else if (typeof val === "object" && val !== null) {
                    extended[prop] = self.extendSchemas(val, obj2[prop]);
                  }
                  // Otherwise, use the first value
                  else {
                      extended[prop] = val;
                    }
          }
          // Otherwise, just use the one in obj1
          else {
              extended[prop] = val;
            }
        });
        // Properties in obj2 that aren't in obj1
        $each(obj2, function (prop, val) {
          if (typeof obj1[prop] === "undefined") {
            extended[prop] = val;
          }
        });

        return extended;
      }
    };

    JSONEditor.defaults = {
      themes: {},
      templates: {},
      iconlibs: {},
      editors: {},
      languages: {},
      resolvers: [],
      custom_validators: []
    };

    JSONEditor.Validator = Class.extend({
      init: function (jsoneditor, schema, options) {
        this.jsoneditor = jsoneditor;
        this.schema = schema || this.jsoneditor.schema;
        this.options = options || {};
        this.translate = this.jsoneditor.translate || JSONEditor.defaults.translate;
      },
      validate: function (value) {
        return this._validateSchema(this.schema, value);
      },
      _validateSchema: function (schema, value, path) {
        var self = this;
        var errors = [];
        var valid, i, j;
        var stringified = JSON.stringify(value);

        path = path || 'root';

        // Work on a copy of the schema
        schema = $extend({}, this.jsoneditor.expandRefs(schema));

        /*
         * Type Agnostic Validation
         */

        // Version 3 `required`
        if (schema.required && schema.required === true) {
          if (typeof value === "undefined") {
            errors.push({
              path: path,
              property: 'required',
              message: this.translate("error_notset")
            });

            // Can't do any more validation at this point
            return errors;
          }
        }
        // Value not defined
        else if (typeof value === "undefined") {
            // If required_by_default is set, all fields are required
            if (this.jsoneditor.options.required_by_default) {
              errors.push({
                path: path,
                property: 'required',
                message: this.translate("error_notset")
              });
            }
            // Not required, no further validation needed
            else {
                return errors;
              }
          }

        // `enum`
        if (schema["enum"]) {
          valid = false;
          for (i = 0; i < schema["enum"].length; i++) {
            if (stringified === JSON.stringify(schema["enum"][i])) valid = true;
          }
          if (!valid) {
            errors.push({
              path: path,
              property: 'enum',
              message: this.translate("error_enum")
            });
          }
        }

        // `extends` (version 3)
        if (schema["extends"]) {
          for (i = 0; i < schema["extends"].length; i++) {
            errors = errors.concat(this._validateSchema(schema["extends"][i], value, path));
          }
        }

        // `allOf`
        if (schema.allOf) {
          for (i = 0; i < schema.allOf.length; i++) {
            errors = errors.concat(this._validateSchema(schema.allOf[i], value, path));
          }
        }

        // `anyOf`
        if (schema.anyOf) {
          valid = false;
          for (i = 0; i < schema.anyOf.length; i++) {
            if (!this._validateSchema(schema.anyOf[i], value, path).length) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            errors.push({
              path: path,
              property: 'anyOf',
              message: this.translate('error_anyOf')
            });
          }
        }

        // `oneOf`
        if (schema.oneOf) {
          valid = 0;
          var oneof_errors = [];
          for (i = 0; i < schema.oneOf.length; i++) {
            // Set the error paths to be path.oneOf[i].rest.of.path
            var tmp = this._validateSchema(schema.oneOf[i], value, path);
            if (!tmp.length) {
              valid++;
            }

            for (j = 0; j < tmp.length; j++) {
              tmp[j].path = path + '.oneOf[' + i + ']' + tmp[j].path.substr(path.length);
            }
            oneof_errors = oneof_errors.concat(tmp);
          }
          if (valid !== 1) {
            errors.push({
              path: path,
              property: 'oneOf',
              message: this.translate('error_oneOf', [valid])
            });
            errors = errors.concat(oneof_errors);
          }
        }

        // `not`
        if (schema.not) {
          if (!this._validateSchema(schema.not, value, path).length) {
            errors.push({
              path: path,
              property: 'not',
              message: this.translate('error_not')
            });
          }
        }

        // `type` (both Version 3 and Version 4 support)
        if (schema.type) {
          // Union type
          if (Array.isArray(schema.type)) {
            valid = false;
            for (i = 0; i < schema.type.length; i++) {
              if (this._checkType(schema.type[i], value)) {
                valid = true;
                break;
              }
            }
            if (!valid) {
              errors.push({
                path: path,
                property: 'type',
                message: this.translate('error_type_union')
              });
            }
          }
          // Simple type
          else {
              if (!this._checkType(schema.type, value)) {
                errors.push({
                  path: path,
                  property: 'type',
                  message: this.translate('error_type', [schema.type])
                });
              }
            }
        }

        // `disallow` (version 3)
        if (schema.disallow) {
          // Union type
          if (Array.isArray(schema.disallow)) {
            valid = true;
            for (i = 0; i < schema.disallow.length; i++) {
              if (this._checkType(schema.disallow[i], value)) {
                valid = false;
                break;
              }
            }
            if (!valid) {
              errors.push({
                path: path,
                property: 'disallow',
                message: this.translate('error_disallow_union')
              });
            }
          }
          // Simple type
          else {
              if (this._checkType(schema.disallow, value)) {
                errors.push({
                  path: path,
                  property: 'disallow',
                  message: this.translate('error_disallow', [schema.disallow])
                });
              }
            }
        }

        /*
         * Type Specific Validation
         */

        // Number Specific Validation
        if (typeof value === "number") {
          // `multipleOf` and `divisibleBy`
          if (schema.multipleOf || schema.divisibleBy) {
            var divisor = schema.multipleOf || schema.divisibleBy;
            // Vanilla JS, prone to floating point rounding errors (e.g. 1.14 / .01 == 113.99999)
            valid = value / divisor === Math.floor(value / divisor);

            // Use math.js is available
            if (window.math) {
              valid = window.math.mod(window.math.bignumber(value), window.math.bignumber(divisor)).equals(0);
            }
            // Use decimal.js is available
            else if (window.Decimal) {
                valid = new window.Decimal(value).mod(new window.Decimal(divisor)).equals(0);
              }

            if (!valid) {
              errors.push({
                path: path,
                property: schema.multipleOf ? 'multipleOf' : 'divisibleBy',
                message: this.translate('error_multipleOf', [divisor])
              });
            }
          }

          // `maximum`
          if (schema.hasOwnProperty('maximum')) {
            // Vanilla JS, prone to floating point rounding errors (e.g. .999999999999999 == 1)
            valid = schema.exclusiveMaximum ? value < schema.maximum : value <= schema.maximum;

            // Use math.js is available
            if (window.math) {
              valid = window.math[schema.exclusiveMaximum ? 'smaller' : 'smallerEq'](window.math.bignumber(value), window.math.bignumber(schema.maximum));
            }
            // Use Decimal.js if available
            else if (window.Decimal) {
                valid = new window.Decimal(value)[schema.exclusiveMaximum ? 'lt' : 'lte'](new window.Decimal(schema.maximum));
              }

            if (!valid) {
              errors.push({
                path: path,
                property: 'maximum',
                message: this.translate(schema.exclusiveMaximum ? 'error_maximum_excl' : 'error_maximum_incl', [schema.maximum])
              });
            }
          }

          // `minimum`
          if (schema.hasOwnProperty('minimum')) {
            // Vanilla JS, prone to floating point rounding errors (e.g. .999999999999999 == 1)
            valid = schema.exclusiveMinimum ? value > schema.minimum : value >= schema.minimum;

            // Use math.js is available
            if (window.math) {
              valid = window.math[schema.exclusiveMinimum ? 'larger' : 'largerEq'](window.math.bignumber(value), window.math.bignumber(schema.minimum));
            }
            // Use Decimal.js if available
            else if (window.Decimal) {
                valid = new window.Decimal(value)[schema.exclusiveMinimum ? 'gt' : 'gte'](new window.Decimal(schema.minimum));
              }

            if (!valid) {
              errors.push({
                path: path,
                property: 'minimum',
                message: this.translate(schema.exclusiveMinimum ? 'error_minimum_excl' : 'error_minimum_incl', [schema.minimum])
              });
            }
          }
        }
        // String specific validation
        else if (typeof value === "string") {
            // `maxLength`
            if (schema.maxLength) {
              if ((value + "").length > schema.maxLength) {
                errors.push({
                  path: path,
                  property: 'maxLength',
                  message: this.translate('error_maxLength', [schema.maxLength])
                });
              }
            }

            // `minLength`
            if (schema.minLength) {
              if ((value + "").length < schema.minLength) {
                errors.push({
                  path: path,
                  property: 'minLength',
                  message: this.translate(schema.minLength === 1 ? 'error_notempty' : 'error_minLength', [schema.minLength])
                });
              }
            }

            // `pattern`
            if (schema.pattern) {
              if (!new RegExp(schema.pattern).test(value)) {
                errors.push({
                  path: path,
                  property: 'pattern',
                  message: this.translate('error_pattern', [schema.pattern])
                });
              }
            }
          }
          // Array specific validation
          else if (typeof value === "object" && value !== null && Array.isArray(value)) {
              // `items` and `additionalItems`
              if (schema.items) {
                // `items` is an array
                if (Array.isArray(schema.items)) {
                  for (i = 0; i < value.length; i++) {
                    // If this item has a specific schema tied to it
                    // Validate against it
                    if (schema.items[i]) {
                      errors = errors.concat(this._validateSchema(schema.items[i], value[i], path + '.' + i));
                    }
                    // If all additional items are allowed
                    else if (schema.additionalItems === true) {
                        break;
                      }
                      // If additional items is a schema
                      // TODO: Incompatibility between version 3 and 4 of the spec
                      else if (schema.additionalItems) {
                          errors = errors.concat(this._validateSchema(schema.additionalItems, value[i], path + '.' + i));
                        }
                        // If no additional items are allowed
                        else if (schema.additionalItems === false) {
                            errors.push({
                              path: path,
                              property: 'additionalItems',
                              message: this.translate('error_additionalItems')
                            });
                            break;
                          }
                          // Default for `additionalItems` is an empty schema
                          else {
                              break;
                            }
                  }
                }
                // `items` is a schema
                else {
                    // Each item in the array must validate against the schema
                    for (i = 0; i < value.length; i++) {
                      errors = errors.concat(this._validateSchema(schema.items, value[i], path + '.' + i));
                    }
                  }
              }

              // `maxItems`
              if (schema.maxItems) {
                if (value.length > schema.maxItems) {
                  errors.push({
                    path: path,
                    property: 'maxItems',
                    message: this.translate('error_maxItems', [schema.maxItems])
                  });
                }
              }

              // `minItems`
              if (schema.minItems) {
                if (value.length < schema.minItems) {
                  errors.push({
                    path: path,
                    property: 'minItems',
                    message: this.translate('error_minItems', [schema.minItems])
                  });
                }
              }

              // `uniqueItems`
              if (schema.uniqueItems) {
                var seen = {};
                for (i = 0; i < value.length; i++) {
                  valid = JSON.stringify(value[i]);
                  if (seen[valid]) {
                    errors.push({
                      path: path,
                      property: 'uniqueItems',
                      message: this.translate('error_uniqueItems')
                    });
                    break;
                  }
                  seen[valid] = true;
                }
              }
            }
            // Object specific validation
            else if (typeof value === "object" && value !== null) {
                // `maxProperties`
                if (schema.maxProperties) {
                  valid = 0;
                  for (i in value) {
                    if (!value.hasOwnProperty(i)) continue;
                    valid++;
                  }
                  if (valid > schema.maxProperties) {
                    errors.push({
                      path: path,
                      property: 'maxProperties',
                      message: this.translate('error_maxProperties', [schema.maxProperties])
                    });
                  }
                }

                // `minProperties`
                if (schema.minProperties) {
                  valid = 0;
                  for (i in value) {
                    if (!value.hasOwnProperty(i)) continue;
                    valid++;
                  }
                  if (valid < schema.minProperties) {
                    errors.push({
                      path: path,
                      property: 'minProperties',
                      message: this.translate('error_minProperties', [schema.minProperties])
                    });
                  }
                }

                // Version 4 `required`
                if (schema.required && Array.isArray(schema.required)) {
                  for (i = 0; i < schema.required.length; i++) {
                    if (typeof value[schema.required[i]] === "undefined") {
                      errors.push({
                        path: path,
                        property: 'required',
                        message: this.translate('error_required', [schema.required[i]])
                      });
                    }
                  }
                }

                // `properties`
                var validated_properties = {};
                if (schema.properties) {
                  for (i in schema.properties) {
                    if (!schema.properties.hasOwnProperty(i)) continue;
                    validated_properties[i] = true;
                    errors = errors.concat(this._validateSchema(schema.properties[i], value[i], path + '.' + i));
                  }
                }

                // `patternProperties`
                if (schema.patternProperties) {
                  for (i in schema.patternProperties) {
                    if (!schema.patternProperties.hasOwnProperty(i)) continue;

                    var regex = new RegExp(i);

                    // Check which properties match
                    for (j in value) {
                      if (!value.hasOwnProperty(j)) continue;
                      if (regex.test(j)) {
                        validated_properties[j] = true;
                        errors = errors.concat(this._validateSchema(schema.patternProperties[i], value[j], path + '.' + j));
                      }
                    }
                  }
                }

                // The no_additional_properties option currently doesn't work with extended schemas that use oneOf or anyOf
                if (typeof schema.additionalProperties === "undefined" && this.jsoneditor.options.no_additional_properties && !schema.oneOf && !schema.anyOf) {
                  schema.additionalProperties = false;
                }

                // `additionalProperties`
                if (typeof schema.additionalProperties !== "undefined") {
                  for (i in value) {
                    if (!value.hasOwnProperty(i)) continue;
                    if (!validated_properties[i]) {
                      // No extra properties allowed
                      if (!schema.additionalProperties) {
                        errors.push({
                          path: path,
                          property: 'additionalProperties',
                          message: this.translate('error_additional_properties', [i])
                        });
                        break;
                      }
                      // Allowed
                      else if (schema.additionalProperties === true) {
                          break;
                        }
                        // Must match schema
                        // TODO: incompatibility between version 3 and 4 of the spec
                        else {
                            errors = errors.concat(this._validateSchema(schema.additionalProperties, value[i], path + '.' + i));
                          }
                    }
                  }
                }

                // `dependencies`
                if (schema.dependencies) {
                  for (i in schema.dependencies) {
                    if (!schema.dependencies.hasOwnProperty(i)) continue;

                    // Doesn't need to meet the dependency
                    if (typeof value[i] === "undefined") continue;

                    // Property dependency
                    if (Array.isArray(schema.dependencies[i])) {
                      for (j = 0; j < schema.dependencies[i].length; j++) {
                        if (typeof value[schema.dependencies[i][j]] === "undefined") {
                          errors.push({
                            path: path,
                            property: 'dependencies',
                            message: this.translate('error_dependency', [schema.dependencies[i][j]])
                          });
                        }
                      }
                    }
                    // Schema dependency
                    else {
                        errors = errors.concat(this._validateSchema(schema.dependencies[i], value, path));
                      }
                  }
                }
              }

        // Custom type validation (global)
        $each(JSONEditor.defaults.custom_validators, function (i, validator) {
          errors = errors.concat(validator.call(self, schema, value, path));
        });
        // Custom type validation (instance specific)
        if (this.options.custom_validators) {
          $each(this.options.custom_validators, function (i, validator) {
            errors = errors.concat(validator.call(self, schema, value, path));
          });
        }

        return errors;
      },
      _checkType: function (type, value) {
        // Simple types
        if (typeof type === "string") {
          if (type === "string") return typeof value === "string";else if (type === "number") return typeof value === "number";else if (type === "integer") return typeof value === "number" && value === Math.floor(value);else if (type === "boolean") return typeof value === "boolean";else if (type === "array") return Array.isArray(value);else if (type === "object") return value !== null && !Array.isArray(value) && typeof value === "object";else if (type === "null") return value === null;else return true;
        }
        // Schema
        else {
            return !this._validateSchema(type, value).length;
          }
      }
    });

    /**
     * All editors should extend from this class
     */
    JSONEditor.AbstractEditor = Class.extend({
      onChildEditorChange: function (editor) {
        this.onChange(true);
      },
      notify: function () {
        this.jsoneditor.notifyWatchers(this.path);
      },
      change: function () {
        if (this.parent) this.parent.onChildEditorChange(this);else this.jsoneditor.onChange();
      },
      onChange: function (bubble) {
        this.notify();
        if (this.watch_listener) this.watch_listener();
        if (bubble) this.change();
      },
      register: function () {
        this.jsoneditor.registerEditor(this);
        this.onChange();
      },
      unregister: function () {
        if (!this.jsoneditor) return;
        this.jsoneditor.unregisterEditor(this);
      },
      getNumColumns: function () {
        return 12;
      },
      init: function (options) {
        this.jsoneditor = options.jsoneditor;

        this.theme = this.jsoneditor.theme;
        this.template_engine = this.jsoneditor.template;
        this.iconlib = this.jsoneditor.iconlib;

        this.translate = this.jsoneditor.translate || JSONEditor.defaults.translate;

        this.original_schema = options.schema;
        this.schema = this.jsoneditor.expandSchema(this.original_schema);

        this.options = $extend({}, this.options || {}, options.schema.options || {}, options);

        if (!options.path && !this.schema.id) this.schema.id = 'root';
        this.path = options.path || 'root';
        this.formname = options.formname || this.path.replace(/\.([^.]+)/g, '[$1]');
        if (this.jsoneditor.options.form_name_root) this.formname = this.formname.replace(/^root\[/, this.jsoneditor.options.form_name_root + '[');
        this.key = this.path.split('.').pop();
        this.parent = options.parent;

        this.link_watchers = [];

        if (options.container) this.setContainer(options.container);
      },
      setContainer: function (container) {
        this.container = container;
        if (this.schema.id) this.container.setAttribute('data-schemaid', this.schema.id);
        if (this.schema.type && typeof this.schema.type === "string") this.container.setAttribute('data-schematype', this.schema.type);
        this.container.setAttribute('data-schemapath', this.path);
      },

      preBuild: function () {},
      build: function () {},
      postBuild: function () {
        this.setupWatchListeners();
        this.addLinks();
        this.setValue(this.getDefault(), true);
        this.updateHeaderText();
        this.register();
        this.onWatchedFieldChange();
      },

      setupWatchListeners: function () {
        var self = this;

        // Watched fields
        this.watched = {};
        if (this.schema.vars) this.schema.watch = this.schema.vars;
        this.watched_values = {};
        this.watch_listener = function () {
          if (self.refreshWatchedFieldValues()) {
            self.onWatchedFieldChange();
          }
        };

        this.register();
        if (this.schema.hasOwnProperty('watch')) {
          var path, path_parts, first, root, adjusted_path;

          for (var name in this.schema.watch) {
            if (!this.schema.watch.hasOwnProperty(name)) continue;
            path = this.schema.watch[name];

            if (Array.isArray(path)) {
              if (path.length < 2) continue;
              path_parts = [path[0]].concat(path[1].split('.'));
            } else {
              path_parts = path.split('.');
              if (!self.theme.closest(self.container, '[data-schemaid="' + path_parts[0] + '"]')) path_parts.unshift('#');
            }
            first = path_parts.shift();

            if (first === '#') first = self.jsoneditor.schema.id || 'root';

            // Find the root node for this template variable
            root = self.theme.closest(self.container, '[data-schemaid="' + first + '"]');
            if (!root) throw "Could not find ancestor node with id " + first;

            // Keep track of the root node and path for use when rendering the template
            adjusted_path = root.getAttribute('data-schemapath') + '.' + path_parts.join('.');

            self.jsoneditor.watch(adjusted_path, self.watch_listener);

            self.watched[name] = adjusted_path;
          }
        }

        // Dynamic header
        if (this.schema.headerTemplate) {
          this.header_template = this.jsoneditor.compileTemplate(this.schema.headerTemplate, this.template_engine);
        }
      },

      addLinks: function () {
        // Add links
        if (!this.no_link_holder) {
          this.link_holder = this.theme.getLinksHolder();
          this.container.appendChild(this.link_holder);
          if (this.schema.links) {
            for (var i = 0; i < this.schema.links.length; i++) {
              this.addLink(this.getLink(this.schema.links[i]));
            }
          }
        }
      },

      getButton: function (text, icon, title) {
        var btnClass = 'json-editor-btn-' + icon;
        if (!this.iconlib) icon = null;else icon = this.iconlib.getIcon(icon);

        if (!icon && title) {
          text = title;
          title = null;
        }

        var btn = this.theme.getButton(text, icon, title);
        btn.className += ' ' + btnClass + ' ';
        return btn;
      },
      setButtonText: function (button, text, icon, title) {
        if (!this.iconlib) icon = null;else icon = this.iconlib.getIcon(icon);

        if (!icon && title) {
          text = title;
          title = null;
        }

        return this.theme.setButtonText(button, text, icon, title);
      },
      addLink: function (link) {
        if (this.link_holder) this.link_holder.appendChild(link);
      },
      getLink: function (data) {
        var holder, link;

        // Get mime type of the link
        var mime = data.mediaType || 'application/javascript';
        var type = mime.split('/')[0];

        // Template to generate the link href
        var href = this.jsoneditor.compileTemplate(data.href, this.template_engine);

        // Template to generate the link's download attribute
        var download = null;
        if (data.download) download = data.download;

        if (download && download !== true) {
          download = this.jsoneditor.compileTemplate(download, this.template_engine);
        }

        // Image links
        if (type === 'image') {
          holder = this.theme.getBlockLinkHolder();
          link = document.createElement('a');
          link.setAttribute('target', '_blank');
          var image = document.createElement('img');

          this.theme.createImageLink(holder, link, image);

          // When a watched field changes, update the url  
          this.link_watchers.push(function (vars) {
            var url = href(vars);
            link.setAttribute('href', url);
            link.setAttribute('title', data.rel || url);
            image.setAttribute('src', url);
          });
        }
        // Audio/Video links
        else if (['audio', 'video'].indexOf(type) >= 0) {
            holder = this.theme.getBlockLinkHolder();

            link = this.theme.getBlockLink();
            link.setAttribute('target', '_blank');

            var media = document.createElement(type);
            media.setAttribute('controls', 'controls');

            this.theme.createMediaLink(holder, link, media);

            // When a watched field changes, update the url  
            this.link_watchers.push(function (vars) {
              var url = href(vars);
              link.setAttribute('href', url);
              link.textContent = data.rel || url;
              media.setAttribute('src', url);
            });
          }
          // Text links
          else {
              link = holder = this.theme.getBlockLink();
              holder.setAttribute('target', '_blank');
              holder.textContent = data.rel;

              // When a watched field changes, update the url
              this.link_watchers.push(function (vars) {
                var url = href(vars);
                holder.setAttribute('href', url);
                holder.textContent = data.rel || url;
              });
            }

        if (download && link) {
          if (download === true) {
            link.setAttribute('download', '');
          } else {
            this.link_watchers.push(function (vars) {
              link.setAttribute('download', download(vars));
            });
          }
        }

        if (data.class) link.className = link.className + ' ' + data.class;

        return holder;
      },
      refreshWatchedFieldValues: function () {
        if (!this.watched_values) return;
        var watched = {};
        var changed = false;
        var self = this;

        if (this.watched) {
          var val, editor;
          for (var name in this.watched) {
            if (!this.watched.hasOwnProperty(name)) continue;
            editor = self.jsoneditor.getEditor(this.watched[name]);
            val = editor ? editor.getValue() : null;
            if (self.watched_values[name] !== val) changed = true;
            watched[name] = val;
          }
        }

        watched.self = this.getValue();
        if (this.watched_values.self !== watched.self) changed = true;

        this.watched_values = watched;

        return changed;
      },
      getWatchedFieldValues: function () {
        return this.watched_values;
      },
      updateHeaderText: function () {
        if (this.header) {
          // If the header has children, only update the text node's value
          if (this.header.children.length) {
            for (var i = 0; i < this.header.childNodes.length; i++) {
              if (this.header.childNodes[i].nodeType === 3) {
                this.header.childNodes[i].nodeValue = this.getHeaderText();
                break;
              }
            }
          }
          // Otherwise, just update the entire node
          else {
              this.header.textContent = this.getHeaderText();
            }
        }
      },
      getHeaderText: function (title_only) {
        if (this.header_text) return this.header_text;else if (title_only) return this.schema.title;else return this.getTitle();
      },
      onWatchedFieldChange: function () {
        var vars;
        if (this.header_template) {
          vars = $extend(this.getWatchedFieldValues(), {
            key: this.key,
            i: this.key,
            i0: this.key * 1,
            i1: this.key * 1 + 1,
            title: this.getTitle()
          });
          var header_text = this.header_template(vars);

          if (header_text !== this.header_text) {
            this.header_text = header_text;
            this.updateHeaderText();
            this.notify();
            //this.fireChangeHeaderEvent();
          }
        }
        if (this.link_watchers.length) {
          vars = this.getWatchedFieldValues();
          for (var i = 0; i < this.link_watchers.length; i++) {
            this.link_watchers[i](vars);
          }
        }
      },
      setValue: function (value) {
        this.value = value;
      },
      getValue: function () {
        return this.value;
      },
      refreshValue: function () {},
      getChildEditors: function () {
        return false;
      },
      destroy: function () {
        var self = this;
        this.unregister(this);
        $each(this.watched, function (name, adjusted_path) {
          self.jsoneditor.unwatch(adjusted_path, self.watch_listener);
        });
        this.watched = null;
        this.watched_values = null;
        this.watch_listener = null;
        this.header_text = null;
        this.header_template = null;
        this.value = null;
        if (this.container && this.container.parentNode) this.container.parentNode.removeChild(this.container);
        this.container = null;
        this.jsoneditor = null;
        this.schema = null;
        this.path = null;
        this.key = null;
        this.parent = null;
      },
      getDefault: function () {
        if (this.schema["default"]) return this.schema["default"];
        if (this.schema["enum"]) return this.schema["enum"][0];

        var type = this.schema.type || this.schema.oneOf;
        if (type && Array.isArray(type)) type = type[0];
        if (type && typeof type === "object") type = type.type;
        if (type && Array.isArray(type)) type = type[0];

        if (typeof type === "string") {
          if (type === "number") return 0.0;
          if (type === "boolean") return false;
          if (type === "integer") return 0;
          if (type === "string") return "";
          if (type === "object") return {};
          if (type === "array") return [];
        }

        return null;
      },
      getTitle: function () {
        return this.schema.title || this.key;
      },
      enable: function () {
        this.disabled = false;
      },
      disable: function () {
        this.disabled = true;
      },
      isEnabled: function () {
        return !this.disabled;
      },
      isRequired: function () {
        if (typeof this.schema.required === "boolean") return this.schema.required;else if (this.parent && this.parent.schema && Array.isArray(this.parent.schema.required)) return this.parent.schema.required.indexOf(this.key) > -1;else if (this.jsoneditor.options.required_by_default) return true;else return false;
      },
      getDisplayText: function (arr) {
        var disp = [];
        var used = {};

        // Determine how many times each attribute name is used.
        // This helps us pick the most distinct display text for the schemas.
        $each(arr, function (i, el) {
          if (el.title) {
            used[el.title] = used[el.title] || 0;
            used[el.title]++;
          }
          if (el.description) {
            used[el.description] = used[el.description] || 0;
            used[el.description]++;
          }
          if (el.format) {
            used[el.format] = used[el.format] || 0;
            used[el.format]++;
          }
          if (el.type) {
            used[el.type] = used[el.type] || 0;
            used[el.type]++;
          }
        });

        // Determine display text for each element of the array
        $each(arr, function (i, el) {
          var name;

          // If it's a simple string
          if (typeof el === "string") name = el;
          // Object
          else if (el.title && used[el.title] <= 1) name = el.title;else if (el.format && used[el.format] <= 1) name = el.format;else if (el.type && used[el.type] <= 1) name = el.type;else if (el.description && used[el.description] <= 1) name = el.descripton;else if (el.title) name = el.title;else if (el.format) name = el.format;else if (el.type) name = el.type;else if (el.description) name = el.description;else if (JSON.stringify(el).length < 50) name = JSON.stringify(el);else name = "type";

          disp.push(name);
        });

        // Replace identical display text with "text 1", "text 2", etc.
        var inc = {};
        $each(disp, function (i, name) {
          inc[name] = inc[name] || 0;
          inc[name]++;

          if (used[name] > 1) disp[i] = name + " " + inc[name];
        });

        return disp;
      },
      getOption: function (key) {
        try {
          throw "getOption is deprecated";
        } catch (e) {
          window.console.error(e);
        }

        return this.options[key];
      },
      showValidationErrors: function (errors) {}
    });

    JSONEditor.defaults.editors["null"] = JSONEditor.AbstractEditor.extend({
      getValue: function () {
        return null;
      },
      setValue: function () {
        this.onChange();
      },
      getNumColumns: function () {
        return 2;
      }
    });

    JSONEditor.defaults.editors.string = JSONEditor.AbstractEditor.extend({
      register: function () {
        this._super();
        if (!this.input) return;
        this.input.setAttribute('name', this.formname);
      },
      unregister: function () {
        this._super();
        if (!this.input) return;
        this.input.removeAttribute('name');
      },
      setValue: function (value, initial, from_template) {
        var self = this;

        if (this.template && !from_template) {
          return;
        }

        if (value === null || typeof value === 'undefined') value = "";else if (typeof value === "object") value = JSON.stringify(value);else if (typeof value !== "string") value = "" + value;

        if (value === this.serialized) return;

        // Sanitize value before setting it
        var sanitized = this.sanitize(value);

        if (this.input.value === sanitized) {
          return;
        }

        this.input.value = sanitized;

        // If using SCEditor, update the WYSIWYG
        if (this.sceditor_instance) {
          this.sceditor_instance.val(sanitized);
        } else if (this.epiceditor) {
          this.epiceditor.importFile(null, sanitized);
        } else if (this.ace_editor) {
          this.ace_editor.setValue(sanitized);
        }

        var changed = from_template || this.getValue() !== value;

        this.refreshValue();

        if (initial) this.is_dirty = false;else if (this.jsoneditor.options.show_errors === "change") this.is_dirty = true;

        if (this.adjust_height) this.adjust_height(this.input);

        // Bubble this setValue to parents if the value changed
        this.onChange(changed);
      },
      getNumColumns: function () {
        var min = Math.ceil(Math.max(this.getTitle().length, this.schema.maxLength || 0, this.schema.minLength || 0) / 5);
        var num;

        if (this.input_type === 'textarea') num = 6;else if (['text', 'email'].indexOf(this.input_type) >= 0) num = 4;else num = 2;

        return Math.min(12, Math.max(min, num));
      },
      build: function () {
        var self = this,
            i;
        if (!this.options.compact) this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        if (this.schema.description) this.description = this.theme.getFormInputDescription(this.schema.description);

        this.format = this.schema.format;
        if (!this.format && this.schema.media && this.schema.media.type) {
          this.format = this.schema.media.type.replace(/(^(application|text)\/(x-)?(script\.)?)|(-source$)/g, '');
        }
        if (!this.format && this.options.default_format) {
          this.format = this.options.default_format;
        }
        if (this.options.format) {
          this.format = this.options.format;
        }

        // Specific format
        if (this.format) {
          // Text Area
          if (this.format === 'textarea') {
            this.input_type = 'textarea';
            this.input = this.theme.getTextareaInput();
          }
          // Range Input
          else if (this.format === 'range') {
              this.input_type = 'range';
              var min = this.schema.minimum || 0;
              var max = this.schema.maximum || Math.max(100, min + 1);
              var step = 1;
              if (this.schema.multipleOf) {
                if (min % this.schema.multipleOf) min = Math.ceil(min / this.schema.multipleOf) * this.schema.multipleOf;
                if (max % this.schema.multipleOf) max = Math.floor(max / this.schema.multipleOf) * this.schema.multipleOf;
                step = this.schema.multipleOf;
              }

              this.input = this.theme.getRangeInput(min, max, step);
            }
            // Source Code
            else if (['actionscript', 'batchfile', 'bbcode', 'c', 'c++', 'cpp', 'coffee', 'csharp', 'css', 'dart', 'django', 'ejs', 'erlang', 'golang', 'groovy', 'handlebars', 'haskell', 'haxe', 'html', 'ini', 'jade', 'java', 'javascript', 'json', 'less', 'lisp', 'lua', 'makefile', 'markdown', 'matlab', 'mysql', 'objectivec', 'pascal', 'perl', 'pgsql', 'php', 'python', 'r', 'ruby', 'sass', 'scala', 'scss', 'smarty', 'sql', 'stylus', 'svg', 'twig', 'vbscript', 'xml', 'yaml'].indexOf(this.format) >= 0) {
                this.input_type = this.format;
                this.source_code = true;

                this.input = this.theme.getTextareaInput();
              }
              // HTML5 Input type
              else {
                  this.input_type = this.format;
                  this.input = this.theme.getFormInputField(this.input_type);
                }
        }
        // Normal text input
        else {
            this.input_type = 'text';
            this.input = this.theme.getFormInputField(this.input_type);
          }

        // minLength, maxLength, and pattern
        if (typeof this.schema.maxLength !== "undefined") this.input.setAttribute('maxlength', this.schema.maxLength);
        if (typeof this.schema.pattern !== "undefined") this.input.setAttribute('pattern', this.schema.pattern);else if (typeof this.schema.minLength !== "undefined") this.input.setAttribute('pattern', '.{' + this.schema.minLength + ',}');

        if (this.options.compact) {
          this.container.className += ' compact';
        } else {
          if (this.options.input_width) this.input.style.width = this.options.input_width;
        }

        if (this.schema.readOnly || this.schema.readonly || this.schema.template) {
          this.always_disabled = true;
          this.input.disabled = true;
        }

        this.input.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();

          // Don't allow changing if this field is a template
          if (self.schema.template) {
            this.value = self.value;
            return;
          }

          var val = this.value;

          // sanitize value
          var sanitized = self.sanitize(val);
          if (val !== sanitized) {
            this.value = sanitized;
          }

          self.is_dirty = true;

          self.refreshValue();
          self.onChange(true);
        });

        if (this.options.input_height) this.input.style.height = this.options.input_height;
        if (this.options.expand_height) {
          this.adjust_height = function (el) {
            if (!el) return;
            var i,
                ch = el.offsetHeight;
            // Input too short
            if (el.offsetHeight < el.scrollHeight) {
              i = 0;
              while (el.offsetHeight < el.scrollHeight + 3) {
                if (i > 100) break;
                i++;
                ch++;
                el.style.height = ch + 'px';
              }
            } else {
              i = 0;
              while (el.offsetHeight >= el.scrollHeight + 3) {
                if (i > 100) break;
                i++;
                ch--;
                el.style.height = ch + 'px';
              }
              el.style.height = ch + 1 + 'px';
            }
          };

          this.input.addEventListener('keyup', function (e) {
            self.adjust_height(this);
          });
          this.input.addEventListener('change', function (e) {
            self.adjust_height(this);
          });
          this.adjust_height();
        }

        if (this.format) this.input.setAttribute('data-schemaformat', this.format);

        this.control = this.theme.getFormControl(this.label, this.input, this.description);
        this.container.appendChild(this.control);

        // Any special formatting that needs to happen after the input is added to the dom
        window.requestAnimationFrame(function () {
          // Skip in case the input is only a temporary editor,
          // otherwise, in the case of an ace_editor creation,
          // it will generate an error trying to append it to the missing parentNode
          if (self.input.parentNode) self.afterInputReady();
          if (self.adjust_height) self.adjust_height(self.input);
        });

        // Compile and store the template
        if (this.schema.template) {
          this.template = this.jsoneditor.compileTemplate(this.schema.template, this.template_engine);
          this.refreshValue();
        } else {
          this.refreshValue();
        }
      },
      enable: function () {
        if (!this.always_disabled) {
          this.input.disabled = false;
          // TODO: WYSIWYG and Markdown editors
        }
        this._super();
      },
      disable: function () {
        this.input.disabled = true;
        // TODO: WYSIWYG and Markdown editors
        this._super();
      },
      afterInputReady: function () {
        var self = this,
            options;

        // Code editor
        if (this.source_code) {
          // WYSIWYG html and bbcode editor
          if (this.options.wysiwyg && ['html', 'bbcode'].indexOf(this.input_type) >= 0 && window.jQuery && window.jQuery.fn && window.jQuery.fn.sceditor) {
            options = $extend({}, {
              plugins: self.input_type === 'html' ? 'xhtml' : 'bbcode',
              emoticonsEnabled: false,
              width: '100%',
              height: 300
            }, JSONEditor.plugins.sceditor, self.options.sceditor_options || {});

            window.jQuery(self.input).sceditor(options);

            self.sceditor_instance = window.jQuery(self.input).sceditor('instance');

            self.sceditor_instance.blur(function () {
              // Get editor's value
              var val = window.jQuery("<div>" + self.sceditor_instance.val() + "</div>");
              // Remove sceditor spans/divs
              window.jQuery('#sceditor-start-marker,#sceditor-end-marker,.sceditor-nlf', val).remove();
              // Set the value and update
              self.input.value = val.html();
              self.value = self.input.value;
              self.is_dirty = true;
              self.onChange(true);
            });
          }
          // EpicEditor for markdown (if it's loaded)
          else if (this.input_type === 'markdown' && window.EpicEditor) {
              this.epiceditor_container = document.createElement('div');
              this.input.parentNode.insertBefore(this.epiceditor_container, this.input);
              this.input.style.display = 'none';

              options = $extend({}, JSONEditor.plugins.epiceditor, {
                container: this.epiceditor_container,
                clientSideStorage: false
              });

              this.epiceditor = new window.EpicEditor(options).load();

              this.epiceditor.importFile(null, this.getValue());

              this.epiceditor.on('update', function () {
                var val = self.epiceditor.exportFile();
                self.input.value = val;
                self.value = val;
                self.is_dirty = true;
                self.onChange(true);
              });
            }
            // ACE editor for everything else
            else if (window.ace) {
                var mode = this.input_type;
                // aliases for c/cpp
                if (mode === 'cpp' || mode === 'c++' || mode === 'c') {
                  mode = 'c_cpp';
                }

                this.ace_container = document.createElement('div');
                this.ace_container.style.width = '100%';
                this.ace_container.style.position = 'relative';
                this.ace_container.style.height = '400px';
                this.input.parentNode.insertBefore(this.ace_container, this.input);
                this.input.style.display = 'none';
                this.ace_editor = window.ace.edit(this.ace_container);

                this.ace_editor.setValue(this.getValue());

                // The theme
                if (JSONEditor.plugins.ace.theme) this.ace_editor.setTheme('ace/theme/' + JSONEditor.plugins.ace.theme);
                // The mode
                mode = window.ace.require("ace/mode/" + mode);
                if (mode) this.ace_editor.getSession().setMode(new mode.Mode());

                // Listen for changes
                this.ace_editor.on('change', function () {
                  var val = self.ace_editor.getValue();
                  self.input.value = val;
                  self.refreshValue();
                  self.is_dirty = true;
                  self.onChange(true);
                });
              }
        }

        self.theme.afterInputReady(self.input);
      },
      refreshValue: function () {
        this.value = this.input.value;
        if (typeof this.value !== "string") this.value = '';
        this.serialized = this.value;
      },
      destroy: function () {
        // If using SCEditor, destroy the editor instance
        if (this.sceditor_instance) {
          this.sceditor_instance.destroy();
        } else if (this.epiceditor) {
          this.epiceditor.unload();
        } else if (this.ace_editor) {
          this.ace_editor.destroy();
        }

        this.template = null;
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        if (this.label && this.label.parentNode) this.label.parentNode.removeChild(this.label);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);

        this._super();
      },
      /**
       * This is overridden in derivative editors
       */
      sanitize: function (value) {
        return value;
      },
      /**
       * Re-calculates the value if needed
       */
      onWatchedFieldChange: function () {
        var self = this,
            vars,
            j;

        // If this editor needs to be rendered by a macro template
        if (this.template) {
          vars = this.getWatchedFieldValues();
          this.setValue(this.template(vars), false, true);
        }

        this._super();
      },
      showValidationErrors: function (errors) {
        var self = this;

        if (this.jsoneditor.options.show_errors === "always") {} else if (!this.is_dirty && this.previous_error_setting === this.jsoneditor.options.show_errors) return;

        this.previous_error_setting = this.jsoneditor.options.show_errors;

        var messages = [];
        $each(errors, function (i, error) {
          if (error.path === self.path) {
            messages.push(error.message);
          }
        });

        if (messages.length) {
          this.theme.addInputError(this.input, messages.join('. ') + '.');
        } else {
          this.theme.removeInputError(this.input);
        }
      }
    });

    JSONEditor.defaults.editors.number = JSONEditor.defaults.editors.string.extend({
      sanitize: function (value) {
        return (value + "").replace(/[^0-9\.\-eE]/g, '');
      },
      getNumColumns: function () {
        return 2;
      },
      getValue: function () {
        return this.value * 1;
      }
    });

    JSONEditor.defaults.editors.integer = JSONEditor.defaults.editors.number.extend({
      sanitize: function (value) {
        value = value + "";
        return value.replace(/[^0-9\-]/g, '');
      },
      getNumColumns: function () {
        return 2;
      }
    });

    JSONEditor.defaults.editors.object = JSONEditor.AbstractEditor.extend({
      getDefault: function () {
        return $extend({}, this.schema["default"] || {});
      },
      getChildEditors: function () {
        return this.editors;
      },
      register: function () {
        this._super();
        if (this.editors) {
          for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i)) continue;
            this.editors[i].register();
          }
        }
      },
      unregister: function () {
        this._super();
        if (this.editors) {
          for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i)) continue;
            this.editors[i].unregister();
          }
        }
      },
      getNumColumns: function () {
        return Math.max(Math.min(12, this.maxwidth), 3);
      },
      enable: function () {
        if (this.editjson_button) this.editjson_button.disabled = false;
        if (this.addproperty_button) this.addproperty_button.disabled = false;

        this._super();
        if (this.editors) {
          for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i)) continue;
            this.editors[i].enable();
          }
        }
      },
      disable: function () {
        if (this.editjson_button) this.editjson_button.disabled = true;
        if (this.addproperty_button) this.addproperty_button.disabled = true;
        this.hideEditJSON();

        this._super();
        if (this.editors) {
          for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i)) continue;
            this.editors[i].disable();
          }
        }
      },
      layoutEditors: function () {
        var self = this,
            i,
            j;

        if (!this.row_container) return;

        // Sort editors by propertyOrder
        this.property_order = Object.keys(this.editors);
        this.property_order = this.property_order.sort(function (a, b) {
          var ordera = self.editors[a].schema.propertyOrder;
          var orderb = self.editors[b].schema.propertyOrder;
          if (typeof ordera !== "number") ordera = 1000;
          if (typeof orderb !== "number") orderb = 1000;

          return ordera - orderb;
        });

        var container;

        if (this.format === 'grid') {
          var rows = [];
          $each(this.property_order, function (j, key) {
            var editor = self.editors[key];
            if (editor.property_removed) return;
            var found = false;
            var width = editor.options.hidden ? 0 : editor.options.grid_columns || editor.getNumColumns();
            var height = editor.options.hidden ? 0 : editor.container.offsetHeight;
            // See if the editor will fit in any of the existing rows first
            for (var i = 0; i < rows.length; i++) {
              // If the editor will fit in the row horizontally
              if (rows[i].width + width <= 12) {
                // If the editor is close to the other elements in height
                // i.e. Don't put a really tall editor in an otherwise short row or vice versa
                if (!height || rows[i].minh * 0.5 < height && rows[i].maxh * 2 > height) {
                  found = i;
                }
              }
            }

            // If there isn't a spot in any of the existing rows, start a new row
            if (found === false) {
              rows.push({
                width: 0,
                minh: 999999,
                maxh: 0,
                editors: []
              });
              found = rows.length - 1;
            }

            rows[found].editors.push({
              key: key,
              //editor: editor,
              width: width,
              height: height
            });
            rows[found].width += width;
            rows[found].minh = Math.min(rows[found].minh, height);
            rows[found].maxh = Math.max(rows[found].maxh, height);
          });

          // Make almost full rows width 12
          // Do this by increasing all editors' sizes proprotionately
          // Any left over space goes to the biggest editor
          // Don't touch rows with a width of 6 or less
          for (i = 0; i < rows.length; i++) {
            if (rows[i].width < 12) {
              var biggest = false;
              var new_width = 0;
              for (j = 0; j < rows[i].editors.length; j++) {
                if (biggest === false) biggest = j;else if (rows[i].editors[j].width > rows[i].editors[biggest].width) biggest = j;
                rows[i].editors[j].width *= 12 / rows[i].width;
                rows[i].editors[j].width = Math.floor(rows[i].editors[j].width);
                new_width += rows[i].editors[j].width;
              }
              if (new_width < 12) rows[i].editors[biggest].width += 12 - new_width;
              rows[i].width = 12;
            }
          }

          // layout hasn't changed
          if (this.layout === JSON.stringify(rows)) return false;
          this.layout = JSON.stringify(rows);

          // Layout the form
          container = document.createElement('div');
          for (i = 0; i < rows.length; i++) {
            var row = this.theme.getGridRow();
            container.appendChild(row);
            for (j = 0; j < rows[i].editors.length; j++) {
              var key = rows[i].editors[j].key;
              var editor = this.editors[key];

              if (editor.options.hidden) editor.container.style.display = 'none';else this.theme.setGridColumnSize(editor.container, rows[i].editors[j].width);
              row.appendChild(editor.container);
            }
          }
        }
        // Normal layout
        else {
            container = document.createElement('div');
            $each(this.property_order, function (i, key) {
              var editor = self.editors[key];
              if (editor.property_removed) return;
              var row = self.theme.getGridRow();
              container.appendChild(row);

              if (editor.options.hidden) editor.container.style.display = 'none';else self.theme.setGridColumnSize(editor.container, 12);
              row.appendChild(editor.container);
            });
          }
        this.row_container.innerHTML = '';
        this.row_container.appendChild(container);
      },
      getPropertySchema: function (key) {
        // Schema declared directly in properties
        var schema = this.schema.properties[key] || {};
        schema = $extend({}, schema);
        var matched = this.schema.properties[key] ? true : false;

        // Any matching patternProperties should be merged in
        if (this.schema.patternProperties) {
          for (var i in this.schema.patternProperties) {
            if (!this.schema.patternProperties.hasOwnProperty(i)) continue;
            var regex = new RegExp(i);
            if (regex.test(key)) {
              schema.allOf = schema.allOf || [];
              schema.allOf.push(this.schema.patternProperties[i]);
              matched = true;
            }
          }
        }

        // Hasn't matched other rules, use additionalProperties schema
        if (!matched && this.schema.additionalProperties && typeof this.schema.additionalProperties === "object") {
          schema = $extend({}, this.schema.additionalProperties);
        }

        return schema;
      },
      preBuild: function () {
        this._super();

        this.editors = {};
        this.cached_editors = {};
        var self = this;

        this.format = this.options.layout || this.options.object_layout || this.schema.format || this.jsoneditor.options.object_layout || 'normal';

        this.schema.properties = this.schema.properties || {};

        this.minwidth = 0;
        this.maxwidth = 0;

        // If the object should be rendered as a table row
        if (this.options.table_row) {
          $each(this.schema.properties, function (key, schema) {
            var editor = self.jsoneditor.getEditorClass(schema);
            self.editors[key] = self.jsoneditor.createEditor(editor, {
              jsoneditor: self.jsoneditor,
              schema: schema,
              path: self.path + '.' + key,
              parent: self,
              compact: true,
              required: true
            });
            self.editors[key].preBuild();

            var width = self.editors[key].options.hidden ? 0 : self.editors[key].options.grid_columns || self.editors[key].getNumColumns();

            self.minwidth += width;
            self.maxwidth += width;
          });
          this.no_link_holder = true;
        }
        // If the object should be rendered as a table
        else if (this.options.table) {
            // TODO: table display format
            throw "Not supported yet";
          }
          // If the object should be rendered as a div
          else {
              if (!this.schema.defaultProperties) {
                if (this.jsoneditor.options.display_required_only || this.options.display_required_only) {
                  this.schema.defaultProperties = [];
                  $each(this.schema.properties, function (k, s) {
                    if (self.isRequired({ key: k, schema: s })) {
                      self.schema.defaultProperties.push(k);
                    }
                  });
                } else {
                  self.schema.defaultProperties = Object.keys(self.schema.properties);
                }
              }

              // Increase the grid width to account for padding
              self.maxwidth += 1;

              $each(this.schema.defaultProperties, function (i, key) {
                self.addObjectProperty(key, true);

                if (self.editors[key]) {
                  self.minwidth = Math.max(self.minwidth, self.editors[key].options.grid_columns || self.editors[key].getNumColumns());
                  self.maxwidth += self.editors[key].options.grid_columns || self.editors[key].getNumColumns();
                }
              });
            }

        // Sort editors by propertyOrder
        this.property_order = Object.keys(this.editors);
        this.property_order = this.property_order.sort(function (a, b) {
          var ordera = self.editors[a].schema.propertyOrder;
          var orderb = self.editors[b].schema.propertyOrder;
          if (typeof ordera !== "number") ordera = 1000;
          if (typeof orderb !== "number") orderb = 1000;

          return ordera - orderb;
        });
      },
      build: function () {
        var self = this;

        // If the object should be rendered as a table row
        if (this.options.table_row) {
          this.editor_holder = this.container;
          $each(this.editors, function (key, editor) {
            var holder = self.theme.getTableCell();
            self.editor_holder.appendChild(holder);

            editor.setContainer(holder);
            editor.build();
            editor.postBuild();

            if (self.editors[key].options.hidden) {
              holder.style.display = 'none';
            }
            if (self.editors[key].options.input_width) {
              holder.style.width = self.editors[key].options.input_width;
            }
          });
        }
        // If the object should be rendered as a table
        else if (this.options.table) {
            // TODO: table display format
            throw "Not supported yet";
          }
          // If the object should be rendered as a div
          else {
              this.header = document.createElement('span');
              this.header.textContent = this.getTitle();
              this.title = this.theme.getHeader(this.header);
              this.container.appendChild(this.title);
              this.container.style.position = 'relative';

              // Edit JSON modal
              this.editjson_holder = this.theme.getModal();
              this.editjson_textarea = this.theme.getTextareaInput();
              this.editjson_textarea.style.height = '170px';
              this.editjson_textarea.style.width = '300px';
              this.editjson_textarea.style.display = 'block';
              this.editjson_save = this.getButton('Save', 'save', 'Save');
              this.editjson_save.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                self.saveJSON();
              });
              this.editjson_cancel = this.getButton('Cancel', 'cancel', 'Cancel');
              this.editjson_cancel.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                self.hideEditJSON();
              });
              this.editjson_holder.appendChild(this.editjson_textarea);
              this.editjson_holder.appendChild(this.editjson_save);
              this.editjson_holder.appendChild(this.editjson_cancel);

              // Manage Properties modal
              this.addproperty_holder = this.theme.getModal();
              this.addproperty_list = document.createElement('div');
              this.addproperty_list.style.width = '295px';
              this.addproperty_list.style.maxHeight = '160px';
              this.addproperty_list.style.padding = '5px 0';
              this.addproperty_list.style.overflowY = 'auto';
              this.addproperty_list.style.overflowX = 'hidden';
              this.addproperty_list.style.paddingLeft = '5px';
              this.addproperty_list.setAttribute('class', 'property-selector');
              this.addproperty_add = this.getButton('add', 'add', 'add');
              this.addproperty_input = this.theme.getFormInputField('text');
              this.addproperty_input.setAttribute('placeholder', 'Property name...');
              this.addproperty_input.style.width = '220px';
              this.addproperty_input.style.marginBottom = '0';
              this.addproperty_input.style.display = 'inline-block';
              this.addproperty_add.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                if (self.addproperty_input.value) {
                  if (self.editors[self.addproperty_input.value]) {
                    window.alert('there is already a property with that name');
                    return;
                  }

                  self.addObjectProperty(self.addproperty_input.value);
                  if (self.editors[self.addproperty_input.value]) {
                    self.editors[self.addproperty_input.value].disable();
                  }
                  self.onChange(true);
                }
              });
              this.addproperty_holder.appendChild(this.addproperty_list);
              this.addproperty_holder.appendChild(this.addproperty_input);
              this.addproperty_holder.appendChild(this.addproperty_add);
              var spacer = document.createElement('div');
              spacer.style.clear = 'both';
              this.addproperty_holder.appendChild(spacer);

              // Description
              if (this.schema.description) {
                this.description = this.theme.getDescription(this.schema.description);
                this.container.appendChild(this.description);
              }

              // Validation error placeholder area
              this.error_holder = document.createElement('div');
              this.container.appendChild(this.error_holder);

              // Container for child editor area
              this.editor_holder = this.theme.getIndentedPanel();
              this.container.appendChild(this.editor_holder);

              // Container for rows of child editors
              this.row_container = this.theme.getGridContainer();
              this.editor_holder.appendChild(this.row_container);

              $each(this.editors, function (key, editor) {
                var holder = self.theme.getGridColumn();
                self.row_container.appendChild(holder);

                editor.setContainer(holder);
                editor.build();
                editor.postBuild();
              });

              // Control buttons
              this.title_controls = this.theme.getHeaderButtonHolder();
              this.editjson_controls = this.theme.getHeaderButtonHolder();
              this.addproperty_controls = this.theme.getHeaderButtonHolder();
              this.title.appendChild(this.title_controls);
              this.title.appendChild(this.editjson_controls);
              this.title.appendChild(this.addproperty_controls);

              // Show/Hide button
              this.collapsed = false;
              this.toggle_button = this.getButton('', 'collapse', this.translate('button_collapse'));
              this.title_controls.appendChild(this.toggle_button);
              this.toggle_button.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                if (self.collapsed) {
                  self.editor_holder.style.display = '';
                  self.collapsed = false;
                  self.setButtonText(self.toggle_button, '', 'collapse', self.translate('button_collapse'));
                } else {
                  self.editor_holder.style.display = 'none';
                  self.collapsed = true;
                  self.setButtonText(self.toggle_button, '', 'expand', self.translate('button_expand'));
                }
              });

              // If it should start collapsed
              if (this.options.collapsed) {
                $trigger(this.toggle_button, 'click');
              }

              // Collapse button disabled
              if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
                if (this.schema.options.disable_collapse) this.toggle_button.style.display = 'none';
              } else if (this.jsoneditor.options.disable_collapse) {
                this.toggle_button.style.display = 'none';
              }

              // Edit JSON Button
              this.editjson_button = this.getButton('JSON', 'edit', 'Edit JSON');
              this.editjson_button.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                self.toggleEditJSON();
              });
              this.editjson_controls.appendChild(this.editjson_button);
              this.editjson_controls.appendChild(this.editjson_holder);

              // Edit JSON Buttton disabled
              if (this.schema.options && typeof this.schema.options.disable_edit_json !== "undefined") {
                if (this.schema.options.disable_edit_json) this.editjson_button.style.display = 'none';
              } else if (this.jsoneditor.options.disable_edit_json) {
                this.editjson_button.style.display = 'none';
              }

              // Object Properties Button
              this.addproperty_button = this.getButton('Properties', 'edit', 'Object Properties');
              this.addproperty_button.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                self.toggleAddProperty();
              });
              this.addproperty_controls.appendChild(this.addproperty_button);
              this.addproperty_controls.appendChild(this.addproperty_holder);
              this.refreshAddProperties();
            }

        // Fix table cell ordering
        if (this.options.table_row) {
          this.editor_holder = this.container;
          $each(this.property_order, function (i, key) {
            self.editor_holder.appendChild(self.editors[key].container);
          });
        }
        // Layout object editors in grid if needed
        else {
            // Initial layout
            this.layoutEditors();
            // Do it again now that we know the approximate heights of elements
            this.layoutEditors();
          }
      },
      showEditJSON: function () {
        if (!this.editjson_holder) return;
        this.hideAddProperty();

        // Position the form directly beneath the button
        // TODO: edge detection
        this.editjson_holder.style.left = this.editjson_button.offsetLeft + "px";
        this.editjson_holder.style.top = this.editjson_button.offsetTop + this.editjson_button.offsetHeight + "px";

        // Start the textarea with the current value
        this.editjson_textarea.value = JSON.stringify(this.getValue(), null, 2);

        // Disable the rest of the form while editing JSON
        this.disable();

        this.editjson_holder.style.display = '';
        this.editjson_button.disabled = false;
        this.editing_json = true;
      },
      hideEditJSON: function () {
        if (!this.editjson_holder) return;
        if (!this.editing_json) return;

        this.editjson_holder.style.display = 'none';
        this.enable();
        this.editing_json = false;
      },
      saveJSON: function () {
        if (!this.editjson_holder) return;

        try {
          var json = JSON.parse(this.editjson_textarea.value);
          this.setValue(json);
          this.hideEditJSON();
        } catch (e) {
          window.alert('invalid JSON');
          throw e;
        }
      },
      toggleEditJSON: function () {
        if (this.editing_json) this.hideEditJSON();else this.showEditJSON();
      },
      insertPropertyControlUsingPropertyOrder: function (property, control, container) {
        var propertyOrder;
        if (this.schema.properties[property]) propertyOrder = this.schema.properties[property].propertyOrder;
        if (typeof propertyOrder !== "number") propertyOrder = 1000;
        control.propertyOrder = propertyOrder;

        for (var i = 0; i < container.childNodes.length; i++) {
          var child = container.childNodes[i];
          if (control.propertyOrder < child.propertyOrder) {
            this.addproperty_list.insertBefore(control, child);
            control = null;
            break;
          }
        }
        if (control) {
          this.addproperty_list.appendChild(control);
        }
      },
      addPropertyCheckbox: function (key) {
        var self = this;
        var checkbox, label, labelText, control;

        checkbox = self.theme.getCheckbox();
        checkbox.style.width = 'auto';

        if (this.schema.properties[key] && this.schema.properties[key].title) labelText = this.schema.properties[key].title;else labelText = key;

        label = self.theme.getCheckboxLabel(labelText);

        control = self.theme.getFormControl(label, checkbox);
        control.style.paddingBottom = control.style.marginBottom = control.style.paddingTop = control.style.marginTop = 0;
        control.style.height = 'auto';
        //control.style.overflowY = 'hidden';

        this.insertPropertyControlUsingPropertyOrder(key, control, this.addproperty_list);

        checkbox.checked = key in this.editors;
        checkbox.addEventListener('change', function () {
          if (checkbox.checked) {
            self.addObjectProperty(key);
          } else {
            self.removeObjectProperty(key);
          }
          self.onChange(true);
        });
        self.addproperty_checkboxes[key] = checkbox;

        return checkbox;
      },
      showAddProperty: function () {
        if (!this.addproperty_holder) return;
        this.hideEditJSON();

        // Position the form directly beneath the button
        // TODO: edge detection
        this.addproperty_holder.style.left = this.addproperty_button.offsetLeft + "px";
        this.addproperty_holder.style.top = this.addproperty_button.offsetTop + this.addproperty_button.offsetHeight + "px";

        // Disable the rest of the form while editing JSON
        this.disable();

        this.adding_property = true;
        this.addproperty_button.disabled = false;
        this.addproperty_holder.style.display = '';
        this.refreshAddProperties();
      },
      hideAddProperty: function () {
        if (!this.addproperty_holder) return;
        if (!this.adding_property) return;

        this.addproperty_holder.style.display = 'none';
        this.enable();

        this.adding_property = false;
      },
      toggleAddProperty: function () {
        if (this.adding_property) this.hideAddProperty();else this.showAddProperty();
      },
      removeObjectProperty: function (property) {
        if (this.editors[property]) {
          this.editors[property].unregister();
          delete this.editors[property];

          this.refreshValue();
          this.layoutEditors();
        }
      },
      addObjectProperty: function (name, prebuild_only) {
        var self = this;

        // Property is already added
        if (this.editors[name]) return;

        // Property was added before and is cached
        if (this.cached_editors[name]) {
          this.editors[name] = this.cached_editors[name];
          if (prebuild_only) return;
          this.editors[name].register();
        }
        // New property
        else {
            if (!this.canHaveAdditionalProperties() && (!this.schema.properties || !this.schema.properties[name])) {
              return;
            }

            var schema = self.getPropertySchema(name);

            // Add the property
            var editor = self.jsoneditor.getEditorClass(schema);

            self.editors[name] = self.jsoneditor.createEditor(editor, {
              jsoneditor: self.jsoneditor,
              schema: schema,
              path: self.path + '.' + name,
              parent: self
            });
            self.editors[name].preBuild();

            if (!prebuild_only) {
              var holder = self.theme.getChildEditorHolder();
              self.editor_holder.appendChild(holder);
              self.editors[name].setContainer(holder);
              self.editors[name].build();
              self.editors[name].postBuild();
            }

            self.cached_editors[name] = self.editors[name];
          }

        // If we're only prebuilding the editors, don't refresh values
        if (!prebuild_only) {
          self.refreshValue();
          self.layoutEditors();
        }
      },
      onChildEditorChange: function (editor) {
        this.refreshValue();
        this._super(editor);
      },
      canHaveAdditionalProperties: function () {
        if (typeof this.schema.additionalProperties === "boolean") {
          return this.schema.additionalProperties;
        }
        return !this.jsoneditor.options.no_additional_properties;
      },
      destroy: function () {
        $each(this.cached_editors, function (i, el) {
          el.destroy();
        });
        if (this.editor_holder) this.editor_holder.innerHTML = '';
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.error_holder && this.error_holder.parentNode) this.error_holder.parentNode.removeChild(this.error_holder);

        this.editors = null;
        this.cached_editors = null;
        if (this.editor_holder && this.editor_holder.parentNode) this.editor_holder.parentNode.removeChild(this.editor_holder);
        this.editor_holder = null;

        this._super();
      },
      getValue: function () {
        var result = this._super();
        if (this.jsoneditor.options.remove_empty_properties || this.options.remove_empty_properties) {
          for (var i in result) {
            if (result.hasOwnProperty(i)) {
              if (!result[i]) delete result[i];
            }
          }
        }
        return result;
      },
      refreshValue: function () {
        this.value = {};
        var self = this;

        for (var i in this.editors) {
          if (!this.editors.hasOwnProperty(i)) continue;
          this.value[i] = this.editors[i].getValue();
        }

        if (this.adding_property) this.refreshAddProperties();
      },
      refreshAddProperties: function () {
        if (this.options.disable_properties || this.options.disable_properties !== false && this.jsoneditor.options.disable_properties) {
          this.addproperty_controls.style.display = 'none';
          return;
        }

        var can_add = false,
            can_remove = false,
            num_props = 0,
            i,
            show_modal = false;

        // Get number of editors
        for (i in this.editors) {
          if (!this.editors.hasOwnProperty(i)) continue;
          num_props++;
        }

        // Determine if we can add back removed properties
        can_add = this.canHaveAdditionalProperties() && !(typeof this.schema.maxProperties !== "undefined" && num_props >= this.schema.maxProperties);

        if (this.addproperty_checkboxes) {
          this.addproperty_list.innerHTML = '';
        }
        this.addproperty_checkboxes = {};

        // Check for which editors can't be removed or added back
        for (i in this.cached_editors) {
          if (!this.cached_editors.hasOwnProperty(i)) continue;

          this.addPropertyCheckbox(i);

          if (this.isRequired(this.cached_editors[i]) && i in this.editors) {
            this.addproperty_checkboxes[i].disabled = true;
          }

          if (typeof this.schema.minProperties !== "undefined" && num_props <= this.schema.minProperties) {
            this.addproperty_checkboxes[i].disabled = this.addproperty_checkboxes[i].checked;
            if (!this.addproperty_checkboxes[i].checked) show_modal = true;
          } else if (!(i in this.editors)) {
            if (!can_add && !this.schema.properties.hasOwnProperty(i)) {
              this.addproperty_checkboxes[i].disabled = true;
            } else {
              this.addproperty_checkboxes[i].disabled = false;
              show_modal = true;
            }
          } else {
            show_modal = true;
            can_remove = true;
          }
        }

        if (this.canHaveAdditionalProperties()) {
          show_modal = true;
        }

        // Additional addproperty checkboxes not tied to a current editor
        for (i in this.schema.properties) {
          if (!this.schema.properties.hasOwnProperty(i)) continue;
          if (this.cached_editors[i]) continue;
          show_modal = true;
          this.addPropertyCheckbox(i);
        }

        // If no editors can be added or removed, hide the modal button
        if (!show_modal) {
          this.hideAddProperty();
          this.addproperty_controls.style.display = 'none';
        }
        // If additional properties are disabled
        else if (!this.canHaveAdditionalProperties()) {
            this.addproperty_add.style.display = 'none';
            this.addproperty_input.style.display = 'none';
          }
          // If no new properties can be added
          else if (!can_add) {
              this.addproperty_add.disabled = true;
            }
            // If new properties can be added
            else {
                this.addproperty_add.disabled = false;
              }
      },
      isRequired: function (editor) {
        if (typeof editor.schema.required === "boolean") return editor.schema.required;else if (Array.isArray(this.schema.required)) return this.schema.required.indexOf(editor.key) > -1;else if (this.jsoneditor.options.required_by_default) return true;else return false;
      },
      setValue: function (value, initial) {
        var self = this;
        value = value || {};

        if (typeof value !== "object" || Array.isArray(value)) value = {};

        // First, set the values for all of the defined properties
        $each(this.cached_editors, function (i, editor) {
          // Value explicitly set
          if (typeof value[i] !== "undefined") {
            self.addObjectProperty(i);
            editor.setValue(value[i], initial);
          }
          // Otherwise, remove value unless this is the initial set or it's required
          else if (!initial && !self.isRequired(editor)) {
              self.removeObjectProperty(i);
            }
            // Otherwise, set the value to the default
            else {
                editor.setValue(editor.getDefault(), initial);
              }
        });

        $each(value, function (i, val) {
          if (!self.cached_editors[i]) {
            self.addObjectProperty(i);
            if (self.editors[i]) self.editors[i].setValue(val, initial);
          }
        });

        this.refreshValue();
        this.layoutEditors();
        this.onChange();
      },
      showValidationErrors: function (errors) {
        var self = this;

        // Get all the errors that pertain to this editor
        var my_errors = [];
        var other_errors = [];
        $each(errors, function (i, error) {
          if (error.path === self.path) {
            my_errors.push(error);
          } else {
            other_errors.push(error);
          }
        });

        // Show errors for this editor
        if (this.error_holder) {
          if (my_errors.length) {
            var message = [];
            this.error_holder.innerHTML = '';
            this.error_holder.style.display = '';
            $each(my_errors, function (i, error) {
              self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
            });
          }
          // Hide error area
          else {
              this.error_holder.style.display = 'none';
            }
        }

        // Show error for the table row if this is inside a table
        if (this.options.table_row) {
          if (my_errors.length) {
            this.theme.addTableRowError(this.container);
          } else {
            this.theme.removeTableRowError(this.container);
          }
        }

        // Show errors for child editors
        $each(this.editors, function (i, editor) {
          editor.showValidationErrors(other_errors);
        });
      }
    });

    JSONEditor.defaults.editors.array = JSONEditor.AbstractEditor.extend({
      getDefault: function () {
        return this.schema["default"] || [];
      },
      register: function () {
        this._super();
        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].register();
          }
        }
      },
      unregister: function () {
        this._super();
        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].unregister();
          }
        }
      },
      getNumColumns: function () {
        var info = this.getItemInfo(0);
        // Tabs require extra horizontal space
        if (this.tabs_holder) {
          return Math.max(Math.min(12, info.width + 2), 4);
        } else {
          return info.width;
        }
      },
      enable: function () {
        if (this.add_row_button) this.add_row_button.disabled = false;
        if (this.remove_all_rows_button) this.remove_all_rows_button.disabled = false;
        if (this.delete_last_row_button) this.delete_last_row_button.disabled = false;

        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].enable();

            if (this.rows[i].moveup_button) this.rows[i].moveup_button.disabled = false;
            if (this.rows[i].movedown_button) this.rows[i].movedown_button.disabled = false;
            if (this.rows[i].delete_button) this.rows[i].delete_button.disabled = false;
          }
        }
        this._super();
      },
      disable: function () {
        if (this.add_row_button) this.add_row_button.disabled = true;
        if (this.remove_all_rows_button) this.remove_all_rows_button.disabled = true;
        if (this.delete_last_row_button) this.delete_last_row_button.disabled = true;

        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].disable();

            if (this.rows[i].moveup_button) this.rows[i].moveup_button.disabled = true;
            if (this.rows[i].movedown_button) this.rows[i].movedown_button.disabled = true;
            if (this.rows[i].delete_button) this.rows[i].delete_button.disabled = true;
          }
        }
        this._super();
      },
      preBuild: function () {
        this._super();

        this.rows = [];
        this.row_cache = [];

        this.hide_delete_buttons = this.options.disable_array_delete || this.jsoneditor.options.disable_array_delete;
        this.hide_delete_all_rows_buttons = this.hide_delete_buttons || this.options.disable_array_delete_all_rows || this.jsoneditor.options.disable_array_delete_all_rows;
        this.hide_delete_last_row_buttons = this.hide_delete_buttons || this.options.disable_array_delete_last_row || this.jsoneditor.options.disable_array_delete_last_row;
        this.hide_move_buttons = this.options.disable_array_reorder || this.jsoneditor.options.disable_array_reorder;
        this.hide_add_button = this.options.disable_array_add || this.jsoneditor.options.disable_array_add;
      },
      build: function () {
        var self = this;

        if (!this.options.compact) {
          this.header = document.createElement('span');
          this.header.textContent = this.getTitle();
          this.title = this.theme.getHeader(this.header);
          this.container.appendChild(this.title);
          this.title_controls = this.theme.getHeaderButtonHolder();
          this.title.appendChild(this.title_controls);
          if (this.schema.description) {
            this.description = this.theme.getDescription(this.schema.description);
            this.container.appendChild(this.description);
          }
          this.error_holder = document.createElement('div');
          this.container.appendChild(this.error_holder);

          if (this.schema.format === 'tabs') {
            this.controls = this.theme.getHeaderButtonHolder();
            this.title.appendChild(this.controls);
            this.tabs_holder = this.theme.getTabHolder();
            this.container.appendChild(this.tabs_holder);
            this.row_holder = this.theme.getTabContentHolder(this.tabs_holder);

            this.active_tab = null;
          } else {
            this.panel = this.theme.getIndentedPanel();
            this.container.appendChild(this.panel);
            this.row_holder = document.createElement('div');
            this.panel.appendChild(this.row_holder);
            this.controls = this.theme.getButtonHolder();
            this.panel.appendChild(this.controls);
          }
        } else {
          this.panel = this.theme.getIndentedPanel();
          this.container.appendChild(this.panel);
          this.controls = this.theme.getButtonHolder();
          this.panel.appendChild(this.controls);
          this.row_holder = document.createElement('div');
          this.panel.appendChild(this.row_holder);
        }

        // Add controls
        this.addControls();
      },
      onChildEditorChange: function (editor) {
        this.refreshValue();
        this.refreshTabs(true);
        this._super(editor);
      },
      getItemTitle: function () {
        if (!this.item_title) {
          if (this.schema.items && !Array.isArray(this.schema.items)) {
            var tmp = this.jsoneditor.expandRefs(this.schema.items);
            this.item_title = tmp.title || 'item';
          } else {
            this.item_title = 'item';
          }
        }
        return this.item_title;
      },
      getItemSchema: function (i) {
        if (Array.isArray(this.schema.items)) {
          if (i >= this.schema.items.length) {
            if (this.schema.additionalItems === true) {
              return {};
            } else if (this.schema.additionalItems) {
              return $extend({}, this.schema.additionalItems);
            }
          } else {
            return $extend({}, this.schema.items[i]);
          }
        } else if (this.schema.items) {
          return $extend({}, this.schema.items);
        } else {
          return {};
        }
      },
      getItemInfo: function (i) {
        var schema = this.getItemSchema(i);

        // Check if it's cached
        this.item_info = this.item_info || {};
        var stringified = JSON.stringify(schema);
        if (typeof this.item_info[stringified] !== "undefined") return this.item_info[stringified];

        // Get the schema for this item
        schema = this.jsoneditor.expandRefs(schema);

        this.item_info[stringified] = {
          title: schema.title || "item",
          'default': schema["default"],
          width: 12,
          child_editors: schema.properties || schema.items
        };

        return this.item_info[stringified];
      },
      getElementEditor: function (i) {
        var item_info = this.getItemInfo(i);
        var schema = this.getItemSchema(i);
        schema = this.jsoneditor.expandRefs(schema);
        schema.title = item_info.title + ' ' + (i + 1);

        var editor = this.jsoneditor.getEditorClass(schema);

        var holder;
        if (this.tabs_holder) {
          holder = this.theme.getTabContent();
        } else if (item_info.child_editors) {
          holder = this.theme.getChildEditorHolder();
        } else {
          holder = this.theme.getIndentedPanel();
        }

        this.row_holder.appendChild(holder);

        var ret = this.jsoneditor.createEditor(editor, {
          jsoneditor: this.jsoneditor,
          schema: schema,
          container: holder,
          path: this.path + '.' + i,
          parent: this,
          required: true
        });
        ret.preBuild();
        ret.build();
        ret.postBuild();

        if (!ret.title_controls) {
          ret.array_controls = this.theme.getButtonHolder();
          holder.appendChild(ret.array_controls);
        }

        return ret;
      },
      destroy: function () {
        this.empty(true);
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.row_holder && this.row_holder.parentNode) this.row_holder.parentNode.removeChild(this.row_holder);
        if (this.controls && this.controls.parentNode) this.controls.parentNode.removeChild(this.controls);
        if (this.panel && this.panel.parentNode) this.panel.parentNode.removeChild(this.panel);

        this.rows = this.row_cache = this.title = this.description = this.row_holder = this.panel = this.controls = null;

        this._super();
      },
      empty: function (hard) {
        if (!this.rows) return;
        var self = this;
        $each(this.rows, function (i, row) {
          if (hard) {
            if (row.tab && row.tab.parentNode) row.tab.parentNode.removeChild(row.tab);
            self.destroyRow(row, true);
            self.row_cache[i] = null;
          }
          self.rows[i] = null;
        });
        self.rows = [];
        if (hard) self.row_cache = [];
      },
      destroyRow: function (row, hard) {
        var holder = row.container;
        if (hard) {
          row.destroy();
          if (holder.parentNode) holder.parentNode.removeChild(holder);
          if (row.tab && row.tab.parentNode) row.tab.parentNode.removeChild(row.tab);
        } else {
          if (row.tab) row.tab.style.display = 'none';
          holder.style.display = 'none';
          row.unregister();
        }
      },
      getMax: function () {
        if (Array.isArray(this.schema.items) && this.schema.additionalItems === false) {
          return Math.min(this.schema.items.length, this.schema.maxItems || Infinity);
        } else {
          return this.schema.maxItems || Infinity;
        }
      },
      refreshTabs: function (refresh_headers) {
        var self = this;
        $each(this.rows, function (i, row) {
          if (!row.tab) return;

          if (refresh_headers) {
            row.tab_text.textContent = row.getHeaderText();
          } else {
            if (row.tab === self.active_tab) {
              self.theme.markTabActive(row.tab);
              row.container.style.display = '';
            } else {
              self.theme.markTabInactive(row.tab);
              row.container.style.display = 'none';
            }
          }
        });
      },
      setValue: function (value, initial) {
        // Update the array's value, adding/removing rows when necessary
        value = value || [];

        if (!Array.isArray(value)) value = [value];

        var serialized = JSON.stringify(value);
        if (serialized === this.serialized) return;

        // Make sure value has between minItems and maxItems items in it
        if (this.schema.minItems) {
          while (value.length < this.schema.minItems) {
            value.push(this.getItemInfo(value.length)["default"]);
          }
        }
        if (this.getMax() && value.length > this.getMax()) {
          value = value.slice(0, this.getMax());
        }

        var self = this;
        $each(value, function (i, val) {
          if (self.rows[i]) {
            // TODO: don't set the row's value if it hasn't changed
            self.rows[i].setValue(val, initial);
          } else if (self.row_cache[i]) {
            self.rows[i] = self.row_cache[i];
            self.rows[i].setValue(val, initial);
            self.rows[i].container.style.display = '';
            if (self.rows[i].tab) self.rows[i].tab.style.display = '';
            self.rows[i].register();
          } else {
            self.addRow(val, initial);
          }
        });

        for (var j = value.length; j < self.rows.length; j++) {
          self.destroyRow(self.rows[j]);
          self.rows[j] = null;
        }
        self.rows = self.rows.slice(0, value.length);

        // Set the active tab
        var new_active_tab = null;
        $each(self.rows, function (i, row) {
          if (row.tab === self.active_tab) {
            new_active_tab = row.tab;
            return false;
          }
        });
        if (!new_active_tab && self.rows.length) new_active_tab = self.rows[0].tab;

        self.active_tab = new_active_tab;

        self.refreshValue(initial);
        self.refreshTabs(true);
        self.refreshTabs();

        self.onChange();

        // TODO: sortable
      },
      refreshValue: function (force) {
        var self = this;
        var oldi = this.value ? this.value.length : 0;
        this.value = [];

        $each(this.rows, function (i, editor) {
          // Get the value for this editor
          self.value[i] = editor.getValue();
        });

        if (oldi !== this.value.length || force) {
          // If we currently have minItems items in the array
          var minItems = this.schema.minItems && this.schema.minItems >= this.rows.length;

          $each(this.rows, function (i, editor) {
            // Hide the move down button for the last row
            if (editor.movedown_button) {
              if (i === self.rows.length - 1) {
                editor.movedown_button.style.display = 'none';
              } else {
                editor.movedown_button.style.display = '';
              }
            }

            // Hide the delete button if we have minItems items
            if (editor.delete_button) {
              if (minItems) {
                editor.delete_button.style.display = 'none';
              } else {
                editor.delete_button.style.display = '';
              }
            }

            // Get the value for this editor
            self.value[i] = editor.getValue();
          });

          var controls_needed = false;

          if (!this.value.length) {
            this.delete_last_row_button.style.display = 'none';
            this.remove_all_rows_button.style.display = 'none';
          } else if (this.value.length === 1) {
            this.remove_all_rows_button.style.display = 'none';

            // If there are minItems items in the array, or configured to hide the delete_last_row button, hide the delete button beneath the rows
            if (minItems || this.hide_delete_last_row_buttons) {
              this.delete_last_row_button.style.display = 'none';
            } else {
              this.delete_last_row_button.style.display = '';
              controls_needed = true;
            }
          } else {
            if (minItems || this.hide_delete_last_row_buttons) {
              this.delete_last_row_button.style.display = 'none';
            } else {
              this.delete_last_row_button.style.display = '';
              controls_needed = true;
            }

            if (minItems || this.hide_delete_all_rows_buttons) {
              this.remove_all_rows_button.style.display = 'none';
            } else {
              this.remove_all_rows_button.style.display = '';
              controls_needed = true;
            }
          }

          // If there are maxItems in the array, hide the add button beneath the rows
          if (this.getMax() && this.getMax() <= this.rows.length || this.hide_add_button) {
            this.add_row_button.style.display = 'none';
          } else {
            this.add_row_button.style.display = '';
            controls_needed = true;
          }

          if (!this.collapsed && controls_needed) {
            this.controls.style.display = 'inline-block';
          } else {
            this.controls.style.display = 'none';
          }
        }
      },
      addRow: function (value, initial) {
        var self = this;
        var i = this.rows.length;

        self.rows[i] = this.getElementEditor(i);
        self.row_cache[i] = self.rows[i];

        if (self.tabs_holder) {
          self.rows[i].tab_text = document.createElement('span');
          self.rows[i].tab_text.textContent = self.rows[i].getHeaderText();
          self.rows[i].tab = self.theme.getTab(self.rows[i].tab_text);
          self.rows[i].tab.addEventListener('click', function (e) {
            self.active_tab = self.rows[i].tab;
            self.refreshTabs();
            e.preventDefault();
            e.stopPropagation();
          });

          self.theme.addTab(self.tabs_holder, self.rows[i].tab);
        }

        var controls_holder = self.rows[i].title_controls || self.rows[i].array_controls;

        // Buttons to delete row, move row up, and move row down
        if (!self.hide_delete_buttons) {
          self.rows[i].delete_button = this.getButton(self.getItemTitle(), 'delete', this.translate('button_delete_row_title', [self.getItemTitle()]));
          self.rows[i].delete_button.className += ' delete';
          self.rows[i].delete_button.setAttribute('data-i', i);
          self.rows[i].delete_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;

            var value = self.getValue();

            var newval = [];
            var new_active_tab = null;
            $each(value, function (j, row) {
              if (j === i) {
                // If the one we're deleting is the active tab
                if (self.rows[j].tab === self.active_tab) {
                  // Make the next tab active if there is one
                  // Note: the next tab is going to be the current tab after deletion
                  if (self.rows[j + 1]) new_active_tab = self.rows[j].tab;
                  // Otherwise, make the previous tab active if there is one
                  else if (j) new_active_tab = self.rows[j - 1].tab;
                }

                return; // If this is the one we're deleting
              }
              newval.push(row);
            });
            self.setValue(newval);
            if (new_active_tab) {
              self.active_tab = new_active_tab;
              self.refreshTabs();
            }

            self.onChange(true);
          });

          if (controls_holder) {
            controls_holder.appendChild(self.rows[i].delete_button);
          }
        }

        if (i && !self.hide_move_buttons) {
          self.rows[i].moveup_button = this.getButton('', 'moveup', this.translate('button_move_up_title'));
          self.rows[i].moveup_button.className += ' moveup';
          self.rows[i].moveup_button.setAttribute('data-i', i);
          self.rows[i].moveup_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;

            if (i <= 0) return;
            var rows = self.getValue();
            var tmp = rows[i - 1];
            rows[i - 1] = rows[i];
            rows[i] = tmp;

            self.setValue(rows);
            self.active_tab = self.rows[i - 1].tab;
            self.refreshTabs();

            self.onChange(true);
          });

          if (controls_holder) {
            controls_holder.appendChild(self.rows[i].moveup_button);
          }
        }

        if (!self.hide_move_buttons) {
          self.rows[i].movedown_button = this.getButton('', 'movedown', this.translate('button_move_down_title'));
          self.rows[i].movedown_button.className += ' movedown';
          self.rows[i].movedown_button.setAttribute('data-i', i);
          self.rows[i].movedown_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;

            var rows = self.getValue();
            if (i >= rows.length - 1) return;
            var tmp = rows[i + 1];
            rows[i + 1] = rows[i];
            rows[i] = tmp;

            self.setValue(rows);
            self.active_tab = self.rows[i + 1].tab;
            self.refreshTabs();
            self.onChange(true);
          });

          if (controls_holder) {
            controls_holder.appendChild(self.rows[i].movedown_button);
          }
        }

        if (value) self.rows[i].setValue(value, initial);
        self.refreshTabs();
      },
      addControls: function () {
        var self = this;

        this.collapsed = false;
        this.toggle_button = this.getButton('', 'collapse', this.translate('button_collapse'));
        this.title_controls.appendChild(this.toggle_button);
        var row_holder_display = self.row_holder.style.display;
        var controls_display = self.controls.style.display;
        this.toggle_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          if (self.collapsed) {
            self.collapsed = false;
            if (self.panel) self.panel.style.display = '';
            self.row_holder.style.display = row_holder_display;
            if (self.tabs_holder) self.tabs_holder.style.display = '';
            self.controls.style.display = controls_display;
            self.setButtonText(this, '', 'collapse', self.translate('button_collapse'));
          } else {
            self.collapsed = true;
            self.row_holder.style.display = 'none';
            if (self.tabs_holder) self.tabs_holder.style.display = 'none';
            self.controls.style.display = 'none';
            if (self.panel) self.panel.style.display = 'none';
            self.setButtonText(this, '', 'expand', self.translate('button_expand'));
          }
        });

        // If it should start collapsed
        if (this.options.collapsed) {
          $trigger(this.toggle_button, 'click');
        }

        // Collapse button disabled
        if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
          if (this.schema.options.disable_collapse) this.toggle_button.style.display = 'none';
        } else if (this.jsoneditor.options.disable_collapse) {
          this.toggle_button.style.display = 'none';
        }

        // Add "new row" and "delete last" buttons below editor
        this.add_row_button = this.getButton(this.getItemTitle(), 'add', this.translate('button_add_row_title', [this.getItemTitle()]));

        this.add_row_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          var i = self.rows.length;
          if (self.row_cache[i]) {
            self.rows[i] = self.row_cache[i];
            self.rows[i].setValue(self.rows[i].getDefault(), true);
            self.rows[i].container.style.display = '';
            if (self.rows[i].tab) self.rows[i].tab.style.display = '';
            self.rows[i].register();
          } else {
            self.addRow();
          }
          self.active_tab = self.rows[i].tab;
          self.refreshTabs();
          self.refreshValue();
          self.onChange(true);
        });
        self.controls.appendChild(this.add_row_button);

        this.delete_last_row_button = this.getButton(this.translate('button_delete_last', [this.getItemTitle()]), 'delete', this.translate('button_delete_last_title', [this.getItemTitle()]));
        this.delete_last_row_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          var rows = self.getValue();

          var new_active_tab = null;
          if (self.rows.length > 1 && self.rows[self.rows.length - 1].tab === self.active_tab) new_active_tab = self.rows[self.rows.length - 2].tab;

          rows.pop();
          self.setValue(rows);
          if (new_active_tab) {
            self.active_tab = new_active_tab;
            self.refreshTabs();
          }
          self.onChange(true);
        });
        self.controls.appendChild(this.delete_last_row_button);

        this.remove_all_rows_button = this.getButton(this.translate('button_delete_all'), 'delete', this.translate('button_delete_all_title'));
        this.remove_all_rows_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          self.setValue([]);
          self.onChange(true);
        });
        self.controls.appendChild(this.remove_all_rows_button);

        if (self.tabs) {
          this.add_row_button.style.width = '100%';
          this.add_row_button.style.textAlign = 'left';
          this.add_row_button.style.marginBottom = '3px';

          this.delete_last_row_button.style.width = '100%';
          this.delete_last_row_button.style.textAlign = 'left';
          this.delete_last_row_button.style.marginBottom = '3px';

          this.remove_all_rows_button.style.width = '100%';
          this.remove_all_rows_button.style.textAlign = 'left';
          this.remove_all_rows_button.style.marginBottom = '3px';
        }
      },
      showValidationErrors: function (errors) {
        var self = this;

        // Get all the errors that pertain to this editor
        var my_errors = [];
        var other_errors = [];
        $each(errors, function (i, error) {
          if (error.path === self.path) {
            my_errors.push(error);
          } else {
            other_errors.push(error);
          }
        });

        // Show errors for this editor
        if (this.error_holder) {
          if (my_errors.length) {
            var message = [];
            this.error_holder.innerHTML = '';
            this.error_holder.style.display = '';
            $each(my_errors, function (i, error) {
              self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
            });
          }
          // Hide error area
          else {
              this.error_holder.style.display = 'none';
            }
        }

        // Show errors for child editors
        $each(this.rows, function (i, row) {
          row.showValidationErrors(other_errors);
        });
      }
    });

    JSONEditor.defaults.editors.table = JSONEditor.defaults.editors.array.extend({
      register: function () {
        this._super();
        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].register();
          }
        }
      },
      unregister: function () {
        this._super();
        if (this.rows) {
          for (var i = 0; i < this.rows.length; i++) {
            this.rows[i].unregister();
          }
        }
      },
      getNumColumns: function () {
        return Math.max(Math.min(12, this.width), 3);
      },
      preBuild: function () {
        var item_schema = this.jsoneditor.expandRefs(this.schema.items || {});

        this.item_title = item_schema.title || 'row';
        this.item_default = item_schema["default"] || null;
        this.item_has_child_editors = item_schema.properties || item_schema.items;
        this.width = 12;
        this._super();
      },
      build: function () {
        var self = this;
        this.table = this.theme.getTable();
        this.container.appendChild(this.table);
        this.thead = this.theme.getTableHead();
        this.table.appendChild(this.thead);
        this.header_row = this.theme.getTableRow();
        this.thead.appendChild(this.header_row);
        this.row_holder = this.theme.getTableBody();
        this.table.appendChild(this.row_holder);

        // Determine the default value of array element
        var tmp = this.getElementEditor(0, true);
        this.item_default = tmp.getDefault();
        this.width = tmp.getNumColumns() + 2;

        if (!this.options.compact) {
          this.title = this.theme.getHeader(this.getTitle());
          this.container.appendChild(this.title);
          this.title_controls = this.theme.getHeaderButtonHolder();
          this.title.appendChild(this.title_controls);
          if (this.schema.description) {
            this.description = this.theme.getDescription(this.schema.description);
            this.container.appendChild(this.description);
          }
          this.panel = this.theme.getIndentedPanel();
          this.container.appendChild(this.panel);
          this.error_holder = document.createElement('div');
          this.panel.appendChild(this.error_holder);
        } else {
          this.panel = document.createElement('div');
          this.container.appendChild(this.panel);
        }

        this.panel.appendChild(this.table);
        this.controls = this.theme.getButtonHolder();
        this.panel.appendChild(this.controls);

        if (this.item_has_child_editors) {
          var ce = tmp.getChildEditors();
          var order = tmp.property_order || Object.keys(ce);
          for (var i = 0; i < order.length; i++) {
            var th = self.theme.getTableHeaderCell(ce[order[i]].getTitle());
            if (ce[order[i]].options.hidden) th.style.display = 'none';
            self.header_row.appendChild(th);
          }
        } else {
          self.header_row.appendChild(self.theme.getTableHeaderCell(this.item_title));
        }

        tmp.destroy();
        this.row_holder.innerHTML = '';

        // Row Controls column
        this.controls_header_cell = self.theme.getTableHeaderCell(" ");
        self.header_row.appendChild(this.controls_header_cell);

        // Add controls
        this.addControls();
      },
      onChildEditorChange: function (editor) {
        this.refreshValue();
        this._super();
      },
      getItemDefault: function () {
        return $extend({}, { "default": this.item_default })["default"];
      },
      getItemTitle: function () {
        return this.item_title;
      },
      getElementEditor: function (i, ignore) {
        var schema_copy = $extend({}, this.schema.items);
        var editor = this.jsoneditor.getEditorClass(schema_copy, this.jsoneditor);
        var row = this.row_holder.appendChild(this.theme.getTableRow());
        var holder = row;
        if (!this.item_has_child_editors) {
          holder = this.theme.getTableCell();
          row.appendChild(holder);
        }

        var ret = this.jsoneditor.createEditor(editor, {
          jsoneditor: this.jsoneditor,
          schema: schema_copy,
          container: holder,
          path: this.path + '.' + i,
          parent: this,
          compact: true,
          table_row: true
        });

        ret.preBuild();
        if (!ignore) {
          ret.build();
          ret.postBuild();

          ret.controls_cell = row.appendChild(this.theme.getTableCell());
          ret.row = row;
          ret.table_controls = this.theme.getButtonHolder();
          ret.controls_cell.appendChild(ret.table_controls);
          ret.table_controls.style.margin = 0;
          ret.table_controls.style.padding = 0;
        }

        return ret;
      },
      destroy: function () {
        this.innerHTML = '';
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.row_holder && this.row_holder.parentNode) this.row_holder.parentNode.removeChild(this.row_holder);
        if (this.table && this.table.parentNode) this.table.parentNode.removeChild(this.table);
        if (this.panel && this.panel.parentNode) this.panel.parentNode.removeChild(this.panel);

        this.rows = this.title = this.description = this.row_holder = this.table = this.panel = null;

        this._super();
      },
      setValue: function (value, initial) {
        // Update the array's value, adding/removing rows when necessary
        value = value || [];

        // Make sure value has between minItems and maxItems items in it
        if (this.schema.minItems) {
          while (value.length < this.schema.minItems) {
            value.push(this.getItemDefault());
          }
        }
        if (this.schema.maxItems && value.length > this.schema.maxItems) {
          value = value.slice(0, this.schema.maxItems);
        }

        var serialized = JSON.stringify(value);
        if (serialized === this.serialized) return;

        var numrows_changed = false;

        var self = this;
        $each(value, function (i, val) {
          if (self.rows[i]) {
            // TODO: don't set the row's value if it hasn't changed
            self.rows[i].setValue(val);
          } else {
            self.addRow(val);
            numrows_changed = true;
          }
        });

        for (var j = value.length; j < self.rows.length; j++) {
          var holder = self.rows[j].container;
          if (!self.item_has_child_editors) {
            self.rows[j].row.parentNode.removeChild(self.rows[j].row);
          }
          self.rows[j].destroy();
          if (holder.parentNode) holder.parentNode.removeChild(holder);
          self.rows[j] = null;
          numrows_changed = true;
        }
        self.rows = self.rows.slice(0, value.length);

        self.refreshValue();
        if (numrows_changed || initial) self.refreshRowButtons();

        self.onChange();

        // TODO: sortable
      },
      refreshRowButtons: function () {
        var self = this;

        // If we currently have minItems items in the array
        var minItems = this.schema.minItems && this.schema.minItems >= this.rows.length;

        var need_row_buttons = false;
        $each(this.rows, function (i, editor) {
          // Hide the move down button for the last row
          if (editor.movedown_button) {
            if (i === self.rows.length - 1) {
              editor.movedown_button.style.display = 'none';
            } else {
              need_row_buttons = true;
              editor.movedown_button.style.display = '';
            }
          }

          // Hide the delete button if we have minItems items
          if (editor.delete_button) {
            if (minItems) {
              editor.delete_button.style.display = 'none';
            } else {
              need_row_buttons = true;
              editor.delete_button.style.display = '';
            }
          }

          if (editor.moveup_button) {
            need_row_buttons = true;
          }
        });

        // Show/hide controls column in table
        $each(this.rows, function (i, editor) {
          if (need_row_buttons) {
            editor.controls_cell.style.display = '';
          } else {
            editor.controls_cell.style.display = 'none';
          }
        });
        if (need_row_buttons) {
          this.controls_header_cell.style.display = '';
        } else {
          this.controls_header_cell.style.display = 'none';
        }

        var controls_needed = false;

        if (!this.value.length) {
          this.delete_last_row_button.style.display = 'none';
          this.remove_all_rows_button.style.display = 'none';
          this.table.style.display = 'none';
        } else if (this.value.length === 1) {
          this.table.style.display = '';
          this.remove_all_rows_button.style.display = 'none';

          // If there are minItems items in the array, or configured to hide the delete_last_row button, hide the delete button beneath the rows
          if (minItems || this.hide_delete_last_row_buttons) {
            this.delete_last_row_button.style.display = 'none';
          } else {
            this.delete_last_row_button.style.display = '';
            controls_needed = true;
          }
        } else {
          this.table.style.display = '';

          if (minItems || this.hide_delete_last_row_buttons) {
            this.delete_last_row_button.style.display = 'none';
          } else {
            this.delete_last_row_button.style.display = '';
            controls_needed = true;
          }

          if (minItems || this.hide_delete_all_rows_buttons) {
            this.remove_all_rows_button.style.display = 'none';
          } else {
            this.remove_all_rows_button.style.display = '';
            controls_needed = true;
          }
        }

        // If there are maxItems in the array, hide the add button beneath the rows
        if (this.schema.maxItems && this.schema.maxItems <= this.rows.length || this.hide_add_button) {
          this.add_row_button.style.display = 'none';
        } else {
          this.add_row_button.style.display = '';
          controls_needed = true;
        }

        if (!controls_needed) {
          this.controls.style.display = 'none';
        } else {
          this.controls.style.display = '';
        }
      },
      refreshValue: function () {
        var self = this;
        this.value = [];

        $each(this.rows, function (i, editor) {
          // Get the value for this editor
          self.value[i] = editor.getValue();
        });
        this.serialized = JSON.stringify(this.value);
      },
      addRow: function (value) {
        var self = this;
        var i = this.rows.length;

        self.rows[i] = this.getElementEditor(i);

        var controls_holder = self.rows[i].table_controls;

        // Buttons to delete row, move row up, and move row down
        if (!this.hide_delete_buttons) {
          self.rows[i].delete_button = this.getButton('', 'delete', this.translate('button_delete_row_title_short'));
          self.rows[i].delete_button.className += ' delete';
          self.rows[i].delete_button.setAttribute('data-i', i);
          self.rows[i].delete_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;

            var value = self.getValue();

            var newval = [];
            $each(value, function (j, row) {
              if (j === i) return; // If this is the one we're deleting
              newval.push(row);
            });
            self.setValue(newval);
            self.onChange(true);
          });
          controls_holder.appendChild(self.rows[i].delete_button);
        }

        if (i && !this.hide_move_buttons) {
          self.rows[i].moveup_button = this.getButton('', 'moveup', this.translate('button_move_up_title'));
          self.rows[i].moveup_button.className += ' moveup';
          self.rows[i].moveup_button.setAttribute('data-i', i);
          self.rows[i].moveup_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;

            if (i <= 0) return;
            var rows = self.getValue();
            var tmp = rows[i - 1];
            rows[i - 1] = rows[i];
            rows[i] = tmp;

            self.setValue(rows);
            self.onChange(true);
          });
          controls_holder.appendChild(self.rows[i].moveup_button);
        }

        if (!this.hide_move_buttons) {
          self.rows[i].movedown_button = this.getButton('', 'movedown', this.translate('button_move_down_title'));
          self.rows[i].movedown_button.className += ' movedown';
          self.rows[i].movedown_button.setAttribute('data-i', i);
          self.rows[i].movedown_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            var i = this.getAttribute('data-i') * 1;
            var rows = self.getValue();
            if (i >= rows.length - 1) return;
            var tmp = rows[i + 1];
            rows[i + 1] = rows[i];
            rows[i] = tmp;

            self.setValue(rows);
            self.onChange(true);
          });
          controls_holder.appendChild(self.rows[i].movedown_button);
        }

        if (value) self.rows[i].setValue(value);
      },
      addControls: function () {
        var self = this;

        this.collapsed = false;
        this.toggle_button = this.getButton('', 'collapse', this.translate('button_collapse'));
        if (this.title_controls) {
          this.title_controls.appendChild(this.toggle_button);
          this.toggle_button.addEventListener('click', function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (self.collapsed) {
              self.collapsed = false;
              self.panel.style.display = '';
              self.setButtonText(this, '', 'collapse', self.translate('button_collapse'));
            } else {
              self.collapsed = true;
              self.panel.style.display = 'none';
              self.setButtonText(this, '', 'expand', self.translate('button_expand'));
            }
          });

          // If it should start collapsed
          if (this.options.collapsed) {
            $trigger(this.toggle_button, 'click');
          }

          // Collapse button disabled
          if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
            if (this.schema.options.disable_collapse) this.toggle_button.style.display = 'none';
          } else if (this.jsoneditor.options.disable_collapse) {
            this.toggle_button.style.display = 'none';
          }
        }

        // Add "new row" and "delete last" buttons below editor
        this.add_row_button = this.getButton(this.getItemTitle(), 'add', this.translate('button_add_row_title', [this.getItemTitle()]));
        this.add_row_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          self.addRow();
          self.refreshValue();
          self.refreshRowButtons();
          self.onChange(true);
        });
        self.controls.appendChild(this.add_row_button);

        this.delete_last_row_button = this.getButton(this.translate('button_delete_last', [this.getItemTitle()]), 'delete', this.translate('button_delete_last_title', [this.getItemTitle()]));
        this.delete_last_row_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          var rows = self.getValue();
          rows.pop();
          self.setValue(rows);
          self.onChange(true);
        });
        self.controls.appendChild(this.delete_last_row_button);

        this.remove_all_rows_button = this.getButton(this.translate('button_delete_all'), 'delete', this.translate('button_delete_all_title'));
        this.remove_all_rows_button.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          self.setValue([]);
          self.onChange(true);
        });
        self.controls.appendChild(this.remove_all_rows_button);
      }
    });

    // Multiple Editor (for when `type` is an array)
    JSONEditor.defaults.editors.multiple = JSONEditor.AbstractEditor.extend({
      register: function () {
        if (this.editors) {
          for (var i = 0; i < this.editors.length; i++) {
            if (!this.editors[i]) continue;
            this.editors[i].unregister();
          }
          if (this.editors[this.type]) this.editors[this.type].register();
        }
        this._super();
      },
      unregister: function () {
        this._super();
        if (this.editors) {
          for (var i = 0; i < this.editors.length; i++) {
            if (!this.editors[i]) continue;
            this.editors[i].unregister();
          }
        }
      },
      getNumColumns: function () {
        if (!this.editors[this.type]) return 4;
        return Math.max(this.editors[this.type].getNumColumns(), 4);
      },
      enable: function () {
        if (this.editors) {
          for (var i = 0; i < this.editors.length; i++) {
            if (!this.editors[i]) continue;
            this.editors[i].enable();
          }
        }
        this.switcher.disabled = false;
        this._super();
      },
      disable: function () {
        if (this.editors) {
          for (var i = 0; i < this.editors.length; i++) {
            if (!this.editors[i]) continue;
            this.editors[i].disable();
          }
        }
        this.switcher.disabled = true;
        this._super();
      },
      switchEditor: function (i) {
        var self = this;

        if (!this.editors[i]) {
          this.buildChildEditor(i);
        }

        var current_value = self.getValue();

        self.type = i;

        self.register();

        $each(self.editors, function (type, editor) {
          if (!editor) return;
          if (self.type === type) {
            if (self.keep_values) editor.setValue(current_value, true);
            editor.container.style.display = '';
          } else editor.container.style.display = 'none';
        });
        self.refreshValue();
        self.refreshHeaderText();
      },
      buildChildEditor: function (i) {
        var self = this;
        var type = this.types[i];
        var holder = self.theme.getChildEditorHolder();
        self.editor_holder.appendChild(holder);

        var schema;

        if (typeof type === "string") {
          schema = $extend({}, self.schema);
          schema.type = type;
        } else {
          schema = $extend({}, self.schema, type);
          schema = self.jsoneditor.expandRefs(schema);

          // If we need to merge `required` arrays
          if (type.required && Array.isArray(type.required) && self.schema.required && Array.isArray(self.schema.required)) {
            schema.required = self.schema.required.concat(type.required);
          }
        }

        var editor = self.jsoneditor.getEditorClass(schema);

        self.editors[i] = self.jsoneditor.createEditor(editor, {
          jsoneditor: self.jsoneditor,
          schema: schema,
          container: holder,
          path: self.path,
          parent: self,
          required: true
        });
        self.editors[i].preBuild();
        self.editors[i].build();
        self.editors[i].postBuild();

        if (self.editors[i].header) self.editors[i].header.style.display = 'none';

        self.editors[i].option = self.switcher_options[i];

        holder.addEventListener('change_header_text', function () {
          self.refreshHeaderText();
        });

        if (i !== self.type) holder.style.display = 'none';
      },
      preBuild: function () {
        var self = this;

        this.types = [];
        this.type = 0;
        this.editors = [];
        this.validators = [];

        this.keep_values = true;
        if (typeof this.jsoneditor.options.keep_oneof_values !== "undefined") this.keep_values = this.jsoneditor.options.keep_oneof_values;
        if (typeof this.options.keep_oneof_values !== "undefined") this.keep_values = this.options.keep_oneof_values;

        if (this.schema.oneOf) {
          this.oneOf = true;
          this.types = this.schema.oneOf;
          delete this.schema.oneOf;
        } else if (this.schema.anyOf) {
          this.anyOf = true;
          this.types = this.schema.anyOf;
          delete this.schema.anyOf;
        } else {
          if (!this.schema.type || this.schema.type === "any") {
            this.types = ['string', 'number', 'integer', 'boolean', 'object', 'array', 'null'];

            // If any of these primitive types are disallowed
            if (this.schema.disallow) {
              var disallow = this.schema.disallow;
              if (typeof disallow !== 'object' || !Array.isArray(disallow)) {
                disallow = [disallow];
              }
              var allowed_types = [];
              $each(this.types, function (i, type) {
                if (disallow.indexOf(type) === -1) allowed_types.push(type);
              });
              this.types = allowed_types;
            }
          } else if (Array.isArray(this.schema.type)) {
            this.types = this.schema.type;
          } else {
            this.types = [this.schema.type];
          }
          delete this.schema.type;
        }

        this.display_text = this.getDisplayText(this.types);
      },
      build: function () {
        var self = this;
        var container = this.container;

        this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        this.container.appendChild(this.header);

        this.switcher = this.theme.getSwitcher(this.display_text);
        container.appendChild(this.switcher);
        this.switcher.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();

          self.switchEditor(self.display_text.indexOf(this.value));
          self.onChange(true);
        });

        this.editor_holder = document.createElement('div');
        container.appendChild(this.editor_holder);

        var validator_options = {};
        if (self.jsoneditor.options.custom_validators) {
          validator_options.custom_validators = self.jsoneditor.options.custom_validators;
        }

        this.switcher_options = this.theme.getSwitcherOptions(this.switcher);
        $each(this.types, function (i, type) {
          self.editors[i] = false;

          var schema;

          if (typeof type === "string") {
            schema = $extend({}, self.schema);
            schema.type = type;
          } else {
            schema = $extend({}, self.schema, type);

            // If we need to merge `required` arrays
            if (type.required && Array.isArray(type.required) && self.schema.required && Array.isArray(self.schema.required)) {
              schema.required = self.schema.required.concat(type.required);
            }
          }

          self.validators[i] = new JSONEditor.Validator(self.jsoneditor, schema, validator_options);
        });

        this.switchEditor(0);
      },
      onChildEditorChange: function (editor) {
        if (this.editors[this.type]) {
          this.refreshValue();
          this.refreshHeaderText();
        }

        this._super();
      },
      refreshHeaderText: function () {
        var display_text = this.getDisplayText(this.types);
        $each(this.switcher_options, function (i, option) {
          option.textContent = display_text[i];
        });
      },
      refreshValue: function () {
        this.value = this.editors[this.type].getValue();
      },
      setValue: function (val, initial) {
        // Determine type by getting the first one that validates
        var self = this;
        $each(this.validators, function (i, validator) {
          if (!validator.validate(val).length) {
            self.type = i;
            self.switcher.value = self.display_text[i];
            return false;
          }
        });

        this.switchEditor(this.type);

        this.editors[this.type].setValue(val, initial);

        this.refreshValue();
        self.onChange();
      },
      destroy: function () {
        $each(this.editors, function (type, editor) {
          if (editor) editor.destroy();
        });
        if (this.editor_holder && this.editor_holder.parentNode) this.editor_holder.parentNode.removeChild(this.editor_holder);
        if (this.switcher && this.switcher.parentNode) this.switcher.parentNode.removeChild(this.switcher);
        this._super();
      },
      showValidationErrors: function (errors) {
        var self = this;

        // oneOf and anyOf error paths need to remove the oneOf[i] part before passing to child editors
        if (this.oneOf || this.anyOf) {
          var check_part = this.oneOf ? 'oneOf' : 'anyOf';
          $each(this.editors, function (i, editor) {
            if (!editor) return;
            var check = self.path + '.' + check_part + '[' + i + ']';
            var new_errors = [];
            $each(errors, function (j, error) {
              if (error.path.substr(0, check.length) === check) {
                var new_error = $extend({}, error);
                new_error.path = self.path + new_error.path.substr(check.length);
                new_errors.push(new_error);
              }
            });

            editor.showValidationErrors(new_errors);
          });
        } else {
          $each(this.editors, function (type, editor) {
            if (!editor) return;
            editor.showValidationErrors(errors);
          });
        }
      }
    });

    // Enum Editor (used for objects and arrays with enumerated values)
    JSONEditor.defaults.editors["enum"] = JSONEditor.AbstractEditor.extend({
      getNumColumns: function () {
        return 4;
      },
      build: function () {
        var container = this.container;
        this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        this.container.appendChild(this.title);

        this.options.enum_titles = this.options.enum_titles || [];

        this["enum"] = this.schema["enum"];
        this.selected = 0;
        this.select_options = [];
        this.html_values = [];

        var self = this;
        for (var i = 0; i < this["enum"].length; i++) {
          this.select_options[i] = this.options.enum_titles[i] || "Value " + (i + 1);
          this.html_values[i] = this.getHTML(this["enum"][i]);
        }

        // Switcher
        this.switcher = this.theme.getSwitcher(this.select_options);
        this.container.appendChild(this.switcher);

        // Display area
        this.display_area = this.theme.getIndentedPanel();
        this.container.appendChild(this.display_area);

        if (this.options.hide_display) this.display_area.style.display = "none";

        this.switcher.addEventListener('change', function () {
          self.selected = self.select_options.indexOf(this.value);
          self.value = self["enum"][self.selected];
          self.refreshValue();
          self.onChange(true);
        });
        this.value = this["enum"][0];
        this.refreshValue();

        if (this["enum"].length === 1) this.switcher.style.display = 'none';
      },
      refreshValue: function () {
        var self = this;
        self.selected = -1;
        var stringified = JSON.stringify(this.value);
        $each(this["enum"], function (i, el) {
          if (stringified === JSON.stringify(el)) {
            self.selected = i;
            return false;
          }
        });

        if (self.selected < 0) {
          self.setValue(self["enum"][0]);
          return;
        }

        this.switcher.value = this.select_options[this.selected];
        this.display_area.innerHTML = this.html_values[this.selected];
      },
      enable: function () {
        if (!this.always_disabled) this.switcher.disabled = false;
        this._super();
      },
      disable: function () {
        this.switcher.disabled = true;
        this._super();
      },
      getHTML: function (el) {
        var self = this;

        if (el === null) {
          return '<em>null</em>';
        }
        // Array or Object
        else if (typeof el === "object") {
            // TODO: use theme
            var ret = '';

            $each(el, function (i, child) {
              var html = self.getHTML(child);

              // Add the keys to object children
              if (!Array.isArray(el)) {
                // TODO: use theme
                html = '<div><em>' + i + '</em>: ' + html + '</div>';
              }

              // TODO: use theme
              ret += '<li>' + html + '</li>';
            });

            if (Array.isArray(el)) ret = '<ol>' + ret + '</ol>';else ret = "<ul style='margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;'>" + ret + '</ul>';

            return ret;
          }
          // Boolean
          else if (typeof el === "boolean") {
              return el ? 'true' : 'false';
            }
            // String
            else if (typeof el === "string") {
                return el.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
              }
              // Number
              else {
                  return el;
                }
      },
      setValue: function (val) {
        if (this.value !== val) {
          this.value = val;
          this.refreshValue();
          this.onChange();
        }
      },
      destroy: function () {
        if (this.display_area && this.display_area.parentNode) this.display_area.parentNode.removeChild(this.display_area);
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.switcher && this.switcher.parentNode) this.switcher.parentNode.removeChild(this.switcher);

        this._super();
      }
    });

    JSONEditor.defaults.editors.select = JSONEditor.AbstractEditor.extend({
      setValue: function (value, initial) {
        value = this.typecast(value || '');

        // Sanitize value before setting it
        var sanitized = value;
        if (this.enum_values.indexOf(sanitized) < 0) {
          sanitized = this.enum_values[0];
        }

        if (this.value === sanitized) {
          return;
        }

        this.input.value = this.enum_options[this.enum_values.indexOf(sanitized)];
        if (this.select2) this.select2.select2('val', this.input.value);
        this.value = sanitized;
        this.onChange();
      },
      register: function () {
        this._super();
        if (!this.input) return;
        this.input.setAttribute('name', this.formname);
      },
      unregister: function () {
        this._super();
        if (!this.input) return;
        this.input.removeAttribute('name');
      },
      getNumColumns: function () {
        if (!this.enum_options) return 3;
        var longest_text = this.getTitle().length;
        for (var i = 0; i < this.enum_options.length; i++) {
          longest_text = Math.max(longest_text, this.enum_options[i].length + 4);
        }
        return Math.min(12, Math.max(longest_text / 7, 2));
      },
      typecast: function (value) {
        if (this.schema.type === "boolean") {
          return !!value;
        } else if (this.schema.type === "number") {
          return 1 * value;
        } else if (this.schema.type === "integer") {
          return Math.floor(value * 1);
        } else {
          return "" + value;
        }
      },
      getValue: function () {
        return this.value;
      },
      preBuild: function () {
        var self = this;
        this.input_type = 'select';
        this.enum_options = [];
        this.enum_values = [];
        this.enum_display = [];
        var i;

        // Enum options enumerated
        if (this.schema["enum"]) {
          var display = this.schema.options && this.schema.options.enum_titles || [];

          $each(this.schema["enum"], function (i, option) {
            self.enum_options[i] = "" + option;
            self.enum_display[i] = "" + (display[i] || option);
            self.enum_values[i] = self.typecast(option);
          });

          if (!this.isRequired()) {
            self.enum_display.unshift(' ');
            self.enum_options.unshift('undefined');
            self.enum_values.unshift(undefined);
          }
        }
        // Boolean
        else if (this.schema.type === "boolean") {
            self.enum_display = this.schema.options && this.schema.options.enum_titles || ['true', 'false'];
            self.enum_options = ['1', ''];
            self.enum_values = [true, false];

            if (!this.isRequired()) {
              self.enum_display.unshift(' ');
              self.enum_options.unshift('undefined');
              self.enum_values.unshift(undefined);
            }
          }
          // Dynamic Enum
          else if (this.schema.enumSource) {
              this.enumSource = [];
              this.enum_display = [];
              this.enum_options = [];
              this.enum_values = [];

              // Shortcut declaration for using a single array
              if (!Array.isArray(this.schema.enumSource)) {
                if (this.schema.enumValue) {
                  this.enumSource = [{
                    source: this.schema.enumSource,
                    value: this.schema.enumValue
                  }];
                } else {
                  this.enumSource = [{
                    source: this.schema.enumSource
                  }];
                }
              } else {
                for (i = 0; i < this.schema.enumSource.length; i++) {
                  // Shorthand for watched variable
                  if (typeof this.schema.enumSource[i] === "string") {
                    this.enumSource[i] = {
                      source: this.schema.enumSource[i]
                    };
                  }
                  // Make a copy of the schema
                  else if (!Array.isArray(this.schema.enumSource[i])) {
                      this.enumSource[i] = $extend({}, this.schema.enumSource[i]);
                    } else {
                      this.enumSource[i] = this.schema.enumSource[i];
                    }
                }
              }

              // Now, enumSource is an array of sources
              // Walk through this array and fix up the values
              for (i = 0; i < this.enumSource.length; i++) {
                if (this.enumSource[i].value) {
                  this.enumSource[i].value = this.jsoneditor.compileTemplate(this.enumSource[i].value, this.template_engine);
                }
                if (this.enumSource[i].title) {
                  this.enumSource[i].title = this.jsoneditor.compileTemplate(this.enumSource[i].title, this.template_engine);
                }
                if (this.enumSource[i].filter) {
                  this.enumSource[i].filter = this.jsoneditor.compileTemplate(this.enumSource[i].filter, this.template_engine);
                }
              }
            }
            // Other, not supported
            else {
                throw "'select' editor requires the enum property to be set.";
              }
      },
      build: function () {
        var self = this;
        if (!this.options.compact) this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        if (this.schema.description) this.description = this.theme.getFormInputDescription(this.schema.description);

        if (this.options.compact) this.container.className += ' compact';

        this.input = this.theme.getSelectInput(this.enum_options);
        this.theme.setSelectOptions(this.input, this.enum_options, this.enum_display);

        if (this.schema.readOnly || this.schema.readonly) {
          this.always_disabled = true;
          this.input.disabled = true;
        }

        this.input.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();
          self.onInputChange();
        });

        this.control = this.theme.getFormControl(this.label, this.input, this.description);
        this.container.appendChild(this.control);

        this.value = this.enum_values[0];
      },
      onInputChange: function () {
        var val = this.input.value;

        var new_val;
        // Invalid option, use first option instead
        if (this.enum_options.indexOf(val) === -1) {
          new_val = this.enum_values[0];
        } else {
          new_val = this.enum_values[this.enum_options.indexOf(val)];
        }

        // If valid hasn't changed
        if (new_val === this.value) return;

        // Store new value and propogate change event
        this.value = new_val;
        this.onChange(true);
      },
      setupSelect2: function () {
        // If the Select2 library is loaded use it when we have lots of items
        if (window.jQuery && window.jQuery.fn && window.jQuery.fn.select2 && (this.enum_options.length > 2 || this.enum_options.length && this.enumSource)) {
          var options = $extend({}, JSONEditor.plugins.select2);
          if (this.schema.options && this.schema.options.select2_options) options = $extend(options, this.schema.options.select2_options);
          this.select2 = window.jQuery(this.input).select2(options);
          var self = this;
          this.select2.on('select2-blur', function () {
            self.input.value = self.select2.select2('val');
            self.onInputChange();
          });
          this.select2.on('change', function () {
            self.input.value = self.select2.select2('val');
            self.onInputChange();
          });
        } else {
          this.select2 = null;
        }
      },
      postBuild: function () {
        this._super();
        this.theme.afterInputReady(this.input);
        this.setupSelect2();
      },
      onWatchedFieldChange: function () {
        var self = this,
            vars,
            j;

        // If this editor uses a dynamic select box
        if (this.enumSource) {
          vars = this.getWatchedFieldValues();
          var select_options = [];
          var select_titles = [];

          for (var i = 0; i < this.enumSource.length; i++) {
            // Constant values
            if (Array.isArray(this.enumSource[i])) {
              select_options = select_options.concat(this.enumSource[i]);
              select_titles = select_titles.concat(this.enumSource[i]);
            } else {
              var items = [];
              // Static list of items
              if (Array.isArray(this.enumSource[i].source)) {
                items = this.enumSource[i].source;
                // A watched field
              } else {
                items = vars[this.enumSource[i].source];
              }

              if (items) {
                // Only use a predefined part of the array
                if (this.enumSource[i].slice) {
                  items = Array.prototype.slice.apply(items, this.enumSource[i].slice);
                }
                // Filter the items
                if (this.enumSource[i].filter) {
                  var new_items = [];
                  for (j = 0; j < items.length; j++) {
                    if (this.enumSource[i].filter({ i: j, item: items[j], watched: vars })) new_items.push(items[j]);
                  }
                  items = new_items;
                }

                var item_titles = [];
                var item_values = [];
                for (j = 0; j < items.length; j++) {
                  var item = items[j];

                  // Rendered value
                  if (this.enumSource[i].value) {
                    item_values[j] = this.enumSource[i].value({
                      i: j,
                      item: item
                    });
                  }
                  // Use value directly
                  else {
                      item_values[j] = items[j];
                    }

                  // Rendered title
                  if (this.enumSource[i].title) {
                    item_titles[j] = this.enumSource[i].title({
                      i: j,
                      item: item
                    });
                  }
                  // Use value as the title also
                  else {
                      item_titles[j] = item_values[j];
                    }
                }

                // TODO: sort

                select_options = select_options.concat(item_values);
                select_titles = select_titles.concat(item_titles);
              }
            }
          }

          var prev_value = this.value;

          this.theme.setSelectOptions(this.input, select_options, select_titles);
          this.enum_options = select_options;
          this.enum_display = select_titles;
          this.enum_values = select_options;

          if (this.select2) {
            this.select2.select2('destroy');
          }

          // If the previous value is still in the new select options, stick with it
          if (select_options.indexOf(prev_value) !== -1) {
            this.input.value = prev_value;
            this.value = prev_value;
          }
          // Otherwise, set the value to the first select option
          else {
              this.input.value = select_options[0];
              this.value = select_options[0] || "";
              if (this.parent) this.parent.onChildEditorChange(this);else this.jsoneditor.onChange();
              this.jsoneditor.notifyWatchers(this.path);
            }

          this.setupSelect2();
        }

        this._super();
      },
      enable: function () {
        if (!this.always_disabled) {
          this.input.disabled = false;
          if (this.select2) this.select2.select2("enable", true);
        }
        this._super();
      },
      disable: function () {
        this.input.disabled = true;
        if (this.select2) this.select2.select2("enable", false);
        this._super();
      },
      destroy: function () {
        if (this.label && this.label.parentNode) this.label.parentNode.removeChild(this.label);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        if (this.select2) {
          this.select2.select2('destroy');
          this.select2 = null;
        }

        this._super();
      }
    });

    JSONEditor.defaults.editors.selectize = JSONEditor.AbstractEditor.extend({
      setValue: function (value, initial) {
        value = this.typecast(value || '');

        // Sanitize value before setting it
        var sanitized = value;
        if (this.enum_values.indexOf(sanitized) < 0) {
          sanitized = this.enum_values[0];
        }

        if (this.value === sanitized) {
          return;
        }

        this.input.value = this.enum_options[this.enum_values.indexOf(sanitized)];

        if (this.selectize) {
          this.selectize[0].selectize.addItem(sanitized);
        }

        this.value = sanitized;
        this.onChange();
      },
      register: function () {
        this._super();
        if (!this.input) return;
        this.input.setAttribute('name', this.formname);
      },
      unregister: function () {
        this._super();
        if (!this.input) return;
        this.input.removeAttribute('name');
      },
      getNumColumns: function () {
        if (!this.enum_options) return 3;
        var longest_text = this.getTitle().length;
        for (var i = 0; i < this.enum_options.length; i++) {
          longest_text = Math.max(longest_text, this.enum_options[i].length + 4);
        }
        return Math.min(12, Math.max(longest_text / 7, 2));
      },
      typecast: function (value) {
        if (this.schema.type === "boolean") {
          return !!value;
        } else if (this.schema.type === "number") {
          return 1 * value;
        } else if (this.schema.type === "integer") {
          return Math.floor(value * 1);
        } else {
          return "" + value;
        }
      },
      getValue: function () {
        return this.value;
      },
      preBuild: function () {
        var self = this;
        this.input_type = 'select';
        this.enum_options = [];
        this.enum_values = [];
        this.enum_display = [];
        var i;

        // Enum options enumerated
        if (this.schema.enum) {
          var display = this.schema.options && this.schema.options.enum_titles || [];

          $each(this.schema.enum, function (i, option) {
            self.enum_options[i] = "" + option;
            self.enum_display[i] = "" + (display[i] || option);
            self.enum_values[i] = self.typecast(option);
          });
        }
        // Boolean
        else if (this.schema.type === "boolean") {
            self.enum_display = this.schema.options && this.schema.options.enum_titles || ['true', 'false'];
            self.enum_options = ['1', '0'];
            self.enum_values = [true, false];
          }
          // Dynamic Enum
          else if (this.schema.enumSource) {
              this.enumSource = [];
              this.enum_display = [];
              this.enum_options = [];
              this.enum_values = [];

              // Shortcut declaration for using a single array
              if (!Array.isArray(this.schema.enumSource)) {
                if (this.schema.enumValue) {
                  this.enumSource = [{
                    source: this.schema.enumSource,
                    value: this.schema.enumValue
                  }];
                } else {
                  this.enumSource = [{
                    source: this.schema.enumSource
                  }];
                }
              } else {
                for (i = 0; i < this.schema.enumSource.length; i++) {
                  // Shorthand for watched variable
                  if (typeof this.schema.enumSource[i] === "string") {
                    this.enumSource[i] = {
                      source: this.schema.enumSource[i]
                    };
                  }
                  // Make a copy of the schema
                  else if (!Array.isArray(this.schema.enumSource[i])) {
                      this.enumSource[i] = $extend({}, this.schema.enumSource[i]);
                    } else {
                      this.enumSource[i] = this.schema.enumSource[i];
                    }
                }
              }

              // Now, enumSource is an array of sources
              // Walk through this array and fix up the values
              for (i = 0; i < this.enumSource.length; i++) {
                if (this.enumSource[i].value) {
                  this.enumSource[i].value = this.jsoneditor.compileTemplate(this.enumSource[i].value, this.template_engine);
                }
                if (this.enumSource[i].title) {
                  this.enumSource[i].title = this.jsoneditor.compileTemplate(this.enumSource[i].title, this.template_engine);
                }
                if (this.enumSource[i].filter) {
                  this.enumSource[i].filter = this.jsoneditor.compileTemplate(this.enumSource[i].filter, this.template_engine);
                }
              }
            }
            // Other, not supported
            else {
                throw "'select' editor requires the enum property to be set.";
              }
      },
      build: function () {
        var self = this;
        if (!this.options.compact) this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        if (this.schema.description) this.description = this.theme.getFormInputDescription(this.schema.description);

        if (this.options.compact) this.container.className += ' compact';

        this.input = this.theme.getSelectInput(this.enum_options);
        this.theme.setSelectOptions(this.input, this.enum_options, this.enum_display);

        if (this.schema.readOnly || this.schema.readonly) {
          this.always_disabled = true;
          this.input.disabled = true;
        }

        this.input.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();
          self.onInputChange();
        });

        this.control = this.theme.getFormControl(this.label, this.input, this.description);
        this.container.appendChild(this.control);

        this.value = this.enum_values[0];
      },
      onInputChange: function () {
        var val = this.input.value;

        var sanitized = val;
        if (this.enum_options.indexOf(val) === -1) {
          sanitized = this.enum_options[0];
        }

        this.value = this.enum_values[this.enum_options.indexOf(val)];
        this.onChange(true);
      },
      setupSelectize: function () {
        // If the Selectize library is loaded use it when we have lots of items
        var self = this;
        if (window.jQuery && window.jQuery.fn && window.jQuery.fn.selectize && (this.enum_options.length >= 2 || this.enum_options.length && this.enumSource)) {
          var options = $extend({}, JSONEditor.plugins.selectize);
          if (this.schema.options && this.schema.options.selectize_options) options = $extend(options, this.schema.options.selectize_options);
          this.selectize = window.jQuery(this.input).selectize($extend(options, {
            create: true,
            onChange: function () {
              self.onInputChange();
            }
          }));
        } else {
          this.selectize = null;
        }
      },
      postBuild: function () {
        this._super();
        this.theme.afterInputReady(this.input);
        this.setupSelectize();
      },
      onWatchedFieldChange: function () {
        var self = this,
            vars,
            j;

        // If this editor uses a dynamic select box
        if (this.enumSource) {
          vars = this.getWatchedFieldValues();
          var select_options = [];
          var select_titles = [];

          for (var i = 0; i < this.enumSource.length; i++) {
            // Constant values
            if (Array.isArray(this.enumSource[i])) {
              select_options = select_options.concat(this.enumSource[i]);
              select_titles = select_titles.concat(this.enumSource[i]);
            }
            // A watched field
            else if (vars[this.enumSource[i].source]) {
                var items = vars[this.enumSource[i].source];

                // Only use a predefined part of the array
                if (this.enumSource[i].slice) {
                  items = Array.prototype.slice.apply(items, this.enumSource[i].slice);
                }
                // Filter the items
                if (this.enumSource[i].filter) {
                  var new_items = [];
                  for (j = 0; j < items.length; j++) {
                    if (this.enumSource[i].filter({ i: j, item: items[j] })) new_items.push(items[j]);
                  }
                  items = new_items;
                }

                var item_titles = [];
                var item_values = [];
                for (j = 0; j < items.length; j++) {
                  var item = items[j];

                  // Rendered value
                  if (this.enumSource[i].value) {
                    item_values[j] = this.enumSource[i].value({
                      i: j,
                      item: item
                    });
                  }
                  // Use value directly
                  else {
                      item_values[j] = items[j];
                    }

                  // Rendered title
                  if (this.enumSource[i].title) {
                    item_titles[j] = this.enumSource[i].title({
                      i: j,
                      item: item
                    });
                  }
                  // Use value as the title also
                  else {
                      item_titles[j] = item_values[j];
                    }
                }

                // TODO: sort

                select_options = select_options.concat(item_values);
                select_titles = select_titles.concat(item_titles);
              }
          }

          var prev_value = this.value;

          this.theme.setSelectOptions(this.input, select_options, select_titles);
          this.enum_options = select_options;
          this.enum_display = select_titles;
          this.enum_values = select_options;

          // If the previous value is still in the new select options, stick with it
          if (select_options.indexOf(prev_value) !== -1) {
            this.input.value = prev_value;
            this.value = prev_value;
          }

          // Otherwise, set the value to the first select option
          else {
              this.input.value = select_options[0];
              this.value = select_options[0] || "";
              if (this.parent) this.parent.onChildEditorChange(this);else this.jsoneditor.onChange();
              this.jsoneditor.notifyWatchers(this.path);
            }

          if (this.selectize) {
            // Update the Selectize options
            this.updateSelectizeOptions(select_options);
          } else {
            this.setupSelectize();
          }

          this._super();
        }
      },
      updateSelectizeOptions: function (select_options) {
        var selectized = this.selectize[0].selectize,
            self = this;

        selectized.off();
        selectized.clearOptions();
        for (var n in select_options) {
          selectized.addOption({ value: select_options[n], text: select_options[n] });
        }
        selectized.addItem(this.value);
        selectized.on('change', function () {
          self.onInputChange();
        });
      },
      enable: function () {
        if (!this.always_disabled) {
          this.input.disabled = false;
          if (this.selectize) {
            this.selectize[0].selectize.unlock();
          }
        }
        this._super();
      },
      disable: function () {
        this.input.disabled = true;
        if (this.selectize) {
          this.selectize[0].selectize.lock();
        }
        this._super();
      },
      destroy: function () {
        if (this.label && this.label.parentNode) this.label.parentNode.removeChild(this.label);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        if (this.selectize) {
          this.selectize[0].selectize.destroy();
          this.selectize = null;
        }
        this._super();
      }
    });

    JSONEditor.defaults.editors.multiselect = JSONEditor.AbstractEditor.extend({
      preBuild: function () {
        this._super();
        var i;

        this.select_options = {};
        this.select_values = {};

        var items_schema = this.jsoneditor.expandRefs(this.schema.items || {});

        var e = items_schema["enum"] || [];
        var t = items_schema.options ? items_schema.options.enum_titles || [] : [];
        this.option_keys = [];
        this.option_titles = [];
        for (i = 0; i < e.length; i++) {
          // If the sanitized value is different from the enum value, don't include it
          if (this.sanitize(e[i]) !== e[i]) continue;

          this.option_keys.push(e[i] + "");
          this.option_titles.push((t[i] || e[i]) + "");
          this.select_values[e[i] + ""] = e[i];
        }
      },
      build: function () {
        var self = this,
            i;
        if (!this.options.compact) this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
        if (this.schema.description) this.description = this.theme.getFormInputDescription(this.schema.description);

        if (!this.schema.format && this.option_keys.length < 8 || this.schema.format === "checkbox") {
          this.input_type = 'checkboxes';

          this.inputs = {};
          this.controls = {};
          for (i = 0; i < this.option_keys.length; i++) {
            this.inputs[this.option_keys[i]] = this.theme.getCheckbox();
            this.select_options[this.option_keys[i]] = this.inputs[this.option_keys[i]];
            var label = this.theme.getCheckboxLabel(this.option_titles[i]);
            this.controls[this.option_keys[i]] = this.theme.getFormControl(label, this.inputs[this.option_keys[i]]);
          }

          this.control = this.theme.getMultiCheckboxHolder(this.controls, this.label, this.description);
        } else {
          this.input_type = 'select';
          this.input = this.theme.getSelectInput(this.option_keys);
          this.theme.setSelectOptions(this.input, this.option_keys, this.option_titles);
          this.input.multiple = true;
          this.input.size = Math.min(10, this.option_keys.length);

          for (i = 0; i < this.option_keys.length; i++) {
            this.select_options[this.option_keys[i]] = this.input.children[i];
          }

          if (this.schema.readOnly || this.schema.readonly) {
            this.always_disabled = true;
            this.input.disabled = true;
          }

          this.control = this.theme.getFormControl(this.label, this.input, this.description);
        }

        this.container.appendChild(this.control);
        this.control.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();

          var new_value = [];
          for (i = 0; i < self.option_keys.length; i++) {
            if (self.select_options[self.option_keys[i]].selected || self.select_options[self.option_keys[i]].checked) new_value.push(self.select_values[self.option_keys[i]]);
          }

          self.updateValue(new_value);
          self.onChange(true);
        });
      },
      setValue: function (value, initial) {
        var i;
        value = value || [];
        if (typeof value !== "object") value = [value];else if (!Array.isArray(value)) value = [];

        // Make sure we are dealing with an array of strings so we can check for strict equality
        for (i = 0; i < value.length; i++) {
          if (typeof value[i] !== "string") value[i] += "";
        }

        // Update selected status of options
        for (i in this.select_options) {
          if (!this.select_options.hasOwnProperty(i)) continue;

          this.select_options[i][this.input_type === "select" ? "selected" : "checked"] = value.indexOf(i) !== -1;
        }

        this.updateValue(value);
        this.onChange();
      },
      setupSelect2: function () {
        if (window.jQuery && window.jQuery.fn && window.jQuery.fn.select2) {
          var options = window.jQuery.extend({}, JSONEditor.plugins.select2);
          if (this.schema.options && this.schema.options.select2_options) options = $extend(options, this.schema.options.select2_options);
          this.select2 = window.jQuery(this.input).select2(options);
          var self = this;
          this.select2.on('select2-blur', function () {
            var val = self.select2.select2('val');
            self.value = val;
            self.onChange(true);
          });
        } else {
          this.select2 = null;
        }
      },
      onInputChange: function () {
        this.value = this.input.value;
        this.onChange(true);
      },
      postBuild: function () {
        this._super();
        this.setupSelect2();
      },
      register: function () {
        this._super();
        if (!this.input) return;
        this.input.setAttribute('name', this.formname);
      },
      unregister: function () {
        this._super();
        if (!this.input) return;
        this.input.removeAttribute('name');
      },
      getNumColumns: function () {
        var longest_text = this.getTitle().length;
        for (var i in this.select_values) {
          if (!this.select_values.hasOwnProperty(i)) continue;
          longest_text = Math.max(longest_text, (this.select_values[i] + "").length + 4);
        }

        return Math.min(12, Math.max(longest_text / 7, 2));
      },
      updateValue: function (value) {
        var changed = false;
        var new_value = [];
        for (var i = 0; i < value.length; i++) {
          if (!this.select_options[value[i] + ""]) {
            changed = true;
            continue;
          }
          var sanitized = this.sanitize(this.select_values[value[i]]);
          new_value.push(sanitized);
          if (sanitized !== value[i]) changed = true;
        }
        this.value = new_value;
        if (this.select2) this.select2.select2('val', this.value);
        return changed;
      },
      sanitize: function (value) {
        if (this.schema.items.type === "number") {
          return 1 * value;
        } else if (this.schema.items.type === "integer") {
          return Math.floor(value * 1);
        } else {
          return "" + value;
        }
      },
      enable: function () {
        if (!this.always_disabled) {
          if (this.input) {
            this.input.disabled = false;
          } else if (this.inputs) {
            for (var i in this.inputs) {
              if (!this.inputs.hasOwnProperty(i)) continue;
              this.inputs[i].disabled = false;
            }
          }
          if (this.select2) this.select2.select2("enable", true);
        }
        this._super();
      },
      disable: function () {
        if (this.input) {
          this.input.disabled = true;
        } else if (this.inputs) {
          for (var i in this.inputs) {
            if (!this.inputs.hasOwnProperty(i)) continue;
            this.inputs[i].disabled = true;
          }
        }
        if (this.select2) this.select2.select2("enable", false);
        this._super();
      },
      destroy: function () {
        if (this.select2) {
          this.select2.select2('destroy');
          this.select2 = null;
        }
        this._super();
      }
    });

    JSONEditor.defaults.editors.base64 = JSONEditor.AbstractEditor.extend({
      getNumColumns: function () {
        return 4;
      },
      build: function () {
        var self = this;
        this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());

        // Input that holds the base64 string
        this.input = this.theme.getFormInputField('hidden');
        this.container.appendChild(this.input);

        // Don't show uploader if this is readonly
        if (!this.schema.readOnly && !this.schema.readonly) {
          if (!window.FileReader) throw "FileReader required for base64 editor";

          // File uploader
          this.uploader = this.theme.getFormInputField('file');

          this.uploader.addEventListener('change', function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (this.files && this.files.length) {
              var fr = new FileReader();
              fr.onload = function (evt) {
                self.value = evt.target.result;
                self.refreshPreview();
                self.onChange(true);
                fr = null;
              };
              fr.readAsDataURL(this.files[0]);
            }
          });
        }

        this.preview = this.theme.getFormInputDescription(this.schema.description);
        this.container.appendChild(this.preview);

        this.control = this.theme.getFormControl(this.label, this.uploader || this.input, this.preview);
        this.container.appendChild(this.control);
      },
      refreshPreview: function () {
        if (this.last_preview === this.value) return;
        this.last_preview = this.value;

        this.preview.innerHTML = '';

        if (!this.value) return;

        var mime = this.value.match(/^data:([^;,]+)[;,]/);
        if (mime) mime = mime[1];

        if (!mime) {
          this.preview.innerHTML = '<em>Invalid data URI</em>';
        } else {
          this.preview.innerHTML = '<strong>Type:</strong> ' + mime + ', <strong>Size:</strong> ' + Math.floor((this.value.length - this.value.split(',')[0].length - 1) / 1.33333) + ' bytes';
          if (mime.substr(0, 5) === "image") {
            this.preview.innerHTML += '<br>';
            var img = document.createElement('img');
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100px';
            img.src = this.value;
            this.preview.appendChild(img);
          }
        }
      },
      enable: function () {
        if (this.uploader) this.uploader.disabled = false;
        this._super();
      },
      disable: function () {
        if (this.uploader) this.uploader.disabled = true;
        this._super();
      },
      setValue: function (val) {
        if (this.value !== val) {
          this.value = val;
          this.input.value = this.value;
          this.refreshPreview();
          this.onChange();
        }
      },
      destroy: function () {
        if (this.preview && this.preview.parentNode) this.preview.parentNode.removeChild(this.preview);
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        if (this.uploader && this.uploader.parentNode) this.uploader.parentNode.removeChild(this.uploader);

        this._super();
      }
    });

    JSONEditor.defaults.editors.upload = JSONEditor.AbstractEditor.extend({
      getNumColumns: function () {
        return 4;
      },
      build: function () {
        var self = this;
        this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());

        // Input that holds the base64 string
        this.input = this.theme.getFormInputField('hidden');
        this.container.appendChild(this.input);

        // Don't show uploader if this is readonly
        if (!this.schema.readOnly && !this.schema.readonly) {

          if (!this.jsoneditor.options.upload) throw "Upload handler required for upload editor";

          // File uploader
          this.uploader = this.theme.getFormInputField('file');

          this.uploader.addEventListener('change', function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (this.files && this.files.length) {
              var fr = new FileReader();
              fr.onload = function (evt) {
                self.preview_value = evt.target.result;
                self.refreshPreview();
                self.onChange(true);
                fr = null;
              };
              fr.readAsDataURL(this.files[0]);
            }
          });
        }

        var description = this.schema.description;
        if (!description) description = '';

        this.preview = this.theme.getFormInputDescription(description);
        this.container.appendChild(this.preview);

        this.control = this.theme.getFormControl(this.label, this.uploader || this.input, this.preview);
        this.container.appendChild(this.control);
      },
      refreshPreview: function () {
        if (this.last_preview === this.preview_value) return;
        this.last_preview = this.preview_value;

        this.preview.innerHTML = '';

        if (!this.preview_value) return;

        var self = this;

        var mime = this.preview_value.match(/^data:([^;,]+)[;,]/);
        if (mime) mime = mime[1];
        if (!mime) mime = 'unknown';

        var file = this.uploader.files[0];

        this.preview.innerHTML = '<strong>Type:</strong> ' + mime + ', <strong>Size:</strong> ' + file.size + ' bytes';
        if (mime.substr(0, 5) === "image") {
          this.preview.innerHTML += '<br>';
          var img = document.createElement('img');
          img.style.maxWidth = '100%';
          img.style.maxHeight = '100px';
          img.src = this.preview_value;
          this.preview.appendChild(img);
        }

        this.preview.innerHTML += '<br>';
        var uploadButton = this.getButton('Upload', 'upload', 'Upload');
        this.preview.appendChild(uploadButton);
        uploadButton.addEventListener('click', function (event) {
          event.preventDefault();

          uploadButton.setAttribute("disabled", "disabled");
          self.theme.removeInputError(self.uploader);

          if (self.theme.getProgressBar) {
            self.progressBar = self.theme.getProgressBar();
            self.preview.appendChild(self.progressBar);
          }

          self.jsoneditor.options.upload(self.path, file, {
            success: function (url) {
              self.setValue(url);

              if (self.parent) self.parent.onChildEditorChange(self);else self.jsoneditor.onChange();

              if (self.progressBar) self.preview.removeChild(self.progressBar);
              uploadButton.removeAttribute("disabled");
            },
            failure: function (error) {
              self.theme.addInputError(self.uploader, error);
              if (self.progressBar) self.preview.removeChild(self.progressBar);
              uploadButton.removeAttribute("disabled");
            },
            updateProgress: function (progress) {
              if (self.progressBar) {
                if (progress) self.theme.updateProgressBar(self.progressBar, progress);else self.theme.updateProgressBarUnknown(self.progressBar);
              }
            }
          });
        });
      },
      enable: function () {
        if (this.uploader) this.uploader.disabled = false;
        this._super();
      },
      disable: function () {
        if (this.uploader) this.uploader.disabled = true;
        this._super();
      },
      setValue: function (val) {
        if (this.value !== val) {
          this.value = val;
          this.input.value = this.value;
          this.onChange();
        }
      },
      destroy: function () {
        if (this.preview && this.preview.parentNode) this.preview.parentNode.removeChild(this.preview);
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        if (this.uploader && this.uploader.parentNode) this.uploader.parentNode.removeChild(this.uploader);

        this._super();
      }
    });

    JSONEditor.defaults.editors.checkbox = JSONEditor.AbstractEditor.extend({
      setValue: function (value, initial) {
        this.value = !!value;
        this.input.checked = this.value;
        this.onChange();
      },
      register: function () {
        this._super();
        if (!this.input) return;
        this.input.setAttribute('name', this.formname);
      },
      unregister: function () {
        this._super();
        if (!this.input) return;
        this.input.removeAttribute('name');
      },
      getNumColumns: function () {
        return Math.min(12, Math.max(this.getTitle().length / 7, 2));
      },
      build: function () {
        var self = this;
        if (!this.options.compact) {
          this.label = this.header = this.theme.getCheckboxLabel(this.getTitle());
        }
        if (this.schema.description) this.description = this.theme.getFormInputDescription(this.schema.description);
        if (this.options.compact) this.container.className += ' compact';

        this.input = this.theme.getCheckbox();
        this.control = this.theme.getFormControl(this.label, this.input, this.description);

        if (this.schema.readOnly || this.schema.readonly) {
          this.always_disabled = true;
          this.input.disabled = true;
        }

        this.input.addEventListener('change', function (e) {
          e.preventDefault();
          e.stopPropagation();
          self.value = this.checked;
          self.onChange(true);
        });

        this.container.appendChild(this.control);
      },
      enable: function () {
        if (!this.always_disabled) {
          this.input.disabled = false;
        }
        this._super();
      },
      disable: function () {
        this.input.disabled = true;
        this._super();
      },
      destroy: function () {
        if (this.label && this.label.parentNode) this.label.parentNode.removeChild(this.label);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);
        this._super();
      }
    });

    JSONEditor.defaults.editors.arraySelectize = JSONEditor.AbstractEditor.extend({
      build: function () {
        this.title = this.theme.getFormInputLabel(this.getTitle());

        this.title_controls = this.theme.getHeaderButtonHolder();
        this.title.appendChild(this.title_controls);
        this.error_holder = document.createElement('div');

        if (this.schema.description) {
          this.description = this.theme.getDescription(this.schema.description);
        }

        this.input = document.createElement('select');
        this.input.setAttribute('multiple', 'multiple');

        var group = this.theme.getFormControl(this.title, this.input, this.description);

        this.container.appendChild(group);
        this.container.appendChild(this.error_holder);

        window.jQuery(this.input).selectize({
          delimiter: false,
          createOnBlur: true,
          create: true
        });
      },
      postBuild: function () {
        var self = this;
        this.input.selectize.on('change', function (event) {
          self.refreshValue();
          self.onChange(true);
        });
      },
      destroy: function () {
        this.empty(true);
        if (this.title && this.title.parentNode) this.title.parentNode.removeChild(this.title);
        if (this.description && this.description.parentNode) this.description.parentNode.removeChild(this.description);
        if (this.input && this.input.parentNode) this.input.parentNode.removeChild(this.input);

        this._super();
      },
      empty: function (hard) {},
      setValue: function (value, initial) {
        var self = this;
        // Update the array's value, adding/removing rows when necessary
        value = value || [];
        if (!Array.isArray(value)) value = [value];

        this.input.selectize.clearOptions();
        this.input.selectize.clear(true);

        value.forEach(function (item) {
          self.input.selectize.addOption({ text: item, value: item });
        });
        this.input.selectize.setValue(value);

        this.refreshValue(initial);
      },
      refreshValue: function (force) {
        this.value = this.input.selectize.getValue();
      },
      showValidationErrors: function (errors) {
        var self = this;

        // Get all the errors that pertain to this editor
        var my_errors = [];
        var other_errors = [];
        $each(errors, function (i, error) {
          if (error.path === self.path) {
            my_errors.push(error);
          } else {
            other_errors.push(error);
          }
        });

        // Show errors for this editor
        if (this.error_holder) {

          if (my_errors.length) {
            var message = [];
            this.error_holder.innerHTML = '';
            this.error_holder.style.display = '';
            $each(my_errors, function (i, error) {
              self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
            });
          }
          // Hide error area
          else {
              this.error_holder.style.display = 'none';
            }
        }
      }
    });

    var matchKey = function () {
      var elem = document.documentElement;

      if (elem.matches) return 'matches';else if (elem.webkitMatchesSelector) return 'webkitMatchesSelector';else if (elem.mozMatchesSelector) return 'mozMatchesSelector';else if (elem.msMatchesSelector) return 'msMatchesSelector';else if (elem.oMatchesSelector) return 'oMatchesSelector';
    }();

    JSONEditor.AbstractTheme = Class.extend({
      getContainer: function () {
        return document.createElement('div');
      },
      getFloatRightLinkHolder: function () {
        var el = document.createElement('div');
        el.style = el.style || {};
        el.style.cssFloat = 'right';
        el.style.marginLeft = '10px';
        return el;
      },
      getModal: function () {
        var el = document.createElement('div');
        el.style.backgroundColor = 'white';
        el.style.border = '1px solid black';
        el.style.boxShadow = '3px 3px black';
        el.style.position = 'absolute';
        el.style.zIndex = '10';
        el.style.display = 'none';
        return el;
      },
      getGridContainer: function () {
        var el = document.createElement('div');
        return el;
      },
      getGridRow: function () {
        var el = document.createElement('div');
        el.className = 'row';
        return el;
      },
      getGridColumn: function () {
        var el = document.createElement('div');
        return el;
      },
      setGridColumnSize: function (el, size) {},
      getLink: function (text) {
        var el = document.createElement('a');
        el.setAttribute('href', '#');
        el.appendChild(document.createTextNode(text));
        return el;
      },
      disableHeader: function (header) {
        header.style.color = '#ccc';
      },
      disableLabel: function (label) {
        label.style.color = '#ccc';
      },
      enableHeader: function (header) {
        header.style.color = '';
      },
      enableLabel: function (label) {
        label.style.color = '';
      },
      getFormInputLabel: function (text) {
        var el = document.createElement('label');
        el.appendChild(document.createTextNode(text));
        return el;
      },
      getCheckboxLabel: function (text) {
        var el = this.getFormInputLabel(text);
        el.style.fontWeight = 'normal';
        return el;
      },
      getHeader: function (text) {
        var el = document.createElement('h3');
        if (typeof text === "string") {
          el.textContent = text;
        } else {
          el.appendChild(text);
        }

        return el;
      },
      getCheckbox: function () {
        var el = this.getFormInputField('checkbox');
        el.style.display = 'inline-block';
        el.style.width = 'auto';
        return el;
      },
      getMultiCheckboxHolder: function (controls, label, description) {
        var el = document.createElement('div');

        if (label) {
          label.style.display = 'block';
          el.appendChild(label);
        }

        for (var i in controls) {
          if (!controls.hasOwnProperty(i)) continue;
          controls[i].style.display = 'inline-block';
          controls[i].style.marginRight = '20px';
          el.appendChild(controls[i]);
        }

        if (description) el.appendChild(description);

        return el;
      },
      getSelectInput: function (options) {
        var select = document.createElement('select');
        if (options) this.setSelectOptions(select, options);
        return select;
      },
      getSwitcher: function (options) {
        var switcher = this.getSelectInput(options);
        switcher.style.backgroundColor = 'transparent';
        switcher.style.display = 'inline-block';
        switcher.style.fontStyle = 'italic';
        switcher.style.fontWeight = 'normal';
        switcher.style.height = 'auto';
        switcher.style.marginBottom = 0;
        switcher.style.marginLeft = '5px';
        switcher.style.padding = '0 0 0 3px';
        switcher.style.width = 'auto';
        return switcher;
      },
      getSwitcherOptions: function (switcher) {
        return switcher.getElementsByTagName('option');
      },
      setSwitcherOptions: function (switcher, options, titles) {
        this.setSelectOptions(switcher, options, titles);
      },
      setSelectOptions: function (select, options, titles) {
        titles = titles || [];
        select.innerHTML = '';
        for (var i = 0; i < options.length; i++) {
          var option = document.createElement('option');
          option.setAttribute('value', options[i]);
          option.textContent = titles[i] || options[i];
          select.appendChild(option);
        }
      },
      getTextareaInput: function () {
        var el = document.createElement('textarea');
        el.style = el.style || {};
        el.style.width = '100%';
        el.style.height = '300px';
        el.style.boxSizing = 'border-box';
        return el;
      },
      getRangeInput: function (min, max, step) {
        var el = this.getFormInputField('range');
        el.setAttribute('min', min);
        el.setAttribute('max', max);
        el.setAttribute('step', step);
        return el;
      },
      getFormInputField: function (type) {
        var el = document.createElement('input');
        el.setAttribute('type', type);
        return el;
      },
      afterInputReady: function (input) {},
      getFormControl: function (label, input, description) {
        var el = document.createElement('div');
        el.className = 'form-control';
        if (label) el.appendChild(label);
        if (input.type === 'checkbox') {
          label.insertBefore(input, label.firstChild);
        } else {
          el.appendChild(input);
        }

        if (description) el.appendChild(description);
        return el;
      },
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.style = el.style || {};
        el.style.paddingLeft = '10px';
        el.style.marginLeft = '10px';
        el.style.borderLeft = '1px solid #ccc';
        return el;
      },
      getChildEditorHolder: function () {
        return document.createElement('div');
      },
      getDescription: function (text) {
        var el = document.createElement('p');
        el.innerHTML = text;
        return el;
      },
      getCheckboxDescription: function (text) {
        return this.getDescription(text);
      },
      getFormInputDescription: function (text) {
        return this.getDescription(text);
      },
      getHeaderButtonHolder: function () {
        return this.getButtonHolder();
      },
      getButtonHolder: function () {
        return document.createElement('div');
      },
      getButton: function (text, icon, title) {
        var el = document.createElement('button');
        el.type = 'button';
        this.setButtonText(el, text, icon, title);
        return el;
      },
      setButtonText: function (button, text, icon, title) {
        button.innerHTML = '';
        if (icon) {
          button.appendChild(icon);
          button.innerHTML += ' ';
        }
        button.appendChild(document.createTextNode(text));
        if (title) button.setAttribute('title', title);
      },
      getTable: function () {
        return document.createElement('table');
      },
      getTableRow: function () {
        return document.createElement('tr');
      },
      getTableHead: function () {
        return document.createElement('thead');
      },
      getTableBody: function () {
        return document.createElement('tbody');
      },
      getTableHeaderCell: function (text) {
        var el = document.createElement('th');
        el.textContent = text;
        return el;
      },
      getTableCell: function () {
        var el = document.createElement('td');
        return el;
      },
      getErrorMessage: function (text) {
        var el = document.createElement('p');
        el.style = el.style || {};
        el.style.color = 'red';
        el.appendChild(document.createTextNode(text));
        return el;
      },
      addInputError: function (input, text) {},
      removeInputError: function (input) {},
      addTableRowError: function (row) {},
      removeTableRowError: function (row) {},
      getTabHolder: function () {
        var el = document.createElement('div');
        el.innerHTML = "<div style='float: left; width: 130px;' class='tabs'></div><div class='content' style='margin-left: 130px;'></div><div style='clear:both;'></div>";
        return el;
      },
      applyStyles: function (el, styles) {
        el.style = el.style || {};
        for (var i in styles) {
          if (!styles.hasOwnProperty(i)) continue;
          el.style[i] = styles[i];
        }
      },
      closest: function (elem, selector) {
        while (elem && elem !== document) {
          if (elem[matchKey]) {
            if (elem[matchKey](selector)) {
              return elem;
            } else {
              elem = elem.parentNode;
            }
          } else {
            return false;
          }
        }
        return false;
      },
      getTab: function (span) {
        var el = document.createElement('div');
        el.appendChild(span);
        el.style = el.style || {};
        this.applyStyles(el, {
          border: '1px solid #ccc',
          borderWidth: '1px 0 1px 1px',
          textAlign: 'center',
          lineHeight: '30px',
          borderRadius: '5px',
          borderBottomRightRadius: 0,
          borderTopRightRadius: 0,
          fontWeight: 'bold',
          cursor: 'pointer'
        });
        return el;
      },
      getTabContentHolder: function (tab_holder) {
        return tab_holder.children[1];
      },
      getTabContent: function () {
        return this.getIndentedPanel();
      },
      markTabActive: function (tab) {
        this.applyStyles(tab, {
          opacity: 1,
          background: 'white'
        });
      },
      markTabInactive: function (tab) {
        this.applyStyles(tab, {
          opacity: 0.5,
          background: ''
        });
      },
      addTab: function (holder, tab) {
        holder.children[0].appendChild(tab);
      },
      getBlockLink: function () {
        var link = document.createElement('a');
        link.style.display = 'block';
        return link;
      },
      getBlockLinkHolder: function () {
        var el = document.createElement('div');
        return el;
      },
      getLinksHolder: function () {
        var el = document.createElement('div');
        return el;
      },
      createMediaLink: function (holder, link, media) {
        holder.appendChild(link);
        media.style.width = '100%';
        holder.appendChild(media);
      },
      createImageLink: function (holder, link, image) {
        holder.appendChild(link);
        link.appendChild(image);
      }
    });

    JSONEditor.defaults.themes.bootstrap2 = JSONEditor.AbstractTheme.extend({
      getRangeInput: function (min, max, step) {
        // TODO: use bootstrap slider
        return this._super(min, max, step);
      },
      getGridContainer: function () {
        var el = document.createElement('div');
        el.className = 'container-fluid';
        return el;
      },
      getGridRow: function () {
        var el = document.createElement('div');
        el.className = 'row-fluid';
        return el;
      },
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.display = 'inline-block';
        el.style.fontWeight = 'bold';
        return el;
      },
      setGridColumnSize: function (el, size) {
        el.className = 'span' + size;
      },
      getSelectInput: function (options) {
        var input = this._super(options);
        input.style.width = 'auto';
        input.style.maxWidth = '98%';
        return input;
      },
      getFormInputField: function (type) {
        var el = this._super(type);
        el.style.width = '98%';
        return el;
      },
      afterInputReady: function (input) {
        if (input.controlgroup) return;
        input.controlgroup = this.closest(input, '.control-group');
        input.controls = this.closest(input, '.controls');
        if (this.closest(input, '.compact')) {
          input.controlgroup.className = input.controlgroup.className.replace(/control-group/g, '').replace(/[ ]{2,}/g, ' ');
          input.controls.className = input.controlgroup.className.replace(/controls/g, '').replace(/[ ]{2,}/g, ' ');
          input.style.marginBottom = 0;
        }

        // TODO: use bootstrap slider
      },
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.className = 'well well-small';
        el.style.paddingBottom = 0;
        return el;
      },
      getFormInputDescription: function (text) {
        var el = document.createElement('p');
        el.className = 'help-inline';
        el.textContent = text;
        return el;
      },
      getFormControl: function (label, input, description) {
        var ret = document.createElement('div');
        ret.className = 'control-group';

        var controls = document.createElement('div');
        controls.className = 'controls';

        if (label && input.getAttribute('type') === 'checkbox') {
          ret.appendChild(controls);
          label.className += ' checkbox';
          label.appendChild(input);
          controls.appendChild(label);
          controls.style.height = '30px';
        } else {
          if (label) {
            label.className += ' control-label';
            ret.appendChild(label);
          }
          controls.appendChild(input);
          ret.appendChild(controls);
        }

        if (description) controls.appendChild(description);

        return ret;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        el.style.marginLeft = '10px';
        return el;
      },
      getButtonHolder: function () {
        var el = document.createElement('div');
        el.className = 'btn-group';
        return el;
      },
      getButton: function (text, icon, title) {
        var el = this._super(text, icon, title);
        el.className += ' btn btn-default';
        return el;
      },
      getTable: function () {
        var el = document.createElement('table');
        el.className = 'table table-bordered';
        el.style.width = 'auto';
        el.style.maxWidth = 'none';
        return el;
      },
      addInputError: function (input, text) {
        if (!input.controlgroup || !input.controls) return;
        input.controlgroup.className += ' error';
        if (!input.errmsg) {
          input.errmsg = document.createElement('p');
          input.errmsg.className = 'help-block errormsg';
          input.controls.appendChild(input.errmsg);
        } else {
          input.errmsg.style.display = '';
        }

        input.errmsg.textContent = text;
      },
      removeInputError: function (input) {
        if (!input.errmsg) return;
        input.errmsg.style.display = 'none';
        input.controlgroup.className = input.controlgroup.className.replace(/\s?error/g, '');
      },
      getTabHolder: function () {
        var el = document.createElement('div');
        el.className = 'tabbable tabs-left';
        el.innerHTML = "<ul class='nav nav-tabs span2' style='margin-right: 0;'></ul><div class='tab-content span10' style='overflow:visible;'></div>";
        return el;
      },
      getTab: function (text) {
        var el = document.createElement('li');
        var a = document.createElement('a');
        a.setAttribute('href', '#');
        a.appendChild(text);
        el.appendChild(a);
        return el;
      },
      getTabContentHolder: function (tab_holder) {
        return tab_holder.children[1];
      },
      getTabContent: function () {
        var el = document.createElement('div');
        el.className = 'tab-pane active';
        return el;
      },
      markTabActive: function (tab) {
        tab.className += ' active';
      },
      markTabInactive: function (tab) {
        tab.className = tab.className.replace(/\s?active/g, '');
      },
      addTab: function (holder, tab) {
        holder.children[0].appendChild(tab);
      },
      getProgressBar: function () {
        var container = document.createElement('div');
        container.className = 'progress';

        var bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.width = '0%';
        container.appendChild(bar);

        return container;
      },
      updateProgressBar: function (progressBar, progress) {
        if (!progressBar) return;

        progressBar.firstChild.style.width = progress + "%";
      },
      updateProgressBarUnknown: function (progressBar) {
        if (!progressBar) return;

        progressBar.className = 'progress progress-striped active';
        progressBar.firstChild.style.width = '100%';
      }
    });

    JSONEditor.defaults.themes.bootstrap3 = JSONEditor.AbstractTheme.extend({
      getSelectInput: function (options) {
        var el = this._super(options);
        el.className += 'form-control';
        //el.style.width = 'auto';
        return el;
      },
      setGridColumnSize: function (el, size) {
        el.className = 'col-md-' + size;
      },
      afterInputReady: function (input) {
        if (input.controlgroup) return;
        input.controlgroup = this.closest(input, '.form-group');
        if (this.closest(input, '.compact')) {
          input.controlgroup.style.marginBottom = 0;
        }

        // TODO: use bootstrap slider
      },
      getTextareaInput: function () {
        var el = document.createElement('textarea');
        el.className = 'form-control';
        return el;
      },
      getRangeInput: function (min, max, step) {
        // TODO: use better slider
        return this._super(min, max, step);
      },
      getFormInputField: function (type) {
        var el = this._super(type);
        if (type !== 'checkbox') {
          el.className += 'form-control';
        }
        return el;
      },
      getFormControl: function (label, input, description) {
        var group = document.createElement('div');

        if (label && input.type === 'checkbox') {
          group.className += ' checkbox';
          label.appendChild(input);
          label.style.fontSize = '14px';
          group.style.marginTop = '0';
          group.appendChild(label);
          input.style.position = 'relative';
          input.style.cssFloat = 'left';
        } else {
          group.className += ' form-group';
          if (label) {
            label.className += ' control-label';
            group.appendChild(label);
          }
          group.appendChild(input);
        }

        if (description) group.appendChild(description);

        return group;
      },
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.className = 'well well-sm';
        el.style.paddingBottom = 0;
        return el;
      },
      getFormInputDescription: function (text) {
        var el = document.createElement('p');
        el.className = 'help-block';
        el.innerHTML = text;
        return el;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        el.style.marginLeft = '10px';
        return el;
      },
      getButtonHolder: function () {
        var el = document.createElement('div');
        el.className = 'btn-group';
        return el;
      },
      getButton: function (text, icon, title) {
        var el = this._super(text, icon, title);
        el.className += 'btn btn-default';
        return el;
      },
      getTable: function () {
        var el = document.createElement('table');
        el.className = 'table table-bordered';
        el.style.width = 'auto';
        el.style.maxWidth = 'none';
        return el;
      },

      addInputError: function (input, text) {
        if (!input.controlgroup) return;
        input.controlgroup.className += ' has-error';
        if (!input.errmsg) {
          input.errmsg = document.createElement('p');
          input.errmsg.className = 'help-block errormsg';
          input.controlgroup.appendChild(input.errmsg);
        } else {
          input.errmsg.style.display = '';
        }

        input.errmsg.textContent = text;
      },
      removeInputError: function (input) {
        if (!input.errmsg) return;
        input.errmsg.style.display = 'none';
        input.controlgroup.className = input.controlgroup.className.replace(/\s?has-error/g, '');
      },
      getTabHolder: function () {
        var el = document.createElement('div');
        el.innerHTML = "<div class='tabs list-group col-md-2'></div><div class='col-md-10'></div>";
        el.className = 'rows';
        return el;
      },
      getTab: function (text) {
        var el = document.createElement('a');
        el.className = 'list-group-item';
        el.setAttribute('href', '#');
        el.appendChild(text);
        return el;
      },
      markTabActive: function (tab) {
        tab.className += ' active';
      },
      markTabInactive: function (tab) {
        tab.className = tab.className.replace(/\s?active/g, '');
      },
      getProgressBar: function () {
        var min = 0,
            max = 100,
            start = 0;

        var container = document.createElement('div');
        container.className = 'progress';

        var bar = document.createElement('div');
        bar.className = 'progress-bar';
        bar.setAttribute('role', 'progressbar');
        bar.setAttribute('aria-valuenow', start);
        bar.setAttribute('aria-valuemin', min);
        bar.setAttribute('aria-valuenax', max);
        bar.innerHTML = start + "%";
        container.appendChild(bar);

        return container;
      },
      updateProgressBar: function (progressBar, progress) {
        if (!progressBar) return;

        var bar = progressBar.firstChild;
        var percentage = progress + "%";
        bar.setAttribute('aria-valuenow', progress);
        bar.style.width = percentage;
        bar.innerHTML = percentage;
      },
      updateProgressBarUnknown: function (progressBar) {
        if (!progressBar) return;

        var bar = progressBar.firstChild;
        progressBar.className = 'progress progress-striped active';
        bar.removeAttribute('aria-valuenow');
        bar.style.width = '100%';
        bar.innerHTML = '';
      }
    });

    // Base Foundation theme
    JSONEditor.defaults.themes.foundation = JSONEditor.AbstractTheme.extend({
      getChildEditorHolder: function () {
        var el = document.createElement('div');
        el.style.marginBottom = '15px';
        return el;
      },
      getSelectInput: function (options) {
        var el = this._super(options);
        el.style.minWidth = 'none';
        el.style.padding = '5px';
        el.style.marginTop = '3px';
        return el;
      },
      getSwitcher: function (options) {
        var el = this._super(options);
        el.style.paddingRight = '8px';
        return el;
      },
      afterInputReady: function (input) {
        if (this.closest(input, '.compact')) {
          input.style.marginBottom = 0;
        }
        input.group = this.closest(input, '.form-control');
      },
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.display = 'inline-block';
        return el;
      },
      getFormInputField: function (type) {
        var el = this._super(type);
        el.style.width = '100%';
        el.style.marginBottom = type === 'checkbox' ? '0' : '12px';
        return el;
      },
      getFormInputDescription: function (text) {
        var el = document.createElement('p');
        el.textContent = text;
        el.style.marginTop = '-10px';
        el.style.fontStyle = 'italic';
        return el;
      },
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.className = 'panel';
        el.style.paddingBottom = 0;
        return el;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        el.style.display = 'inline-block';
        el.style.marginLeft = '10px';
        el.style.verticalAlign = 'middle';
        return el;
      },
      getButtonHolder: function () {
        var el = document.createElement('div');
        el.className = 'button-group';
        return el;
      },
      getButton: function (text, icon, title) {
        var el = this._super(text, icon, title);
        el.className += ' small button';
        return el;
      },
      addInputError: function (input, text) {
        if (!input.group) return;
        input.group.className += ' error';

        if (!input.errmsg) {
          input.insertAdjacentHTML('afterend', '<small class="error"></small>');
          input.errmsg = input.parentNode.getElementsByClassName('error')[0];
        } else {
          input.errmsg.style.display = '';
        }

        input.errmsg.textContent = text;
      },
      removeInputError: function (input) {
        if (!input.errmsg) return;
        input.group.className = input.group.className.replace(/ error/g, '');
        input.errmsg.style.display = 'none';
      },
      getProgressBar: function () {
        var progressBar = document.createElement('div');
        progressBar.className = 'progress';

        var meter = document.createElement('span');
        meter.className = 'meter';
        meter.style.width = '0%';
        progressBar.appendChild(meter);
        return progressBar;
      },
      updateProgressBar: function (progressBar, progress) {
        if (!progressBar) return;
        progressBar.firstChild.style.width = progress + '%';
      },
      updateProgressBarUnknown: function (progressBar) {
        if (!progressBar) return;
        progressBar.firstChild.style.width = '100%';
      }
    });

    // Foundation 3 Specific Theme
    JSONEditor.defaults.themes.foundation3 = JSONEditor.defaults.themes.foundation.extend({
      getHeaderButtonHolder: function () {
        var el = this._super();
        el.style.fontSize = '.6em';
        return el;
      },
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.fontWeight = 'bold';
        return el;
      },
      getTabHolder: function () {
        var el = document.createElement('div');
        el.className = 'row';
        el.innerHTML = "<dl class='tabs vertical two columns'></dl><div class='tabs-content ten columns'></div>";
        return el;
      },
      setGridColumnSize: function (el, size) {
        var sizes = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve'];
        el.className = 'columns ' + sizes[size];
      },
      getTab: function (text) {
        var el = document.createElement('dd');
        var a = document.createElement('a');
        a.setAttribute('href', '#');
        a.appendChild(text);
        el.appendChild(a);
        return el;
      },
      getTabContentHolder: function (tab_holder) {
        return tab_holder.children[1];
      },
      getTabContent: function () {
        var el = document.createElement('div');
        el.className = 'content active';
        el.style.paddingLeft = '5px';
        return el;
      },
      markTabActive: function (tab) {
        tab.className += ' active';
      },
      markTabInactive: function (tab) {
        tab.className = tab.className.replace(/\s*active/g, '');
      },
      addTab: function (holder, tab) {
        holder.children[0].appendChild(tab);
      }
    });

    // Foundation 4 Specific Theme
    JSONEditor.defaults.themes.foundation4 = JSONEditor.defaults.themes.foundation.extend({
      getHeaderButtonHolder: function () {
        var el = this._super();
        el.style.fontSize = '.6em';
        return el;
      },
      setGridColumnSize: function (el, size) {
        el.className = 'columns large-' + size;
      },
      getFormInputDescription: function (text) {
        var el = this._super(text);
        el.style.fontSize = '.8rem';
        return el;
      },
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.fontWeight = 'bold';
        return el;
      }
    });

    // Foundation 5 Specific Theme
    JSONEditor.defaults.themes.foundation5 = JSONEditor.defaults.themes.foundation.extend({
      getFormInputDescription: function (text) {
        var el = this._super(text);
        el.style.fontSize = '.8rem';
        return el;
      },
      setGridColumnSize: function (el, size) {
        el.className = 'columns medium-' + size;
      },
      getButton: function (text, icon, title) {
        var el = this._super(text, icon, title);
        el.className = el.className.replace(/\s*small/g, '') + ' tiny';
        return el;
      },
      getTabHolder: function () {
        var el = document.createElement('div');
        el.innerHTML = "<dl class='tabs vertical'></dl><div class='tabs-content vertical'></div>";
        return el;
      },
      getTab: function (text) {
        var el = document.createElement('dd');
        var a = document.createElement('a');
        a.setAttribute('href', '#');
        a.appendChild(text);
        el.appendChild(a);
        return el;
      },
      getTabContentHolder: function (tab_holder) {
        return tab_holder.children[1];
      },
      getTabContent: function () {
        var el = document.createElement('div');
        el.className = 'content active';
        el.style.paddingLeft = '5px';
        return el;
      },
      markTabActive: function (tab) {
        tab.className += ' active';
      },
      markTabInactive: function (tab) {
        tab.className = tab.className.replace(/\s*active/g, '');
      },
      addTab: function (holder, tab) {
        holder.children[0].appendChild(tab);
      }
    });

    JSONEditor.defaults.themes.foundation6 = JSONEditor.defaults.themes.foundation5.extend({
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.className = 'callout secondary';
        return el;
      },
      getButtonHolder: function () {
        var el = document.createElement('div');
        el.className = 'button-group tiny';
        el.style.marginBottom = 0;
        return el;
      },
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.display = 'block';
        return el;
      },
      getFormControl: function (label, input, description) {
        var el = document.createElement('div');
        el.className = 'form-control';
        if (label) el.appendChild(label);
        if (input.type === 'checkbox') {
          label.insertBefore(input, label.firstChild);
        } else if (label) {
          label.appendChild(input);
        } else {
          el.appendChild(input);
        }

        if (description) label.appendChild(description);
        return el;
      },
      addInputError: function (input, text) {
        if (!input.group) return;
        input.group.className += ' error';

        if (!input.errmsg) {
          var errorEl = document.createElement('span');
          errorEl.className = 'form-error is-visible';
          input.group.getElementsByTagName('label')[0].appendChild(errorEl);

          input.className = input.className + ' is-invalid-input';

          input.errmsg = errorEl;
        } else {
          input.errmsg.style.display = '';
          input.className = '';
        }

        input.errmsg.textContent = text;
      },
      removeInputError: function (input) {
        if (!input.errmsg) return;
        input.className = input.className.replace(/ is-invalid-input/g, '');
        if (input.errmsg.parentNode) {
          input.errmsg.parentNode.removeChild(input.errmsg);
        }
      }
    });

    JSONEditor.defaults.themes.html = JSONEditor.AbstractTheme.extend({
      getFormInputLabel: function (text) {
        var el = this._super(text);
        el.style.display = 'block';
        el.style.marginBottom = '3px';
        el.style.fontWeight = 'bold';
        return el;
      },
      getFormInputDescription: function (text) {
        var el = this._super(text);
        el.style.fontSize = '.8em';
        el.style.margin = 0;
        el.style.display = 'inline-block';
        el.style.fontStyle = 'italic';
        return el;
      },
      getIndentedPanel: function () {
        var el = this._super();
        el.style.border = '1px solid #ddd';
        el.style.padding = '5px';
        el.style.margin = '5px';
        el.style.borderRadius = '3px';
        return el;
      },
      getChildEditorHolder: function () {
        var el = this._super();
        el.style.marginBottom = '8px';
        return el;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        el.style.display = 'inline-block';
        el.style.marginLeft = '10px';
        el.style.fontSize = '.8em';
        el.style.verticalAlign = 'middle';
        return el;
      },
      getTable: function () {
        var el = this._super();
        el.style.borderBottom = '1px solid #ccc';
        el.style.marginBottom = '5px';
        return el;
      },
      addInputError: function (input, text) {
        input.style.borderColor = 'red';

        if (!input.errmsg) {
          var group = this.closest(input, '.form-control');
          input.errmsg = document.createElement('div');
          input.errmsg.setAttribute('class', 'errmsg');
          input.errmsg.style = input.errmsg.style || {};
          input.errmsg.style.color = 'red';
          group.appendChild(input.errmsg);
        } else {
          input.errmsg.style.display = 'block';
        }

        input.errmsg.innerHTML = '';
        input.errmsg.appendChild(document.createTextNode(text));
      },
      removeInputError: function (input) {
        input.style.borderColor = '';
        if (input.errmsg) input.errmsg.style.display = 'none';
      },
      getProgressBar: function () {
        var max = 100,
            start = 0;

        var progressBar = document.createElement('progress');
        progressBar.setAttribute('max', max);
        progressBar.setAttribute('value', start);
        return progressBar;
      },
      updateProgressBar: function (progressBar, progress) {
        if (!progressBar) return;
        progressBar.setAttribute('value', progress);
      },
      updateProgressBarUnknown: function (progressBar) {
        if (!progressBar) return;
        progressBar.removeAttribute('value');
      }
    });

    JSONEditor.defaults.themes.jqueryui = JSONEditor.AbstractTheme.extend({
      getTable: function () {
        var el = this._super();
        el.setAttribute('cellpadding', 5);
        el.setAttribute('cellspacing', 0);
        return el;
      },
      getTableHeaderCell: function (text) {
        var el = this._super(text);
        el.className = 'ui-state-active';
        el.style.fontWeight = 'bold';
        return el;
      },
      getTableCell: function () {
        var el = this._super();
        el.className = 'ui-widget-content';
        return el;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        el.style.marginLeft = '10px';
        el.style.fontSize = '.6em';
        el.style.display = 'inline-block';
        return el;
      },
      getFormInputDescription: function (text) {
        var el = this.getDescription(text);
        el.style.marginLeft = '10px';
        el.style.display = 'inline-block';
        return el;
      },
      getFormControl: function (label, input, description) {
        var el = this._super(label, input, description);
        if (input.type === 'checkbox') {
          el.style.lineHeight = '25px';

          el.style.padding = '3px 0';
        } else {
          el.style.padding = '4px 0 8px 0';
        }
        return el;
      },
      getDescription: function (text) {
        var el = document.createElement('span');
        el.style.fontSize = '.8em';
        el.style.fontStyle = 'italic';
        el.textContent = text;
        return el;
      },
      getButtonHolder: function () {
        var el = document.createElement('div');
        el.className = 'ui-buttonset';
        el.style.fontSize = '.7em';
        return el;
      },
      getFormInputLabel: function (text) {
        var el = document.createElement('label');
        el.style.fontWeight = 'bold';
        el.style.display = 'block';
        el.textContent = text;
        return el;
      },
      getButton: function (text, icon, title) {
        var button = document.createElement("button");
        button.className = 'ui-button ui-widget ui-state-default ui-corner-all';

        // Icon only
        if (icon && !text) {
          button.className += ' ui-button-icon-only';
          icon.className += ' ui-button-icon-primary ui-icon-primary';
          button.appendChild(icon);
        }
        // Icon and Text
        else if (icon) {
            button.className += ' ui-button-text-icon-primary';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          }
          // Text only
          else {
              button.className += ' ui-button-text-only';
            }

        var el = document.createElement('span');
        el.className = 'ui-button-text';
        el.textContent = text || title || ".";
        button.appendChild(el);

        button.setAttribute('title', title);

        return button;
      },
      setButtonText: function (button, text, icon, title) {
        button.innerHTML = '';
        button.className = 'ui-button ui-widget ui-state-default ui-corner-all';

        // Icon only
        if (icon && !text) {
          button.className += ' ui-button-icon-only';
          icon.className += ' ui-button-icon-primary ui-icon-primary';
          button.appendChild(icon);
        }
        // Icon and Text
        else if (icon) {
            button.className += ' ui-button-text-icon-primary';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          }
          // Text only
          else {
              button.className += ' ui-button-text-only';
            }

        var el = document.createElement('span');
        el.className = 'ui-button-text';
        el.textContent = text || title || ".";
        button.appendChild(el);

        button.setAttribute('title', title);
      },
      getIndentedPanel: function () {
        var el = document.createElement('div');
        el.className = 'ui-widget-content ui-corner-all';
        el.style.padding = '1em 1.4em';
        el.style.marginBottom = '20px';
        return el;
      },
      afterInputReady: function (input) {
        if (input.controls) return;
        input.controls = this.closest(input, '.form-control');
      },
      addInputError: function (input, text) {
        if (!input.controls) return;
        if (!input.errmsg) {
          input.errmsg = document.createElement('div');
          input.errmsg.className = 'ui-state-error';
          input.controls.appendChild(input.errmsg);
        } else {
          input.errmsg.style.display = '';
        }

        input.errmsg.textContent = text;
      },
      removeInputError: function (input) {
        if (!input.errmsg) return;
        input.errmsg.style.display = 'none';
      },
      markTabActive: function (tab) {
        tab.className = tab.className.replace(/\s*ui-widget-header/g, '') + ' ui-state-active';
      },
      markTabInactive: function (tab) {
        tab.className = tab.className.replace(/\s*ui-state-active/g, '') + ' ui-widget-header';
      }
    });

    JSONEditor.defaults.themes.barebones = JSONEditor.AbstractTheme.extend({
      getFormInputLabel: function (text) {
        var el = this._super(text);
        return el;
      },
      getFormInputDescription: function (text) {
        var el = this._super(text);
        return el;
      },
      getIndentedPanel: function () {
        var el = this._super();
        return el;
      },
      getChildEditorHolder: function () {
        var el = this._super();
        return el;
      },
      getHeaderButtonHolder: function () {
        var el = this.getButtonHolder();
        return el;
      },
      getTable: function () {
        var el = this._super();
        return el;
      },
      addInputError: function (input, text) {
        if (!input.errmsg) {
          var group = this.closest(input, '.form-control');
          input.errmsg = document.createElement('div');
          input.errmsg.setAttribute('class', 'errmsg');
          group.appendChild(input.errmsg);
        } else {
          input.errmsg.style.display = 'block';
        }

        input.errmsg.innerHTML = '';
        input.errmsg.appendChild(document.createTextNode(text));
      },
      removeInputError: function (input) {
        input.style.borderColor = '';
        if (input.errmsg) input.errmsg.style.display = 'none';
      },
      getProgressBar: function () {
        var max = 100,
            start = 0;

        var progressBar = document.createElement('progress');
        progressBar.setAttribute('max', max);
        progressBar.setAttribute('value', start);
        return progressBar;
      },
      updateProgressBar: function (progressBar, progress) {
        if (!progressBar) return;
        progressBar.setAttribute('value', progress);
      },
      updateProgressBarUnknown: function (progressBar) {
        if (!progressBar) return;
        progressBar.removeAttribute('value');
      }
    });

    JSONEditor.AbstractIconLib = Class.extend({
      mapping: {
        collapse: '',
        expand: '',
        "delete": '',
        edit: '',
        add: '',
        cancel: '',
        save: '',
        moveup: '',
        movedown: ''
      },
      icon_prefix: '',
      getIconClass: function (key) {
        if (this.mapping[key]) return this.icon_prefix + this.mapping[key];else return null;
      },
      getIcon: function (key) {
        var iconclass = this.getIconClass(key);

        if (!iconclass) return null;

        var i = document.createElement('i');
        i.className = iconclass;
        return i;
      }
    });

    JSONEditor.defaults.iconlibs.bootstrap2 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'chevron-down',
        expand: 'chevron-up',
        "delete": 'trash',
        edit: 'pencil',
        add: 'plus',
        cancel: 'ban-circle',
        save: 'ok',
        moveup: 'arrow-up',
        movedown: 'arrow-down'
      },
      icon_prefix: 'icon-'
    });

    JSONEditor.defaults.iconlibs.bootstrap3 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'chevron-down',
        expand: 'chevron-right',
        "delete": 'remove',
        edit: 'pencil',
        add: 'plus',
        cancel: 'floppy-remove',
        save: 'floppy-saved',
        moveup: 'arrow-up',
        movedown: 'arrow-down'
      },
      icon_prefix: 'glyphicon glyphicon-'
    });

    JSONEditor.defaults.iconlibs.fontawesome3 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'chevron-down',
        expand: 'chevron-right',
        "delete": 'remove',
        edit: 'pencil',
        add: 'plus',
        cancel: 'ban-circle',
        save: 'save',
        moveup: 'arrow-up',
        movedown: 'arrow-down'
      },
      icon_prefix: 'icon-'
    });

    JSONEditor.defaults.iconlibs.fontawesome4 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'caret-square-o-down',
        expand: 'caret-square-o-right',
        "delete": 'times',
        edit: 'pencil',
        add: 'plus',
        cancel: 'ban',
        save: 'save',
        moveup: 'arrow-up',
        movedown: 'arrow-down'
      },
      icon_prefix: 'fa fa-'
    });

    JSONEditor.defaults.iconlibs.foundation2 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'minus',
        expand: 'plus',
        "delete": 'remove',
        edit: 'edit',
        add: 'add-doc',
        cancel: 'error',
        save: 'checkmark',
        moveup: 'up-arrow',
        movedown: 'down-arrow'
      },
      icon_prefix: 'foundicon-'
    });

    JSONEditor.defaults.iconlibs.foundation3 = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'minus',
        expand: 'plus',
        "delete": 'x',
        edit: 'pencil',
        add: 'page-add',
        cancel: 'x-circle',
        save: 'save',
        moveup: 'arrow-up',
        movedown: 'arrow-down'
      },
      icon_prefix: 'fi-'
    });

    JSONEditor.defaults.iconlibs.jqueryui = JSONEditor.AbstractIconLib.extend({
      mapping: {
        collapse: 'triangle-1-s',
        expand: 'triangle-1-e',
        "delete": 'trash',
        edit: 'pencil',
        add: 'plusthick',
        cancel: 'closethick',
        save: 'disk',
        moveup: 'arrowthick-1-n',
        movedown: 'arrowthick-1-s'
      },
      icon_prefix: 'ui-icon ui-icon-'
    });

    JSONEditor.defaults.templates["default"] = function () {
      return {
        compile: function (template) {
          var matches = template.match(/{{\s*([a-zA-Z0-9\-_ \.]+)\s*}}/g);
          var l = matches && matches.length;

          // Shortcut if the template contains no variables
          if (!l) return function () {
            return template;
          };

          // Pre-compute the search/replace functions
          // This drastically speeds up template execution
          var replacements = [];
          var get_replacement = function (i) {
            var p = matches[i].replace(/[{}]+/g, '').trim().split('.');
            var n = p.length;
            var func;

            if (n > 1) {
              var cur;
              func = function (vars) {
                cur = vars;
                for (i = 0; i < n; i++) {
                  cur = cur[p[i]];
                  if (!cur) break;
                }
                return cur;
              };
            } else {
              p = p[0];
              func = function (vars) {
                return vars[p];
              };
            }

            replacements.push({
              s: matches[i],
              r: func
            });
          };
          for (var i = 0; i < l; i++) {
            get_replacement(i);
          }

          // The compiled function
          return function (vars) {
            var ret = template + "";
            var r;
            for (i = 0; i < l; i++) {
              r = replacements[i];
              ret = ret.replace(r.s, r.r(vars));
            }
            return ret;
          };
        }
      };
    };

    JSONEditor.defaults.templates.ejs = function () {
      if (!window.EJS) return false;

      return {
        compile: function (template) {
          var compiled = new window.EJS({
            text: template
          });

          return function (context) {
            return compiled.render(context);
          };
        }
      };
    };

    JSONEditor.defaults.templates.handlebars = function () {
      return window.Handlebars;
    };

    JSONEditor.defaults.templates.hogan = function () {
      if (!window.Hogan) return false;

      return {
        compile: function (template) {
          var compiled = window.Hogan.compile(template);
          return function (context) {
            return compiled.render(context);
          };
        }
      };
    };

    JSONEditor.defaults.templates.markup = function () {
      if (!window.Mark || !window.Mark.up) return false;

      return {
        compile: function (template) {
          return function (context) {
            return window.Mark.up(template, context);
          };
        }
      };
    };

    JSONEditor.defaults.templates.mustache = function () {
      if (!window.Mustache) return false;

      return {
        compile: function (template) {
          return function (view) {
            return window.Mustache.render(template, view);
          };
        }
      };
    };

    JSONEditor.defaults.templates.swig = function () {
      return window.swig;
    };

    JSONEditor.defaults.templates.underscore = function () {
      if (!window._) return false;

      return {
        compile: function (template) {
          return function (context) {
            return window._.template(template, context);
          };
        }
      };
    };

    // Set the default theme
    JSONEditor.defaults.theme = 'html';

    // Set the default template engine
    JSONEditor.defaults.template = 'default';

    // Default options when initializing JSON Editor
    JSONEditor.defaults.options = {};

    // String translate function
    JSONEditor.defaults.translate = function (key, variables) {
      var lang = JSONEditor.defaults.languages[JSONEditor.defaults.language];
      if (!lang) throw "Unknown language " + JSONEditor.defaults.language;

      var string = lang[key] || JSONEditor.defaults.languages[JSONEditor.defaults.default_language][key];

      if (typeof string === "undefined") throw "Unknown translate string " + key;

      if (variables) {
        for (var i = 0; i < variables.length; i++) {
          string = string.replace(new RegExp('\\{\\{' + i + '}}', 'g'), variables[i]);
        }
      }

      return string;
    };

    // Translation strings and default languages
    JSONEditor.defaults.default_language = 'en';
    JSONEditor.defaults.language = JSONEditor.defaults.default_language;
    JSONEditor.defaults.languages.en = {
      /**
       * When a property is not set
       */
      error_notset: "Property must be set",
      /**
       * When a string must not be empty
       */
      error_notempty: "Value required",
      /**
       * When a value is not one of the enumerated values
       */
      error_enum: "Value must be one of the enumerated values",
      /**
       * When a value doesn't validate any schema of a 'anyOf' combination
       */
      error_anyOf: "Value must validate against at least one of the provided schemas",
      /**
       * When a value doesn't validate
       * @variables This key takes one variable: The number of schemas the value does not validate
       */
      error_oneOf: 'Value must validate against exactly one of the provided schemas. It currently validates against {{0}} of the schemas.',
      /**
       * When a value does not validate a 'not' schema
       */
      error_not: "Value must not validate against the provided schema",
      /**
       * When a value does not match any of the provided types
       */
      error_type_union: "Value must be one of the provided types",
      /**
       * When a value does not match the given type
       * @variables This key takes one variable: The type the value should be of
       */
      error_type: "Value must be of type {{0}}",
      /**
       *  When the value validates one of the disallowed types
       */
      error_disallow_union: "Value must not be one of the provided disallowed types",
      /**
       *  When the value validates a disallowed type
       * @variables This key takes one variable: The type the value should not be of
       */
      error_disallow: "Value must not be of type {{0}}",
      /**
       * When a value is not a multiple of or divisible by a given number
       * @variables This key takes one variable: The number mentioned above
       */
      error_multipleOf: "Value must be a multiple of {{0}}",
      /**
       * When a value is greater than it's supposed to be (exclusive)
       * @variables This key takes one variable: The maximum
       */
      error_maximum_excl: "Value must be less than {{0}}",
      /**
       * When a value is greater than it's supposed to be (inclusive
       * @variables This key takes one variable: The maximum
       */
      error_maximum_incl: "Value must be at most {{0}}",
      /**
       * When a value is lesser than it's supposed to be (exclusive)
       * @variables This key takes one variable: The minimum
       */
      error_minimum_excl: "Value must be greater than {{0}}",
      /**
       * When a value is lesser than it's supposed to be (inclusive)
       * @variables This key takes one variable: The minimum
       */
      error_minimum_incl: "Value must be at least {{0}}",
      /**
       * When a value have too many characters
       * @variables This key takes one variable: The maximum character count
       */
      error_maxLength: "Value must be at most {{0}} characters long",
      /**
       * When a value does not have enough characters
       * @variables This key takes one variable: The minimum character count
       */
      error_minLength: "Value must be at least {{0}} characters long",
      /**
       * When a value does not match a given pattern
       */
      error_pattern: "Value must match the pattern {{0}}",
      /**
       * When an array has additional items whereas it is not supposed to
       */
      error_additionalItems: "No additional items allowed in this array",
      /**
       * When there are to many items in an array
       * @variables This key takes one variable: The maximum item count
       */
      error_maxItems: "Value must have at most {{0}} items",
      /**
       * When there are not enough items in an array
       * @variables This key takes one variable: The minimum item count
       */
      error_minItems: "Value must have at least {{0}} items",
      /**
       * When an array is supposed to have unique items but has duplicates
       */
      error_uniqueItems: "Array must have unique items",
      /**
       * When there are too many properties in an object
       * @variables This key takes one variable: The maximum property count
       */
      error_maxProperties: "Object must have at most {{0}} properties",
      /**
       * When there are not enough properties in an object
       * @variables This key takes one variable: The minimum property count
       */
      error_minProperties: "Object must have at least {{0}} properties",
      /**
       * When a required property is not defined
       * @variables This key takes one variable: The name of the missing property
       */
      error_required: "Object is missing the required property '{{0}}'",
      /**
       * When there is an additional property is set whereas there should be none
       * @variables This key takes one variable: The name of the additional property
       */
      error_additional_properties: "No additional properties allowed, but property {{0}} is set",
      /**
       * When a dependency is not resolved
       * @variables This key takes one variable: The name of the missing property for the dependency
       */
      error_dependency: "Must have property {{0}}",
      /**
       * Text on Delete All buttons
       */
      button_delete_all: "All",
      /**
       * Title on Delete All buttons
       */
      button_delete_all_title: "Delete All",
      /**
        * Text on Delete Last buttons
        * @variable This key takes one variable: The title of object to delete
        */
      button_delete_last: "Last {{0}}",
      /**
        * Title on Delete Last buttons
        * @variable This key takes one variable: The title of object to delete
        */
      button_delete_last_title: "Delete Last {{0}}",
      /**
        * Title on Add Row buttons
        * @variable This key takes one variable: The title of object to add
        */
      button_add_row_title: "Add {{0}}",
      /**
        * Title on Move Down buttons
        */
      button_move_down_title: "Move down",
      /**
        * Title on Move Up buttons
        */
      button_move_up_title: "Move up",
      /**
        * Title on Delete Row buttons
        * @variable This key takes one variable: The title of object to delete
        */
      button_delete_row_title: "Delete {{0}}",
      /**
        * Title on Delete Row buttons, short version (no parameter with the object title)
        */
      button_delete_row_title_short: "Delete",
      /**
        * Title on Collapse buttons
        */
      button_collapse: "Collapse",
      /**
        * Title on Expand buttons
        */
      button_expand: "Expand"
    };

    // Miscellaneous Plugin Settings
    JSONEditor.plugins = {
      ace: {
        theme: ''
      },
      epiceditor: {},
      sceditor: {},
      select2: {},
      selectize: {}
    };

    // Default per-editor options
    $each(JSONEditor.defaults.editors, function (i, editor) {
      JSONEditor.defaults.editors[i].options = editor.options || {};
    });

    // Set the default resolvers
    // Use "multiple" as a fall back for everything
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (typeof schema.type !== "string") return "multiple";
    });
    // If the type is not set but properties are defined, we can infer the type is actually object
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // If the schema is a simple type
      if (!schema.type && schema.properties) return "object";
    });
    // If the type is set and it's a basic type, use the primitive editor
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // If the schema is a simple type
      if (typeof schema.type === "string") return schema.type;
    });
    // Boolean editors
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (schema.type === 'boolean') {
        // If explicitly set to 'checkbox', use that
        if (schema.format === "checkbox" || schema.options && schema.options.checkbox) {
          return "checkbox";
        }
        // Otherwise, default to select menu
        return JSONEditor.plugins.selectize.enable ? 'selectize' : 'select';
      }
    });
    // Use the multiple editor for schemas where the `type` is set to "any"
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // If the schema can be of any type
      if (schema.type === "any") return "multiple";
    });
    // Editor for base64 encoded files
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // If the schema can be of any type
      if (schema.type === "string" && schema.media && schema.media.binaryEncoding === "base64") {
        return "base64";
      }
    });
    // Editor for uploading files
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (schema.type === "string" && schema.format === "url" && schema.options && schema.options.upload === true) {
        if (window.FileReader) return "upload";
      }
    });
    // Use the table editor for arrays with the format set to `table`
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // Type `array` with format set to `table`
      if (schema.type == "array" && schema.format == "table") {
        return "table";
      }
    });
    // Use the `select` editor for dynamic enumSource enums
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (schema.enumSource) return JSONEditor.plugins.selectize.enable ? 'selectize' : 'select';
    });
    // Use the `enum` or `select` editors for schemas with enumerated properties
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (schema["enum"]) {
        if (schema.type === "array" || schema.type === "object") {
          return "enum";
        } else if (schema.type === "number" || schema.type === "integer" || schema.type === "string") {
          return JSONEditor.plugins.selectize.enable ? 'selectize' : 'select';
        }
      }
    });
    // Specialized editors for arrays of strings
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      if (schema.type === "array" && schema.items && !Array.isArray(schema.items) && schema.uniqueItems && ['string', 'number', 'integer'].indexOf(schema.items.type) >= 0) {
        // For enumerated strings, number, or integers
        if (schema.items.enum) {
          return 'multiselect';
        }
        // For non-enumerated strings (tag editor)
        else if (JSONEditor.plugins.selectize.enable && schema.items.type === "string") {
            return 'arraySelectize';
          }
      }
    });
    // Use the multiple editor for schemas with `oneOf` set
    JSONEditor.defaults.resolvers.unshift(function (schema) {
      // If this schema uses `oneOf` or `anyOf`
      if (schema.oneOf || schema.anyOf) return "multiple";
    });

    /**
     * This is a small wrapper for using JSON Editor like a typical jQuery plugin.
     */
    (function () {
      if (window.jQuery || window.Zepto) {
        var $ = window.jQuery || window.Zepto;
        $.jsoneditor = JSONEditor.defaults;

        $.fn.jsoneditor = function (options) {
          var self = this;
          var editor = this.data('jsoneditor');
          if (options === 'value') {
            if (!editor) throw "Must initialize jsoneditor before getting/setting the value";

            // Set value
            if (arguments.length > 1) {
              editor.setValue(arguments[1]);
            }
            // Get value
            else {
                return editor.getValue();
              }
          } else if (options === 'validate') {
            if (!editor) throw "Must initialize jsoneditor before validating";

            // Validate a specific value
            if (arguments.length > 1) {
              return editor.validate(arguments[1]);
            }
            // Validate current value
            else {
                return editor.validate();
              }
          } else if (options === 'destroy') {
            if (editor) {
              editor.destroy();
              this.data('jsoneditor', null);
            }
          } else {
            // Destroy first
            if (editor) {
              editor.destroy();
            }

            // Create editor
            editor = new JSONEditor(this.get(0), options);
            this.data('jsoneditor', editor);

            // Setup event listeners
            editor.on('change', function () {
              self.trigger('change');
            });
            editor.on('ready', function () {
              self.trigger('ready');
            });
          }

          return this;
        };
      }
    })();

    window.JSONEditor = JSONEditor;
  })();

  
});
$__System.registerDynamic("e0", ["df"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("df");
});
$__System.registerDynamic("e1", ["e2"], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* loads npm-published function module accepting string, returning array of positive numbers or undefined */

	const positiveNumberArray = $__require("e2");

	function JSONEditorPositiveNumberArrayTextarea() {

		if (window.JSONEditor) {

			/* suggested by json-editor README.md lines 1122-1165 */

			window.JSONEditor.defaults.resolvers.unshift(function (schema) {
				if (schema.type === "array" && schema.format === "textarea" && schema.flavor === "positiveNumber") {
					return "positiveNumber";
				}
			});

			/* from an examination of json-editor/src/editors/number.js */

			window.JSONEditor.defaults.editors.positiveNumber = window.JSONEditor.defaults.editors.string.extend({
				sanitize(value) {
					return (positiveNumberArray(value) || []).join(" ");
				},
				getNumColumns() {
					return 2;
				},
				getValue() {
					return positiveNumberArray(this.value) || [];
				}
			});
		}
	}

	module.exports = JSONEditorPositiveNumberArrayTextarea;
});
$__System.registerDynamic("e3", ["e1"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("e1");
});
$__System.registerDynamic("e4", [], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    // Copyright 2016 Paul Brewer, Economic and Financial Technology Consulting LLC                             
    // This is open source software. The MIT License applies to this software.                                  
    // see https://opensource.org/licenses/MIT or included License.md file

    /* eslint no-sync:"off", no-underscore-dangle:"off" */

    /* global fs */

    /**
     * Isomorphic javascript logger, logs data rows to memory for browser and test simulations, logs data rows to .csv disk files for node server-based simulations
     */

    /**
     * Log stores tabular (array-of-array) data in JS memory on the browser, but streams it to disk using fs.appendFileSync() in nodejs server apps.
     * .last is used to cache the last log row As a kind of limited guarantee of history on both platforms
     */

    var Log = function () {

        /** 
         * Create Log with suggested file name in browser memory or on-disk in nodejs
         *
         * @param {string} fname Suggested file name
         * @param {boolean} force true forces filesystem mode, false forces memory mode, undefined tests for 'fs' module
         */

        function Log(fname, force) {
            _classCallCheck(this, Log);

            /**
             * if true, uses nodejs fs calls
             * @type {boolean} this.useFS
             */

            this.useFS = false;
            try {
                if (typeof force === 'undefined') {
                    this.useFS = typeof fname === 'string' && (typeof fs === 'undefined' ? 'undefined' : _typeof(fs)) === 'object' && typeof fs.openSync === 'function' && typeof fs.appendFileSync === 'function' && !fs.should;
                } else {
                    this.useFS = force;
                }
            } catch (e) {} // eslint-disable-line no-empty

            if (this.useFS) {

                /**
                 * log file descriptor from open call
                 * @type {number} this.fd
                 */

                this.fname = fname;
                this.fd = fs.openSync(fname, 'w');
            } else {

                /** 
                 * data array for browser and test usage
                 * @type {Array} this.data
                 */

                this.data = [];
            }
        }

        /**
         * stringifies data for text file
         * @param {Array|number|string} x data fo write to a string output
         * @return {string} stringified x data
         */

        _createClass(Log, [{
            key: 'stringify',
            value: function stringify(x) {
                if (Array.isArray(x)) {
                    return x.join(",") + "\n";
                }
                if (typeof x === 'number' || typeof x === 'string') {
                    return x + "\n";
                }
                return JSON.stringify(x) + "\n";
            }

            /**
             * writes data to Log and sets .last
             * @param {Array|number|string} x data to write to Log's log file or memory
             * @return {Object} returns Log object, chainable
             */

        }, {
            key: 'write',
            value: function write(x) {
                if (x === undefined) return;

                /**
                 * last item written to log
                 * @type {Object} this.last
                 */

                this.last = x;

                if (this.useFS) {
                    fs.appendFileSync(this.fd, this.stringify(x));
                } else {
                    this.data.push(x);
                }
                return this;
            }

            /**
             * sets header row and writes it to Log for csv-style Log. 
             * @param {string[]} x Header array giving names of columns for future writes
             * @return {Object} Returns this Log; chainable
             */

        }, {
            key: 'setHeader',
            value: function setHeader(x) {
                if (Array.isArray(x)) {

                    /**
                     * header array for Log, as set by setHeader(header)
                     * @type {string[]}
                     */

                    this.header = x;
                    this.write(x);
                }
                return this;
            }

            /**
             * last value for some column recorded in Log 
             * @return {number|string|undefined} value from last write at column position matching header for given key
             */

        }, {
            key: 'lastByKey',
            value: function lastByKey(k) {
                if (this.header && this.header.length && this.last && this.last.length) {
                    return this.last[this.header.indexOf(k)];
                }
            }

            /**
             * get string of all data in the log.  If useFS is true, simply read the file.  If useFS is false, assemble from data. 
             *
             * @return string representing all log data
             *
             */

        }, {
            key: 'toString',
            value: function toString() {
                if (this.useFS) {
                    return fs.readFileSync(this.fname, { encoding: 'utf8' });
                }
                var s = '';
                var i = void 0,
                    l = void 0;
                for (i = 0, l = this.data.length; i < l; ++i) {
                    s += this.stringify(this.data[i]);
                }
                return s;
            }

            /**
             * restore Log from string.  inverse of toString(). 
             *
             * @param string to convert to complete Log
             */

        }, {
            key: 'fromString',
            value: function fromString(s) {
                function rowFromLine(line) {
                    var row = line.split(",");
                    for (var i = 0, rl = row.length; i < rl; ++i) {
                        var v = row[i];
                        if (v && /^-?\d/.test(v)) {
                            v = parseFloat(v);
                            if (!isNaN(v)) row[i] = v;
                        }
                    }
                    return row;
                }
                var first = s.substring(0, s.indexOf("\n"));
                var start = 0;

                if (this.data) {
                    if (this.data.length > 1) throw new Error("forbidden: attempting fromString() on populated Log -- denied -- would cause data erasure");
                    this.data.length = 0;
                }

                if (this.header) {
                    this.setHeader(first.split(","));
                    start = first.length + 1;
                }

                var l = s.length;

                while (start < l) {
                    var match = s.indexOf("\n", start);
                    var line = match === -1 ? s.substring(start, s.length) : s.substring(start, match);
                    start += line.length + 1;
                    var fchar = line[0];
                    if (fchar === '{' || fchar === '"' || fchar === '[') {
                        var obj = JSON.parse(line);
                        this.write(obj);
                    } else if (line.includes(",")) {
                        this.write(rowFromLine(line));
                    } else this.write(line);
                }
                return this;
            }

            /**
             * get readable stream of string log data. This function requires a base class parameter Readable if using with in-memory data.
             * @param {Object} Readable base class for constructing readable streams (required only if log useFS=false)
             * @return {Object} readable stream of log data, in string form with newlines terminating records
             */

        }, {
            key: 'createReadStream',
            value: function createReadStream(Readable) {
                if (this.useFS) {
                    fs.fsyncSync(this.fd);
                    return fs.createReadStream(this.fname, { encoding: 'utf8' });
                }
                if (!Readable) throw new Error("missing base class for Readable stream as first parameter");

                var LogStream = function (_Readable) {
                    _inherits(LogStream, _Readable);

                    function LogStream(simlog, opt) {
                        _classCallCheck(this, LogStream);

                        var _this = _possibleConstructorReturn(this, (LogStream.__proto__ || Object.getPrototypeOf(LogStream)).call(this, opt));

                        _this._log = simlog;
                        _this._index = 0;
                        return _this;
                    }

                    _createClass(LogStream, [{
                        key: '_read',
                        value: function _read() {
                            var i = void 0,
                                hungry = void 0;
                            do {
                                i = this._index++;
                                if (i < this._log.data.length) {
                                    var str = this._log.stringify(this._log.data[i]);
                                    if (typeof str === 'string' && str.length > 0) hungry = this.push(str, 'utf8');
                                } else {
                                    hungry = this.push(null);
                                }
                            } while (i < this._max && hungry);
                        }
                    }]);

                    return LogStream;
                }(Readable);

                return new LogStream(this);
            }
        }]);

        return Log;
    }();

    exports.default = Log;
});
$__System.registerDynamic("e5", ["e4"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("e4");
});
$__System.registerDynamic("e6", ["e7", "96"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MarketEngine = undefined;
    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    var _events = $__require("e7");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function reject(order) {
      if (Array.isArray(order)) {
        order[0] = 0;
      } else if ((typeof order === 'undefined' ? 'undefined' : _typeof(order)) === 'object') {
        order.ok = false;
      }
    }
    var MarketEngine = exports.MarketEngine = function (_EventEmitter) {
      _inherits(MarketEngine, _EventEmitter);
      function MarketEngine() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? { pushArray: 1 } : arguments[0];
        _classCallCheck(this, MarketEngine);
        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MarketEngine).call(this));
        _this.o = options;
        if (_this.o.goods) _this.goods = _this.o.goods;
        _this.a = [];
        _this.trash = [];
        _this.count = 0;
        _this.on('trade-cleanup', function (tradespec) {
          if (tradespec && tradespec.buyA && tradespec.buyQ && this.o.qCol) this.reduceQ(tradespec.buyA, tradespec.buyQ);
          if (tradespec && tradespec.sellA && tradespec.sellQ && this.o.qCol) this.reduceQ(tradespec.sellA, tradespec.sellQ);
        });
        return _this;
      }
      _createClass(MarketEngine, [{
        key: 'clear',
        value: function clear() {
          if (this.a && this.a.length) this.a.length = 0;
          if (this.trash && this.trash.length) this.trash.length = 0;
          this.count = 0;
          this.emit('clear');
        }
      }, {
        key: 'bump',
        value: function bump(neworder) {
          var countRemoved = 0;
          var cancelCol = this.o.cancelCol,
              tCol = this.o.tCol,
              idCol = this.o.idCol;
          if (cancelCol !== undefined && idCol !== undefined && neworder[cancelCol]) {
            countRemoved += this.cancel(neworder[idCol]);
          }
          if (tCol !== undefined && neworder[tCol]) {
            countRemoved += this.expire(neworder[tCol]);
          }
          if (countRemoved > 0) this.emit('bump');
        }
      }, {
        key: 'push',
        value: function push(order) {
          var myorder = void 0;
          if (this.o.pushArray && Array.isArray(order)) {
            myorder = order.slice();
            myorder.unshift(1, Date.now());
            this.emit('before-order', myorder, reject);
            if (myorder.length && myorder[0]) {
              this.count++;
              myorder[0] = this.count;
              this.emit('preorder', myorder);
              if (!this.o.noBump) this.bump(myorder);
              if (this.a) this.a.push(myorder);
              this.emit('order', myorder);
            } else {
              this.emit('reject', myorder);
            }
          } else if (this.o.pushObject && (typeof order === 'undefined' ? 'undefined' : _typeof(order)) === 'object') {
            myorder = Object.assign({}, order);
            myorder.ts = Date.now();
            myorder.ok = 1;
            this.emit('before-order', myorder, reject);
            if (myorder.ok) {
              delete myorder.ok;
              this.count++;
              myorder.num = this.count;
              this.emit('preorder', myorder);
              if (!this.o.noBump) this.bump(myorder);
              if (this.a) this.a.push(myorder);
              this.emit('order', myorder);
            } else {
              this.emit('reject', myorder);
            }
          }
        }
      }, {
        key: 'reduceQ',
        value: function reduceQ(ais, qs) {
          var i = 0,
              l = Math.max(ais.length, qs.length),
              qCol = this.o.qCol;
          var trash = this.trash,
              a = this.a;
          var order = void 0;
          if (!a) return;
          for (i = 0; i < l; ++i) {
            order = a[ais[i]];
            order[qCol] -= qs[i];
            if (order[qCol] < 0) throw new Error('quantity (' + qs[i] + ') exceeded availability in order:');
            if (order[qCol] === 0 && trash) trash.push(ais[i]);
          }
        }
      }, {
        key: 'trade',
        value: function trade(tradespec) {
          if (this.o.goods) tradespec.goods = this.o.goods;
          if (this.o.money) tradespec.money = this.o.money;
          this.emit('trade', tradespec);
          this.emit('trade-cleanup', tradespec);
          this.emit('after-trade', tradespec);
        }
      }, {
        key: 'expire',
        value: function expire(ts) {
          var i = void 0,
              l = void 0,
              order = void 0,
              countExpired = 0;
          var xCol = this.o.txCol,
              qCol = this.o.qCol;
          var a = this.a,
              trash = this.trash;
          if (!a || xCol === undefined) return;
          for (i = 0, l = a.length; i < l; ++i) {
            order = a[i];
            if (order && order[xCol] > 0 && ts > order[xCol]) {
              countExpired++;
              if (trash) trash.push(i);
              if (qCol !== undefined) order[qCol] = 0;
            }
          }
          return countExpired;
        }
      }, {
        key: 'cancel',
        value: function cancel(id) {
          var i = void 0,
              order = void 0,
              countCancelled = 0;
          var idCol = this.o.idCol,
              qCol = this.o.qCol;
          var a = this.a,
              trash = this.trash;
          var cancelCol = this.o.cancelCol;
          if (!a) return;
          i = a.length;
          while (i-- > 0) {
            order = a[i];
            if (order && id === order[idCol]) {
              countCancelled++;
              if (trash) trash.push(i);
              if (qCol !== undefined) order[qCol] = 0;
              if (order[cancelCol]) i = 0;
            }
          }
          return countCancelled;
        }
      }, {
        key: 'emptyTrash',
        value: function emptyTrash() {
          var trash = this.trash,
              a = this.a;
          if (!trash || !a) return;
          trash.sort(function (x, y) {
            return x - y;
          });
          var i = trash.length,
              last = -1,
              j = void 0,
              uniq = [];
          while (i-- > 0) {
            j = trash[i];
            if (j !== last) {
              last = j;
              uniq.unshift(j);
              a.splice(j, 1);
            }
          }
          this.trash = [];
          return uniq;
        }
      }]);
      return MarketEngine;
    }(_events.EventEmitter);
  })($__require("96"));
});
$__System.registerDynamic("e8", ["e6"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("e6");
});
$__System.registerDynamic("e9", [], true, function ($__require, exports, module) {
   var global = this || self,
       GLOBAL = global;
   /* Copyright 2016 Paul Brewer, Economic & Financial Technology COnsulting LLC  <drpaulbrewer@eaftc.com> */
   /* License: MIT https://opensource.org/licenses/MIT  */

   module.exports = function (l, h, tol, f) {
      'use strict';
      // returns a two element array giving an inclusive range of zero values of f
      // requires strictly everywhere non-descending function f
      // use with caution:  this code assumes but does and can not check that f is everywhere non-descending

      var right = h,
          left = l,
          intflag = tol >= 1;
      var fl = f(l),
          fh = f(h);
      if (fl === 0 && fh === 0) return [l, h];
      if (fh < fl) throw new Error("findZeroRange: requires non-descending function");
      if (fl >= 0) return [];
      if (fh <= 0) return [];
      var zleft, zright, mid;
      zright = left;
      while (right - zright > tol) {
         mid = (right + zright) / 2;
         if (intflag) mid = Math.floor(mid);
         if (f(mid) > 0) right = mid;else zright = mid;
      }
      if (f(zright) < 0) return [zright];
      zleft = zright;
      while (zleft - left > tol) {
         mid = (left + zleft) / 2;
         if (intflag) mid = Math.floor(mid);
         if (f(mid) < 0) left = mid;else zleft = mid;
      }
      if (zleft === zright) return [zright];
      return [zleft, zright];
   };
});
$__System.registerDynamic("ea", ["e9"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("e9");
});
$__System.registerDynamic('eb', ['ea'], true, function ($__require, exports, module) {
			var global = this || self,
			    GLOBAL = global;
			/* */
			var findZeroRange = $__require('ea');

			function walrasianCEPriceRange(pLow, pHigh, pTol, qDemand, qSupply) {
						'use strict';

						var excessSupply = function (p) {
									return qSupply(p) - qDemand(p);
						};
						var priceRange = findZeroRange(pLow, pHigh, pTol, excessSupply);
						// correction for integer prices and quantities when a supply order is needed for CE
						if (priceRange.length === 1 && pTol === 1 && excessSupply(priceRange[0]) < 0 && qSupply(priceRange[0]) < qSupply(priceRange[0] + 1)) return [priceRange[0] + 1];
						return priceRange;
			}

			module.exports.walrasianCEPriceRange = walrasianCEPriceRange;

			function demandFromQueue(buyQueue, bpCol, qCol) {
						return function (p) {
									'use strict';

									var i = 0,
									    l = buyQueue.length,
									    totalQ = 0;
									while (i < l && p <= buyQueue[i][bpCol]) {
												totalQ += buyQueue[i][qCol];
												++i;
									}
									return totalQ;
						};
			}

			module.exports.demandFromQueue = demandFromQueue;

			function supplyFromQueue(sellQueue, spCol, qCol) {
						return function (p) {
									'use strict';

									var i = 0,
									    l = sellQueue.length,
									    totalQ = 0;
									while (i < l && p >= sellQueue[i][spCol]) {
												totalQ += sellQueue[i][qCol];
												++i;
									}
									return totalQ;
						};
			}

			module.exports.supplyFromQueue = supplyFromQueue;

			function marshallianCEPriceRange(inframarginalBuyPrice, inframarginalSellPrice, extramarginalBuyPrice, extramarginalSellPrice) {
						'use strict';

						if (extramarginalBuyPrice > inframarginalBuyPrice) throw new Error("marketPricing.marshallianCEPriceRange: invalid buy prices, extramarginal price must not be greater than inframarginal price");
						if (extramarginalSellPrice < inframarginalSellPrice) throw new Error("marketPricing.marshallianCEPriceRange: invalid sell prices, extramarginal price must not be less than inframarginal price");
						if (extramarginalBuyPrice >= extramarginalSellPrice) throw new Error("marketPricing.marshallianCEPriceRange: invalid extramarginal prices, extramarginal buy price should not equal or exceed extramarginal sell price");
						var cePriceRange = [Math.max(extramarginalBuyPrice, inframarginalSellPrice) || inframarginalSellPrice, Math.min(extramarginalSellPrice, inframarginalBuyPrice) || inframarginalBuyPrice];
						return cePriceRange;
			}

			module.exports.marshallianCEPriceRange = marshallianCEPriceRange;

			function crossSingleUnitDemandAndSupply(buyPrices, sellPrices) {
						'use strict';

						var l = Math.min(buyPrices.length, sellPrices.length),
						    q0 = 0,
						    q1 = 0;
						var ceIntersection;
						if (l > 0) {
									while (q0 < l && buyPrices[q0] > sellPrices[q0]) q0++;
									q1 = q0;
									while (q1 < l && buyPrices[q1] >= sellPrices[q1]) q1++;
									if (q1 === 0) {
												ceIntersection = {
															p: [buyPrices[0], sellPrices[0]],
															q: 0
												};
									} else {
												if (q1 > q0) {
															/* in this case, buyPrices[j]===sellPrices[j] at q0<=j<q1 */
															ceIntersection = {
																		p: buyPrices[q1 - 1],
																		q: [q0, q1]
															};
												} else if (q1 === q0) {
															ceIntersection = {
																		p: marshallianCEPriceRange(buyPrices[q1 - 1], sellPrices[q1 - 1], buyPrices[q1], sellPrices[q1]),
																		q: q0
															};
															if (ceIntersection.p[0] === ceIntersection.p[1]) ceIntersection.p = ceIntersection.p[0];
												}
									}
									return ceIntersection;
						}
			}

			module.exports.crossSingleUnitDemandAndSupply = crossSingleUnitDemandAndSupply;

			function cross(buyQueue, sellQueue, bpCol, bqCol, spCol, sqCol) {
						'use strict';

						if (bpCol === undefined || bqCol === undefined || spCol === undefined || sqCol === undefined) throw new Error("marketPricing.cross: missing 1 or more col parameters: " + [bpCol, bqCol, spCol, sqCol].join(","));
						var bidx = 0,
						    sidx = 0,
						    bl = buyQueue.length,
						    sl = sellQueue.length;
						if (!bl || !sl) return undefined;
						var buyQ = [],
						    sellQ = [],
						    deltaQ = 0,
						    totalQ = 0;
						var ibp,
						    isp,
						    ebp = buyQueue[0][bpCol],
						    esp = sellQueue[0][spCol];
						if (ebp >= esp) {
									buyQ[0] = 0;
									sellQ[0] = 0;
						}
						while (ebp >= esp && bidx < bl && sidx < sl) {
									deltaQ = Math.min(buyQueue[bidx][bqCol] - buyQ[bidx], sellQueue[sidx][sqCol] - sellQ[sidx]);
									totalQ += deltaQ;
									// increment or initialize quantity bought/sold by deltaQ
									buyQ[bidx] += deltaQ;
									sellQ[sidx] += deltaQ;
									ibp = ebp;
									isp = esp;
									if (buyQueue[bidx][bqCol] === buyQ[bidx]) {
												bidx++;
												buyQ[bidx] = 0;
												ebp = bidx < bl ? buyQueue[bidx][bpCol] : undefined;
									}
									if (sellQueue[sidx][sqCol] === sellQ[sidx]) {
												sidx++;
												sellQ[sidx] = 0;
												esp = sidx < sl ? sellQueue[sidx][spCol] : undefined;
									}
						}
						if (totalQ === 0) return undefined;
						var priceRange = marshallianCEPriceRange(ibp, isp, ebp, esp);
						var price = (priceRange[0] + priceRange[1]) / 2;
						if (buyQ[bidx] === 0) buyQ.pop();
						if (sellQ[sidx] === 0) sellQ.pop();
						return [price, totalQ, buyQ, sellQ];
			}

			module.exports.cross = cross;

			function sequential(buyQueue, sellQueue, tCol, bpCol, bqCol, spCol, sqCol) {
						'use strict';

						if (tCol === undefined || bpCol === undefined || bqCol === undefined || spCol === undefined || sqCol === undefined) throw new Error("marketPricing.sequential: missing 1 or more col parameters: " + [tCol, bpCol, bqCol, spCol, sqCol].join(","));
						var totalQ, prices, buyQ, sellQ, i, l, op;
						if (!buyQueue.length || !sellQueue.length || buyQueue[0][bpCol] < sellQueue[0][spCol]) return undefined;
						var crossResult = cross(buyQueue, sellQueue, bpCol, bqCol, spCol, sqCol);
						if (crossResult === undefined) return undefined;
						totalQ = crossResult[1];
						buyQ = crossResult[2];
						sellQ = crossResult[3];
						prices = [];
						if (buyQueue[0][tCol] < sellQueue[0][tCol]) {
									op = 's';
									if (sellQ[1]) throw new Error("marketPricing.sequential: non-sequential trades on sell side");
									for (i = 0, l = buyQ.length; i < l; ++i) prices[i] = buyQueue[i][bpCol];
						} else {
									op = 'b';
									if (buyQ[1]) throw new Error("marketPricing.sequential: non-sequential trades on buy side");
									for (i = 0, l = sellQ.length; i < l; ++i) prices[i] = sellQueue[i][spCol];
						}
						return [op, prices, totalQ, buyQ, sellQ];
			}

			module.exports.sequential = sequential;
});
$__System.registerDynamic("ec", ["eb"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("eb");
});
$__System.registerDynamic("ed", [], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* jshint esnext:true */
	/* Copyright 2016 Paul Brewer, Economic & Financial Technology Consulting LLC */
	/* module source code for PartialIndex */
	/* Open Source License: The MIT License */

	(function () {
		'use strict';

		function sort1(i1, d1) {
			return function (a, b) {
				return d1 * (+a[i1] - b[i1]);
			};
		}

		function sort2(i1, d1, i2, d2) {
			return function (a, b) {
				var c1 = +a[i1] - b[i1];
				if (0 === c1) return d2 * (+a[i2] - b[i2]);
				return d1 * c1;
			};
		}

		function sort3(i1, d1, i2, d2, i3, d3) {
			var func2 = sort2(i2, d2, i3, d3);
			return function (a, b) {
				var c1 = +a[i1] - b[i1];
				if (0 === c1) return func2(a, b);
				return d1 * c1;
			};
		}

		function makeSorter(prop1, dir1, prop2, dir2, prop3, dir3) {
			if (dir3) {
				return sort3(prop1, dir1, prop2, dir2, prop3, dir3);
			} else if (dir2) {
				return sort2(prop1, dir1, prop2, dir2);
			} else if (dir1) {
				return sort1(prop1, dir1);
			} else {
				return sort1(prop1, 1);
			}
		}

		function makeFilter(prop1, dir1, prop2, dir2, prop3, dir3) {
			if (dir3) {
				return function (item) {
					return item && item[prop1] > 0 && item[prop2] > 0 && item[prop3] > 0;
				};
			} else if (dir2) {
				return function (item) {
					return item && item[prop1] > 0 && item[prop2] > 0;
				};
			} else return function (item) {
				return item && item[prop1] > 0;
			};
		}

		function makeBulkFilter(prop1, dir1, prop2, dir2, prop3, dir3) {
			if (dir3) {
				return function (data) {
					var i, l, r, item;
					for (i = 0, l = data.length, r = []; i < l; ++i) {
						item = data[i];
						if (item && item[prop1] > 0 && item[prop2] > 0 && item[prop3] > 0) r.push(i);
					}
					return r;
				};
			} else if (dir2) {
				return function (data) {
					var i, l, r, item;
					for (i = 0, l = data.length, r = []; i < l; ++i) {
						item = data[i];
						if (item && item[prop1] > 0 && item[prop2] > 0) r.push(i);
					}
					return r;
				};
			} else {
				return function (data) {
					var i, l, r, item;
					for (i = 0, l = data.length, r = []; i < l; ++i) {
						item = data[i];
						if (item && item[prop1] > 0) r.push(i);
					}
					return r;
				};
			}
		}

		function idxByBisection(sorted, v, comp) {
			var cmp;
			var left, right, mid, midval;
			var checkLeft;
			if (!comp) {
				if (v >= sorted[sorted.length - 1]) return sorted.length;
				if (v < sorted[0]) return 0;
				if (v === sorted[0]) return 1;
				left = 0;
				right = sorted.length - 1;
				while (right - left > 1) {
					mid = Math.floor((left + right) / 2);
					midval = sorted[mid];
					if (v > midval) left = mid;else if (v < midval) right = mid;else if (v === midval) {
						left = mid;
						right = mid + 1;
					}
				}
				return right;
			} else {
				if (comp(v, sorted[sorted.length - 1]) >= 0) return sorted.length;
				checkLeft = comp(v, sorted[0]);
				if (checkLeft < 0) return 0;
				if (checkLeft === 0) return 1;
				left = 0;
				right = sorted.length - 1;
				while (right - left > 1) {
					mid = Math.floor((left + right) / 2);
					midval = sorted[mid];
					cmp = comp(v, midval);
					if (cmp > 0) left = mid;else if (cmp < 0) right = mid;else if (0 === cmp) {
						left = mid;
						right = mid + 1;
					}
				}
				return right;
			}
		}

		var PartialIndex = function (data, limit, prop1, dir1, prop2, dir2, prop3, dir3) {
			this.data = data;
			this.limit = limit;
			this.idx = [];
			this.iok = [];
			this.prop1 = prop1;
			this.dir1 = dir1;
			this.datafilter = makeFilter(prop1, dir1, prop2, dir2, prop3, dir3);
			this.datacomp = makeSorter(prop1, dir1, prop2, dir2, prop3, dir3);
			var that = this;
			this.idxcomp = function (a, b) {
				var d = that.data;return that.datacomp(d[a], d[b]);
			};
			this.idxfilter = function (i) {
				return that.datafilter(that.data[i]);
			};
			this.bulkFilter = makeBulkFilter(prop1, dir1, prop2, dir2, prop3, dir3);
			if (this.data.length) this.needScan = 1;
		};

		PartialIndex.prototype.val = function (i) {
			if (i >= this.idx.length || i < 0) return undefined;
			return this.data[this.idx[i]][this.prop1];
		};

		PartialIndex.prototype.vals = function () {
			for (var i = 0, l = this.idx.length, a = [], data = this.data, idx = this.idx, prop = this.prop1; i < l; ++i) a[i] = data[idx[i]][prop];
			return a;
		};

		PartialIndex.prototype.valBisect = function (v) {
			var prop1 = this.prop1;
			var dir1 = this.dir1;
			var idx = this.idx;
			var data = this.data;
			var cmp;
			if (!idx || idx.length === 0) return;
			if (dir1 < 0) cmp = function (av, bi) {
				return data[bi][prop1] - av;
			};else cmp = function (av, bi) {
				return av - data[bi][prop1];
			};
			return idxByBisection(idx, v, cmp);
		};

		PartialIndex.prototype.idxdata = function (ii) {
			var i = 0,
			    l = this.idx.length,
			    idx = this.idx,
			    data = this.data,
			    a = [];
			if (ii === undefined) {
				for (i = 0; i < l; ++i) a[i] = data[idx[i]];
				return a;
			}
			return data[idx[ii]];
		};

		PartialIndex.prototype.scan = function (newLimit) {
			var i, l;
			this.idx = [];
			var limit = newLimit || this.limit;
			this.needScan = 0;
			this.limit = limit;
			if (0 === limit) return;
			this.iok = this.bulkFilter(this.data);
			if (this.iok.length) this.sort(limit);
		};

		PartialIndex.prototype.sort = function (newLimit) {
			if (!this.iok || !this.iok.length) return this.scan(newLimit);
			if (newLimit > 0) this.limit = newLimit;
			var iok = this.iok,
			    ioki,
			    limit = this.limit,
			    idxcomp = this.idxcomp,
			    loc,
			    i,
			    l;
			this.needScan = 0;
			if (0 === limit) return;
			// testing reveals that full internal .sort(this.idxcomp) is actually pretty fast and
			// our insertion sort with bisection is only faster when the index limit
			// is less than 1% of the filtered data length
			if (limit > 0.01 * this.iok.length) this.idx = iok.slice();else this.idx = iok.slice(0, 2 * limit);
			var idx = this.idx;
			idx.sort(idxcomp);
			var j = idx.length;
			if (j > limit) idx.splice(limit, j - limit);
			if (iok.length <= limit) return;
			for (i = j, l = iok.length; i < l; ++i) {
				ioki = iok[i];
				loc = idxByBisection(idx, ioki, idxcomp);
				if (loc < limit) {
					idx.splice(loc, 0, ioki);
					idx.splice(limit, 1);
				}
			}
		};

		PartialIndex.prototype.syncLast = function () {
			var lastdataidx = this.data.length - 1;
			var loc;
			var idx = this.idx;
			var limit = this.limit;
			if (!limit) return;
			if (this.idxfilter(lastdataidx)) {
				if (this.needScan) return this.scan();
				if (Array.isArray(this.iok)) this.iok.push(lastdataidx);
				if (idx.length < limit) {
					idx.push(lastdataidx);
					idx.sort(this.idxcomp);
				} else {
					loc = idxByBisection(idx, lastdataidx, this.idxcomp);
					if (loc < limit) {
						idx.splice(loc, 0, lastdataidx);
						idx.splice(limit, 1);
					}
				}
			}
		};

		PartialIndex.prototype.remove = function (rmidxs, options) {
			var i = rmidxs.length,
			    l;
			var idx = this.idx;
			var loc;
			var removed = 0;
			if (0 === rmidxs.length) return;
			while (i-- > 1) {
				if (rmidxs[i - 1] >= rmidxs[i]) throw new Error("PartialIndex.remove called with unsorted list of indexes. List of indexes to be removed must be ascending.");
			}
			delete this.iok; /* bust iok cache */
			i = rmidxs.length;
			while (i-- > 0) {
				loc = idx.indexOf(rmidxs[i]);
				if (loc >= 0) {
					idx.splice(loc, 1);
					++removed;
				}
			}
			if (removed && options && options.scan) return this.scan(options.limit);
			if (removed) {
				if (options && options.shrink) {
					this.limit -= removed;
				} else {
					this.needScan = 1;
				}
			}
			if (options && options.preserve) return;
			for (i = 0, l = idx.length; i < l; ++i) idx[i] -= idxByBisection(rmidxs, idx[i]);
		};

		PartialIndex.prototype.shrink = function (newsize) {
			var s = +newsize;
			if (!s || s <= 0 || s >= this.limit) return;
			this.limit = s;
			this.idx.splice(s, this.idx.length - s);
		};

		module.exports = PartialIndex;
	})();
});
$__System.registerDynamic("ee", ["ed"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("ed");
});
$__System.registerDynamic("ef", ["e8", "ec", "ee", "96"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Market = exports.orderHeader = undefined;
    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.ao = ao;
    exports.oa = oa;
    var _marketEngine = $__require("e8");
    var _marketPricing = $__require("ec");
    var _marketPricing2 = _interopRequireDefault(_marketPricing);
    var _partialIndex = $__require("ee");
    var _partialIndex2 = _interopRequireDefault(_partialIndex);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var orderHeader = exports.orderHeader = ['count', 'tlocal', 't', 'tx', 'id', 'cancel', 'q', 'buyPrice', 'sellPrice', 'buyStop', 'buyStopPrice', 'sellStop', 'sellStopPrice', 'triggersBuyPrice', 'triggersSellPrice', 'triggersBuyStop', 'triggersBuyStopPrice', 'triggersSellStop', 'triggersSellStopPrice'];
    function ao(ordera) {
      var obj = {};
      var i = 0,
          l = orderHeader.length,
          offset = 0;
      if (ordera.length === orderHeader.length) {
        offset = 0;
      } else if (ordera.length === orderHeader.length - 2) {
        offset = 2;
      } else {
        throw new Error("market-example-contingent function ao(), expected order array to have length 17 or 19, got " + ordera.length);
      }
      for (i = offset; i < l; ++i) {
        if (i <= 6 || ordera[i - offset]) obj[orderHeader[i]] = ordera[i - offset];
      }
      return obj;
    }
    function oa(oin) {
      var a = [];
      var i = void 0,
          l = void 0;
      if ((typeof oin === 'undefined' ? 'undefined' : _typeof(oin)) === 'object') {
        for (i = 2, l = orderHeader.length; i < l; ++i) {
          a[i - 2] = oin[orderHeader[i]];
          if (!a[i - 2]) a[i - 2] = 0;
        }
      }
      return a;
    }
    var Market = exports.Market = function (_MarketEngine) {
      _inherits(Market, _MarketEngine);
      function Market(options) {
        _classCallCheck(this, Market);
        var defaults = {
          pushArray: 1,
          countCol: 0,
          tlocalCol: 1,
          tCol: 2,
          txCol: 3,
          idCol: 4,
          cancelCol: 5,
          qCol: 6,
          bpCol: 7,
          spCol: 8,
          bsCol: 9,
          bspCol: 10,
          ssCol: 11,
          sspCol: 12,
          trigSliceBegin: 13,
          trigSliceEnd: 19,
          bookfixed: 1,
          booklimit: 100
        };
        var _this = _possibleConstructorReturn(this, (Market.__proto__ || Object.getPrototypeOf(Market)).call(this, Object.assign({}, defaults, options)));
        _this.on('bump', _this.cleanup);
        _this.on('before-order', _this.improvementRule);
        _this.on('order', function () {
          this.book.buy.syncLast();
          this.book.sell.syncLast();
          this.book.buyStop.syncLast();
          this.book.sellStop.syncLast();
          this.findAndProcessTrades();
        });
        _this.on('trade', _this.tradeTrigger);
        _this.on('trade-cleanup', function (tradespec) {
          this.findAndProcessStops(tradespec);
          this.cleanup();
          this.bookSizeRule();
        });
        _this.on('stops', _this.stopsTrigger);
        _this.clear();
        return _this;
      }
      _createClass(Market, [{
        key: 'submit',
        value: function submit(neworder) {
          if (Array.isArray(neworder) && neworder.length === orderHeader.length - 2) {
            this.inbox.push(neworder);
            return undefined;
          }
          return "market-example-contingent.submit: Invalid order, not an array of the correct length, got:" + JSON.stringify(neworder);
        }
      }, {
        key: 'process',
        value: function process() {
          if (this.inbox.length > 0) this.push(this.inbox.shift());
          return this.inbox.length;
        }
      }, {
        key: 'improvementRule',
        value: function improvementRule(neworder, reject) {
          var bpCol = this.o.bpCol,
              spCol = this.o.spCol;
          if (this.o.buyImprove && neworder[bpCol] && this.book.buy.idx && this.book.buy.idx.length >= this.o.buyImprove && neworder[bpCol] <= this.book.buy.val(this.o.buyImprove - 1)) return reject(neworder);
          if (this.o.sellImprove && neworder[spCol] && this.book.sell.idx && this.book.sell.idx.length >= this.o.sellImprove && neworder[spCol] >= this.book.sell.val(this.o.sellImprove - 1)) return reject(neworder);
        }
      }, {
        key: 'bookSizeRule',
        value: function bookSizeRule() {
          var _this2 = this;
          if (this.o.resetAfterEachTrade) return this.clear();
          var buySellBookLimit = this.o.buySellBookLimit;
          if (buySellBookLimit > 0) {
            (function () {
              var keep = {};
              [_this2.book.buy, _this2.book.sell].forEach(function (B) {
                var i = void 0,
                    l = void 0;
                for (i = 0, l = Math.min(B.idx.length, buySellBookLimit); i < l; ++i) {
                  keep[B.idx[i]] = 1;
                }
              });
              [_this2.book.buyStop, _this2.book.sellStop].forEach(function (B) {
                var i = void 0,
                    l = void 0;
                for (i = 0, l = B.idx.length; i < l; i++) {
                  keep[B.idx[i]] = 1;
                }
              });
              var keepidx = Object.keys(keep).sort(function (a, b) {
                return +a - b;
              });
              var i = void 0,
                  l = void 0,
                  temp = [];
              for (i = 0, l = keepidx.length; i < l; ++i) {
                temp[i] = _this2.a[keepidx[i]];
              }
              for (i = 0, l = keepidx.length; i < l; ++i) {
                _this2.a[i] = temp[i];
              }
              _this2.a.length = l;
              _this2.books.forEach(function (B) {
                B.scan();
              });
            })();
          }
        }
      }, {
        key: 'currentBidPrice',
        value: function currentBidPrice() {
          return this.book.buy.val(0);
        }
      }, {
        key: 'currentAskPrice',
        value: function currentAskPrice() {
          return this.book.sell.val(0);
        }
      }, {
        key: 'lastTradePrice',
        value: function lastTradePrice() {
          if (this.lastTrade && this.lastTrade.prices && this.lastTrade.prices.length) return this.lastTrade.prices[this.lastTrade.prices.length - 1];
        }
      }, {
        key: 'findAndProcessStops',
        value: function findAndProcessStops(tradespec) {
          var matches = void 0;
          for (matches = this.stopsMatch(tradespec); Math.max.apply(Math, _toConsumableArray(matches)) > 0; matches = this.stopsMatch(tradespec)) {
            this.emit('stops', tradespec.t, matches);
          }
        }
      }, {
        key: 'findAndProcessTrades',
        value: function findAndProcessTrades() {
          var seqtrades = void 0;
          var tradeSpec = void 0;
          var i = void 0,
              l = void 0;
          while ((seqtrades = _marketPricing2.default.sequential(this.book.buy.idxdata(), this.book.sell.idxdata(), this.o.countCol, this.o.bpCol, this.o.qCol, this.o.spCol, this.o.qCol)) !== undefined) {
            tradeSpec = {
              t: seqtrades[0] === 'b' ? this.book.buy.idxdata(0)[this.o.tCol] : this.book.sell.idxdata(0)[this.o.tCol],
              bs: seqtrades[0],
              prices: seqtrades[1],
              totalQ: seqtrades[2],
              buyQ: seqtrades[3],
              sellQ: seqtrades[4],
              buyA: this.book.buy.idx.slice(0, seqtrades[3].length),
              sellA: this.book.sell.idx.slice(0, seqtrades[4].length)
            };
            tradeSpec.buyId = [];
            tradeSpec.sellId = [];
            for (i = 0, l = tradeSpec.buyA.length; i < l; ++i) {
              tradeSpec.buyId[i] = this.a[tradeSpec.buyA[i]][this.o.idCol];
            }
            for (i = 0, l = tradeSpec.sellA.length; i < l; ++i) {
              tradeSpec.sellId[i] = this.a[tradeSpec.sellA[i]][this.o.idCol];
            }
            this.trade(tradeSpec);
            this.lastTrade = tradeSpec;
          }
        }
      }, {
        key: 'stopsMatch',
        value: function stopsMatch(tradespec) {
          var prices = tradespec.prices;
          var low = Math.min.apply(Math, _toConsumableArray(prices));
          var high = Math.max.apply(Math, _toConsumableArray(prices));
          return [this.book.buyStop.valBisect(high) || 0, this.book.sellStop.valBisect(low) || 0];
        }
      }, {
        key: 'stopsTrigger',
        value: function stopsTrigger(t, matches) {
          var o = this.o;
          if (!matches) return;
          function toBuyAtMarket(buystop) {
            var neworder = buystop.slice();
            neworder[o.tCol] = t;
            neworder[o.txCol] = 0;
            neworder[o.cancelCol] = 0;
            neworder[o.bpCol] = neworder[o.bspCol];
            neworder[o.bsCol] = 0;
            neworder[o.bspCol] = 0;
            neworder[o.spCol] = 0;
            neworder[o.ssCol] = 0;
            neworder[o.sspCol] = 0;
            neworder.splice(0, 2);
            return neworder;
          }
          function toSellAtMarket(sellstop) {
            var neworder = sellstop.slice();
            neworder[o.tCol] = t;
            neworder[o.txCol] = 0;
            neworder[o.cancelCol] = 0;
            neworder[o.bpCol] = 0;
            neworder[o.bsCol] = 0;
            neworder[o.bspCol] = 0;
            neworder[o.spCol] = neworder[o.sspCol];
            neworder[o.ssCol] = 0;
            neworder[o.sspCol] = 0;
            neworder.splice(0, 2);
            return neworder;
          }
          if (matches[0]) {
            var _inbox, _trash;
            var bs = this.book.buyStop;
            var newOrders = bs.idxdata().slice(0, matches[0]).map(toBuyAtMarket);
            var trashIdxs = bs.idx.slice(0, matches[0]);
            (_inbox = this.inbox).push.apply(_inbox, _toConsumableArray(newOrders));
            (_trash = this.trash).push.apply(_trash, _toConsumableArray(trashIdxs));
          }
          if (matches[1]) {
            var _inbox2, _trash2;
            var ss = this.book.sellStop;
            var _newOrders = ss.idxdata().slice(0, matches[1]).map(toSellAtMarket);
            var _trashIdxs = ss.idx.slice(0, matches[1]);
            (_inbox2 = this.inbox).push.apply(_inbox2, _toConsumableArray(_newOrders));
            (_trash2 = this.trash).push.apply(_trash2, _toConsumableArray(_trashIdxs));
          }
          this.cleanup();
        }
      }, {
        key: 'triggerOrderToInbox',
        value: function triggerOrderToInbox(j, q, t) {
          if (j === undefined || !q) return;
          var myorder = this.a[j];
          var o = this.o;
          var qCol = o.qCol;
          var bpCol = o.bpCol;
          var tCol = o.tCol;
          var idCol = o.idCol;
          var trigSliceBegin = o.trigSliceBegin;
          var trigSliceEnd = o.trigSliceEnd;
          var inbox = this.inbox;
          if (myorder && myorder[qCol] >= q) {
            if (myorder[trigSliceBegin] > 0 || myorder[trigSliceBegin + 1] > 0 || myorder[trigSliceBegin + 2] > 0 || myorder[trigSliceBegin + 3] > 0 || myorder[trigSliceBegin + 4] > 0 || myorder[trigSliceBegin + 5] > 0) {
              var trigorder = [];
              for (var ii = 0, ll = trigSliceEnd - 2; ii < ll; ++ii) {
                trigorder[ii] = 0;
              }
              trigorder[tCol - 2] = t;
              trigorder[idCol - 2] = myorder[idCol];
              trigorder[qCol - 2] = q;
              for (var _ii = 0, _ll = trigSliceEnd - trigSliceBegin; _ii < _ll; ++_ii) {
                trigorder[bpCol + _ii - 2] = myorder[_ii + trigSliceBegin];
              }
              inbox.push(trigorder);
            }
          }
        }
      }, {
        key: 'tradeTrigger',
        value: function tradeTrigger(tradespec) {
          var t = tradespec.t;
          var buyA = tradespec.buyA,
              sellA = tradespec.sellA;
          var buyQ = tradespec.buyQ,
              sellQ = tradespec.sellQ;
          if (buyA) for (var i = 0, l = buyA.length; i < l; ++i) {
            this.triggerOrderToInbox(buyA[i], buyQ[i], t);
          }
          if (sellA) for (var _i = 0, _l = sellA.length; _i < _l; ++_i) {
            this.triggerOrderToInbox(sellA[_i], sellQ[_i], t);
          }
        }
      }, {
        key: 'clear',
        value: function clear() {
          _get(Market.prototype.__proto__ || Object.getPrototypeOf(Market.prototype), 'clear', this).call(this);
          this.book = {};
          this.book.limit = this.o.booklimit || 100;
          this.book.fixed = this.o.bookfixed;
          this.book.buy = new _partialIndex2.default(this.a, this.book.limit, this.o.bpCol, -1, this.o.countCol, 1, this.o.qCol, 1);
          this.book.sell = new _partialIndex2.default(this.a, this.book.limit, this.o.spCol, 1, this.o.countCol, 1, this.o.qCol, 1);
          this.book.buyStop = new _partialIndex2.default(this.a, this.book.limit, this.o.bsCol, 1, this.o.countCol, 1, this.o.qCol, 1);
          this.book.sellStop = new _partialIndex2.default(this.a, this.book.limit, this.o.ssCol, -1, this.o.countCol, 1, this.o.qCol, 1);
          this.books = [this.book.buy, this.book.sell, this.book.buyStop, this.book.sellStop];
          this.inbox = [];
        }
      }, {
        key: 'cleanup',
        value: function cleanup() {
          var blimit = this.book.limit;
          var bfixed = this.book.fixed;
          var r = this.emptyTrash();
          this.books.forEach(function (b) {
            if (!bfixed && r.length < 10) {
              b.remove(r, { shrink: 1 });
              if (b.limit < blimit / 2) b.scan(blimit);
            } else {
              b.scan(blimit);
            }
          });
        }
      }]);
      return Market;
    }(_marketEngine.MarketEngine);
  })($__require("96"));
});
$__System.registerDynamic("f0", ["ef"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("ef");
});
$__System.registerDynamic("f1", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  /*jshint eqnull:true*/

  var global = this || self,
      GLOBAL = global;
  (function (root) {
    "use strict";

    var GLOBAL_KEY = "Random";

    var imul = typeof Math.imul !== "function" || Math.imul(0xffffffff, 5) !== -5 ? function (a, b) {
      var ah = a >>> 16 & 0xffff;
      var al = a & 0xffff;
      var bh = b >>> 16 & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    } : Math.imul;

    var stringRepeat = typeof String.prototype.repeat === "function" && "x".repeat(3) === "xxx" ? function (x, y) {
      return x.repeat(y);
    } : function (pattern, count) {
      var result = "";
      while (count > 0) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result;
    };

    function Random(engine) {
      if (!(this instanceof Random)) {
        return new Random(engine);
      }

      if (engine == null) {
        engine = Random.engines.nativeMath;
      } else if (typeof engine !== "function") {
        throw new TypeError("Expected engine to be a function, got " + typeof engine);
      }
      this.engine = engine;
    }
    var proto = Random.prototype;

    Random.engines = {
      nativeMath: function () {
        return Math.random() * 0x100000000 | 0;
      },
      mt19937: function (Int32Array) {
        // http://en.wikipedia.org/wiki/Mersenne_twister
        function refreshData(data) {
          var k = 0;
          var tmp = 0;
          for (; (k | 0) < 227; k = k + 1 | 0) {
            tmp = data[k] & 0x80000000 | data[k + 1 | 0] & 0x7fffffff;
            data[k] = data[k + 397 | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? 0x9908b0df : 0);
          }

          for (; (k | 0) < 623; k = k + 1 | 0) {
            tmp = data[k] & 0x80000000 | data[k + 1 | 0] & 0x7fffffff;
            data[k] = data[k - 227 | 0] ^ tmp >>> 1 ^ (tmp & 0x1 ? 0x9908b0df : 0);
          }

          tmp = data[623] & 0x80000000 | data[0] & 0x7fffffff;
          data[623] = data[396] ^ tmp >>> 1 ^ (tmp & 0x1 ? 0x9908b0df : 0);
        }

        function temper(value) {
          value ^= value >>> 11;
          value ^= value << 7 & 0x9d2c5680;
          value ^= value << 15 & 0xefc60000;
          return value ^ value >>> 18;
        }

        function seedWithArray(data, source) {
          var i = 1;
          var j = 0;
          var sourceLength = source.length;
          var k = Math.max(sourceLength, 624) | 0;
          var previous = data[0] | 0;
          for (; (k | 0) > 0; --k) {
            data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x0019660d)) + (source[j] | 0) + (j | 0) | 0;
            i = i + 1 | 0;
            ++j;
            if ((i | 0) > 623) {
              data[0] = data[623];
              i = 1;
            }
            if (j >= sourceLength) {
              j = 0;
            }
          }
          for (k = 623; (k | 0) > 0; --k) {
            data[i] = previous = (data[i] ^ imul(previous ^ previous >>> 30, 0x5d588b65)) - i | 0;
            i = i + 1 | 0;
            if ((i | 0) > 623) {
              data[0] = data[623];
              i = 1;
            }
          }
          data[0] = 0x80000000;
        }

        function mt19937() {
          var data = new Int32Array(624);
          var index = 0;
          var uses = 0;

          function next() {
            if ((index | 0) >= 624) {
              refreshData(data);
              index = 0;
            }

            var value = data[index];
            index = index + 1 | 0;
            uses += 1;
            return temper(value) | 0;
          }
          next.getUseCount = function () {
            return uses;
          };
          next.discard = function (count) {
            uses += count;
            if ((index | 0) >= 624) {
              refreshData(data);
              index = 0;
            }
            while (count - index > 624) {
              count -= 624 - index;
              refreshData(data);
              index = 0;
            }
            index = index + count | 0;
            return next;
          };
          next.seed = function (initial) {
            var previous = 0;
            data[0] = previous = initial | 0;

            for (var i = 1; i < 624; i = i + 1 | 0) {
              data[i] = previous = imul(previous ^ previous >>> 30, 0x6c078965) + i | 0;
            }
            index = 624;
            uses = 0;
            return next;
          };
          next.seedWithArray = function (source) {
            next.seed(0x012bd6aa);
            seedWithArray(data, source);
            return next;
          };
          next.autoSeed = function () {
            return next.seedWithArray(Random.generateEntropyArray());
          };
          return next;
        }

        return mt19937;
      }(typeof Int32Array === "function" ? Int32Array : Array),
      browserCrypto: typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function" && typeof Int32Array === "function" ? function () {
        var data = null;
        var index = 128;

        return function () {
          if (index >= 128) {
            if (data === null) {
              data = new Int32Array(128);
            }
            crypto.getRandomValues(data);
            index = 0;
          }

          return data[index++] | 0;
        };
      }() : null
    };

    Random.generateEntropyArray = function () {
      var array = [];
      var engine = Random.engines.nativeMath;
      for (var i = 0; i < 16; ++i) {
        array[i] = engine() | 0;
      }
      array.push(new Date().getTime() | 0);
      return array;
    };

    function returnValue(value) {
      return function () {
        return value;
      };
    }

    // [-0x80000000, 0x7fffffff]
    Random.int32 = function (engine) {
      return engine() | 0;
    };
    proto.int32 = function () {
      return Random.int32(this.engine);
    };

    // [0, 0xffffffff]
    Random.uint32 = function (engine) {
      return engine() >>> 0;
    };
    proto.uint32 = function () {
      return Random.uint32(this.engine);
    };

    // [0, 0x1fffffffffffff]
    Random.uint53 = function (engine) {
      var high = engine() & 0x1fffff;
      var low = engine() >>> 0;
      return high * 0x100000000 + low;
    };
    proto.uint53 = function () {
      return Random.uint53(this.engine);
    };

    // [0, 0x20000000000000]
    Random.uint53Full = function (engine) {
      while (true) {
        var high = engine() | 0;
        if (high & 0x200000) {
          if ((high & 0x3fffff) === 0x200000 && (engine() | 0) === 0) {
            return 0x20000000000000;
          }
        } else {
          var low = engine() >>> 0;
          return (high & 0x1fffff) * 0x100000000 + low;
        }
      }
    };
    proto.uint53Full = function () {
      return Random.uint53Full(this.engine);
    };

    // [-0x20000000000000, 0x1fffffffffffff]
    Random.int53 = function (engine) {
      var high = engine() | 0;
      var low = engine() >>> 0;
      return (high & 0x1fffff) * 0x100000000 + low + (high & 0x200000 ? -0x20000000000000 : 0);
    };
    proto.int53 = function () {
      return Random.int53(this.engine);
    };

    // [-0x20000000000000, 0x20000000000000]
    Random.int53Full = function (engine) {
      while (true) {
        var high = engine() | 0;
        if (high & 0x400000) {
          if ((high & 0x7fffff) === 0x400000 && (engine() | 0) === 0) {
            return 0x20000000000000;
          }
        } else {
          var low = engine() >>> 0;
          return (high & 0x1fffff) * 0x100000000 + low + (high & 0x200000 ? -0x20000000000000 : 0);
        }
      }
    };
    proto.int53Full = function () {
      return Random.int53Full(this.engine);
    };

    function add(generate, addend) {
      if (addend === 0) {
        return generate;
      } else {
        return function (engine) {
          return generate(engine) + addend;
        };
      }
    }

    Random.integer = function () {
      function isPowerOfTwoMinusOne(value) {
        return (value + 1 & value) === 0;
      }

      function bitmask(masking) {
        return function (engine) {
          return engine() & masking;
        };
      }

      function downscaleToLoopCheckedRange(range) {
        var extendedRange = range + 1;
        var maximum = extendedRange * Math.floor(0x100000000 / extendedRange);
        return function (engine) {
          var value = 0;
          do {
            value = engine() >>> 0;
          } while (value >= maximum);
          return value % extendedRange;
        };
      }

      function downscaleToRange(range) {
        if (isPowerOfTwoMinusOne(range)) {
          return bitmask(range);
        } else {
          return downscaleToLoopCheckedRange(range);
        }
      }

      function isEvenlyDivisibleByMaxInt32(value) {
        return (value | 0) === 0;
      }

      function upscaleWithHighMasking(masking) {
        return function (engine) {
          var high = engine() & masking;
          var low = engine() >>> 0;
          return high * 0x100000000 + low;
        };
      }

      function upscaleToLoopCheckedRange(extendedRange) {
        var maximum = extendedRange * Math.floor(0x20000000000000 / extendedRange);
        return function (engine) {
          var ret = 0;
          do {
            var high = engine() & 0x1fffff;
            var low = engine() >>> 0;
            ret = high * 0x100000000 + low;
          } while (ret >= maximum);
          return ret % extendedRange;
        };
      }

      function upscaleWithinU53(range) {
        var extendedRange = range + 1;
        if (isEvenlyDivisibleByMaxInt32(extendedRange)) {
          var highRange = (extendedRange / 0x100000000 | 0) - 1;
          if (isPowerOfTwoMinusOne(highRange)) {
            return upscaleWithHighMasking(highRange);
          }
        }
        return upscaleToLoopCheckedRange(extendedRange);
      }

      function upscaleWithinI53AndLoopCheck(min, max) {
        return function (engine) {
          var ret = 0;
          do {
            var high = engine() | 0;
            var low = engine() >>> 0;
            ret = (high & 0x1fffff) * 0x100000000 + low + (high & 0x200000 ? -0x20000000000000 : 0);
          } while (ret < min || ret > max);
          return ret;
        };
      }

      return function (min, max) {
        min = Math.floor(min);
        max = Math.floor(max);
        if (min < -0x20000000000000 || !isFinite(min)) {
          throw new RangeError("Expected min to be at least " + -0x20000000000000);
        } else if (max > 0x20000000000000 || !isFinite(max)) {
          throw new RangeError("Expected max to be at most " + 0x20000000000000);
        }

        var range = max - min;
        if (range <= 0 || !isFinite(range)) {
          return returnValue(min);
        } else if (range === 0xffffffff) {
          if (min === 0) {
            return Random.uint32;
          } else {
            return add(Random.int32, min + 0x80000000);
          }
        } else if (range < 0xffffffff) {
          return add(downscaleToRange(range), min);
        } else if (range === 0x1fffffffffffff) {
          return add(Random.uint53, min);
        } else if (range < 0x1fffffffffffff) {
          return add(upscaleWithinU53(range), min);
        } else if (max - 1 - min === 0x1fffffffffffff) {
          return add(Random.uint53Full, min);
        } else if (min === -0x20000000000000 && max === 0x20000000000000) {
          return Random.int53Full;
        } else if (min === -0x20000000000000 && max === 0x1fffffffffffff) {
          return Random.int53;
        } else if (min === -0x1fffffffffffff && max === 0x20000000000000) {
          return add(Random.int53, 1);
        } else if (max === 0x20000000000000) {
          return add(upscaleWithinI53AndLoopCheck(min - 1, max - 1), 1);
        } else {
          return upscaleWithinI53AndLoopCheck(min, max);
        }
      };
    }();
    proto.integer = function (min, max) {
      return Random.integer(min, max)(this.engine);
    };

    // [0, 1] (floating point)
    Random.realZeroToOneInclusive = function (engine) {
      return Random.uint53Full(engine) / 0x20000000000000;
    };
    proto.realZeroToOneInclusive = function () {
      return Random.realZeroToOneInclusive(this.engine);
    };

    // [0, 1) (floating point)
    Random.realZeroToOneExclusive = function (engine) {
      return Random.uint53(engine) / 0x20000000000000;
    };
    proto.realZeroToOneExclusive = function () {
      return Random.realZeroToOneExclusive(this.engine);
    };

    Random.real = function () {
      function multiply(generate, multiplier) {
        if (multiplier === 1) {
          return generate;
        } else if (multiplier === 0) {
          return function () {
            return 0;
          };
        } else {
          return function (engine) {
            return generate(engine) * multiplier;
          };
        }
      }

      return function (left, right, inclusive) {
        if (!isFinite(left)) {
          throw new RangeError("Expected left to be a finite number");
        } else if (!isFinite(right)) {
          throw new RangeError("Expected right to be a finite number");
        }
        return add(multiply(inclusive ? Random.realZeroToOneInclusive : Random.realZeroToOneExclusive, right - left), left);
      };
    }();
    proto.real = function (min, max, inclusive) {
      return Random.real(min, max, inclusive)(this.engine);
    };

    Random.bool = function () {
      function isLeastBitTrue(engine) {
        return (engine() & 1) === 1;
      }

      function lessThan(generate, value) {
        return function (engine) {
          return generate(engine) < value;
        };
      }

      function probability(percentage) {
        if (percentage <= 0) {
          return returnValue(false);
        } else if (percentage >= 1) {
          return returnValue(true);
        } else {
          var scaled = percentage * 0x100000000;
          if (scaled % 1 === 0) {
            return lessThan(Random.int32, scaled - 0x80000000 | 0);
          } else {
            return lessThan(Random.uint53, Math.round(percentage * 0x20000000000000));
          }
        }
      }

      return function (numerator, denominator) {
        if (denominator == null) {
          if (numerator == null) {
            return isLeastBitTrue;
          }
          return probability(numerator);
        } else {
          if (numerator <= 0) {
            return returnValue(false);
          } else if (numerator >= denominator) {
            return returnValue(true);
          }
          return lessThan(Random.integer(0, denominator - 1), numerator);
        }
      };
    }();
    proto.bool = function (numerator, denominator) {
      return Random.bool(numerator, denominator)(this.engine);
    };

    function toInteger(value) {
      var number = +value;
      if (number < 0) {
        return Math.ceil(number);
      } else {
        return Math.floor(number);
      }
    }

    function convertSliceArgument(value, length) {
      if (value < 0) {
        return Math.max(value + length, 0);
      } else {
        return Math.min(value, length);
      }
    }
    Random.pick = function (engine, array, begin, end) {
      var length = array.length;
      var start = begin == null ? 0 : convertSliceArgument(toInteger(begin), length);
      var finish = end === void 0 ? length : convertSliceArgument(toInteger(end), length);
      if (start >= finish) {
        return void 0;
      }
      var distribution = Random.integer(start, finish - 1);
      return array[distribution(engine)];
    };
    proto.pick = function (array, begin, end) {
      return Random.pick(this.engine, array, begin, end);
    };

    function returnUndefined() {
      return void 0;
    }
    var slice = Array.prototype.slice;
    Random.picker = function (array, begin, end) {
      var clone = slice.call(array, begin, end);
      if (!clone.length) {
        return returnUndefined;
      }
      var distribution = Random.integer(0, clone.length - 1);
      return function (engine) {
        return clone[distribution(engine)];
      };
    };

    Random.shuffle = function (engine, array, downTo) {
      var length = array.length;
      if (length) {
        if (downTo == null) {
          downTo = 0;
        }
        for (var i = length - 1 >>> 0; i > downTo; --i) {
          var distribution = Random.integer(0, i);
          var j = distribution(engine);
          if (i !== j) {
            var tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
          }
        }
      }
      return array;
    };
    proto.shuffle = function (array) {
      return Random.shuffle(this.engine, array);
    };

    Random.sample = function (engine, population, sampleSize) {
      if (sampleSize < 0 || sampleSize > population.length || !isFinite(sampleSize)) {
        throw new RangeError("Expected sampleSize to be within 0 and the length of the population");
      }

      if (sampleSize === 0) {
        return [];
      }

      var clone = slice.call(population);
      var length = clone.length;
      if (length === sampleSize) {
        return Random.shuffle(engine, clone, 0);
      }
      var tailLength = length - sampleSize;
      return Random.shuffle(engine, clone, tailLength - 1).slice(tailLength);
    };
    proto.sample = function (population, sampleSize) {
      return Random.sample(this.engine, population, sampleSize);
    };

    Random.die = function (sideCount) {
      return Random.integer(1, sideCount);
    };
    proto.die = function (sideCount) {
      return Random.die(sideCount)(this.engine);
    };

    Random.dice = function (sideCount, dieCount) {
      var distribution = Random.die(sideCount);
      return function (engine) {
        var result = [];
        result.length = dieCount;
        for (var i = 0; i < dieCount; ++i) {
          result[i] = distribution(engine);
        }
        return result;
      };
    };
    proto.dice = function (sideCount, dieCount) {
      return Random.dice(sideCount, dieCount)(this.engine);
    };

    // http://en.wikipedia.org/wiki/Universally_unique_identifier
    Random.uuid4 = function () {
      function zeroPad(string, zeroCount) {
        return stringRepeat("0", zeroCount - string.length) + string;
      }

      return function (engine) {
        var a = engine() >>> 0;
        var b = engine() | 0;
        var c = engine() | 0;
        var d = engine() >>> 0;

        return zeroPad(a.toString(16), 8) + "-" + zeroPad((b & 0xffff).toString(16), 4) + "-" + zeroPad((b >> 4 & 0x0fff | 0x4000).toString(16), 4) + "-" + zeroPad((c & 0x3fff | 0x8000).toString(16), 4) + "-" + zeroPad((c >> 4 & 0xffff).toString(16), 4) + zeroPad(d.toString(16), 8);
      };
    }();
    proto.uuid4 = function () {
      return Random.uuid4(this.engine);
    };

    Random.string = function () {
      // has 2**x chars, for faster uniform distribution
      var DEFAULT_STRING_POOL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";

      return function (pool) {
        if (pool == null) {
          pool = DEFAULT_STRING_POOL;
        }

        var length = pool.length;
        if (!length) {
          throw new Error("Expected pool not to be an empty string");
        }

        var distribution = Random.integer(0, length - 1);
        return function (engine, length) {
          var result = "";
          for (var i = 0; i < length; ++i) {
            var j = distribution(engine);
            result += pool.charAt(j);
          }
          return result;
        };
      };
    }();
    proto.string = function (length, pool) {
      return Random.string(pool)(this.engine, length);
    };

    Random.hex = function () {
      var LOWER_HEX_POOL = "0123456789abcdef";
      var lowerHex = Random.string(LOWER_HEX_POOL);
      var upperHex = Random.string(LOWER_HEX_POOL.toUpperCase());

      return function (upper) {
        if (upper) {
          return upperHex;
        } else {
          return lowerHex;
        }
      };
    }();
    proto.hex = function (length, upper) {
      return Random.hex(upper)(this.engine, length);
    };

    Random.date = function (start, end) {
      if (!(start instanceof Date)) {
        throw new TypeError("Expected start to be a Date, got " + typeof start);
      } else if (!(end instanceof Date)) {
        throw new TypeError("Expected end to be a Date, got " + typeof end);
      }
      var distribution = Random.integer(start.getTime(), end.getTime());
      return function (engine) {
        return new Date(distribution(engine));
      };
    };
    proto.date = function (start, end) {
      return Random.date(start, end)(this.engine);
    };

    if (typeof undefined === "function" && define.amd) {
      define(function () {
        return Random;
      });
    } else if (typeof module !== "undefined" && typeof $__require === "function") {
      module.exports = Random;
    } else {
      (function () {
        var oldGlobal = root[GLOBAL_KEY];
        Random.noConflict = function () {
          root[GLOBAL_KEY] = oldGlobal;
          return this;
        };
      })();
      root[GLOBAL_KEY] = Random;
    }
  })(this);
});
$__System.registerDynamic("f2", ["f1"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("f1");
});
$__System.registerDynamic('f3', ['f2'], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  /* Prob.js 1.0.6 (c) 2016 Google, Inc. License: Apache 2.0 */
  // Copyright 2016 Google Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  //
  ////////////////////////////////////////////////////////////////////////////////

  var global = this || self,
      GLOBAL = global;
  (function () {
    'use strict';

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.

    var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this;

    var Prob = {};

    // Export the Prob object for **Node.js**, with backwards-compatibility for
    // their old module API. If we're in the browser, add `Prob` as a global object.
    // (`nodeType` is checked to ensure that `module` and `exports` are not HTML elements.)
    if (typeof exports !== 'undefined' && !exports.nodeType) {
      if (typeof module !== 'undefined' && !module.nodeType && module.exports) {
        exports = module.exports = Prob;
      }
      exports.Prob = Prob;
    } else {
      root.Prob = Prob;
    }

    // Taken from http://stackoverflow.com/a/15313435/88646
    function assert(condition, message) {
      if (!condition) {
        message = message || 'Assertion failed';
        if (typeof Error !== 'undefined') {
          throw new Error(message);
        }
        throw message; // Fallback
      }
    }

    // TODO Remove the dependency on Random JS
    var Random = root.Random || (typeof $__require === 'function' ? $__require('f2') : null);
    if (Random === null) {
      throw 'random-js is required https://github.com/ckknight/random-js';
    }

    var mt = Random.engines.mt19937().autoSeed(); // Fallback generator when one isn't specified
    var rand01 = Random.real(0, 1, false); // [0,1)
    var rand11 = Random.real(-1, 1, true); // [-1,1]

    Prob.Type = {
      UNKNOWN: 0,
      CONTINUOUS: 1,
      DISCRETE: 2
    };

    // Returns floats uniformly distributed between min (inclusive) and max (exclusive).
    Prob.uniform = function (min, max) {
      min = typeof min !== 'undefined' ? min : 0.0;
      max = typeof max !== 'undefined' ? max : 1.0;

      var range = max - min;
      var f = function (rand) {
        return min + rand01(rand || mt) * range;
      };
      f.Min = min;
      f.Max = max;
      f.Mean = min + range / 2;
      f.Variance = (max - min) * (max - min) / 12;
      f.Type = Prob.Type.CONTINUOUS;
      return f;
    };

    // Returns floats random chosen from a normal disribution.
    Prob.normal = function (mean, sd) {
      mean = typeof mean !== 'undefined' ? mean : 0.0;
      sd = typeof sd !== 'undefined' ? sd : 1.0;

      var y1 = null;
      var y2 = null;
      var f = function (rand) {
        if (y2 !== null) {
          y1 = y2;
          y2 = null;
          return y1 * sd + mean;
        }
        var x1;
        var x2;
        var w;

        do {
          x1 = rand11(rand || mt);
          x2 = rand11(rand || mt);
          w = x1 * x1 + x2 * x2;
        } while (w >= 1.0 || w === 0.0);

        w = Math.sqrt(-2.0 * Math.log(w) / w);
        y1 = x1 * w;
        y2 = x2 * w;
        return y1 * sd + mean;
      };
      f.Min = Number.NEGATIVE_INFINITY;
      f.Max = Number.POSITIVE_INFINITY;
      f.Mean = mean;
      f.Variance = sd * sd;
      f.Type = Prob.Type.CONTINUOUS;
      return f;
    };

    // Returns floats random chosen from a exponential disribution.
    Prob.exponential = function (lambda) {
      lambda = typeof lambda !== 'undefined' ? lambda : 1.0;
      var mean = 1 / lambda;

      var f = function (rand) {
        return -1 * Math.log(rand01(rand || mt)) * mean;
      };
      f.Min = 0;
      f.Max = Number.POSITIVE_INFINITY;
      f.Mean = mean;
      f.Variance = Math.pow(lambda, -2);
      f.Type = Prob.Type.CONTINUOUS;
      return f;
    };

    // Returns floats random chosen from a lognormal disribution.
    Prob.lognormal = function (mu, sigma) {
      mu = typeof mu !== 'undefined' ? mu : 0;
      sigma = typeof sigma !== 'undefined' ? sigma : 1.0;

      var nf = Prob.normal(mu, sigma);
      var f = function (rand) {
        return Math.exp(nf(rand));
      };

      f.Min = 0;
      f.Max = Number.POSITIVE_INFINITY;
      f.Mean = Math.exp(mu + sigma * sigma / 2);
      f.Variance = (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
      f.Type = Prob.Type.CONTINUOUS;
      return f;
    };

    // Returns int random chosen from a poisson disribution.
    Prob.poisson = function (lambda) {
      lambda = typeof lambda !== 'undefined' ? lambda : 1;

      // Knuth's algorithm
      var L = Math.exp(-lambda);

      var f = function (rand) {
        var k = 0;
        var p = 1;
        while (true) {
          p = p * rand01(rand || mt); // BUG: This should be [0,1] not [0,1)
          if (p <= L) {
            break;
          }
          k++;
        }
        return k;
      };
      f.Min = 0;
      f.Max = Number.POSITIVE_INFINITY;
      f.Mean = lambda;
      f.Variance = lambda;
      f.Type = Prob.Type.DISCRETE;
      return f;
    };

    function binarySearch(arr, needle) {
      var high = arr.length;
      var low = -1;

      while (high - low > 1) {
        var mid = Math.floor(low + (high - low) / 2);
        if (arr[mid] < needle) {
          low = mid;
        } else {
          high = mid;
        }
      }

      return high;
    }

    // Returns integers random chosen from a zipf disribution.
    Prob.zipf = function (s, N) {
      // We use a inverse CDF approach. We calculate the CDF for
      // the zipf function, then generate a uniform random number in the range [0,1).
      // A binary search of the CDF used to find the value which maps to that random number.
      //
      s = typeof s !== 'undefined' ? s : 1;
      N = typeof N !== 'undefined' ? N : 100;

      assert(N >= 1, 'N must be >= 1');

      // TODO Consider moving the cdf generating code into a seperate function

      var sum = 0.0;
      for (var i = 1; i <= N; i++) {
        sum = sum + 1.0 / Math.pow(i, s);
      }

      var cdf = [0];
      var sumProb = 0;
      for (i = 1; i <= N; i++) {
        sumProb += 1.0 / (sum * Math.pow(i, s));
        cdf[i] = sumProb;
      }

      var f = function (rand) {
        return binarySearch(cdf, rand01(rand || mt));
      };

      f.Min = 1;
      f.Max = N + 1;
      f.Mean = null; // TODO
      f.Variance = null; // TODO
      f.Type = Prob.Type.DISCRETE;
      return f;
    };

    if (typeof undefined === 'function' && define.amd) {
      define('prob', [], function () {
        return Prob;
      });
    }
  })();
});
$__System.registerDynamic("f4", ["f3"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("f3");
});
$__System.registerDynamic("f5", ["f6", "e7", "f4"], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pool = exports.KaplanSniperAgent = exports.MidpointAgent = exports.OneupmanshipAgent = exports.UnitAgent = exports.ZIAgent = exports.HoarderAgent = exports.TruthfulAgent = exports.Trader = exports.Agent = undefined;
  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);
      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === undefined) {
        return undefined;
      }
      return getter.call(receiver);
    }
  };
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _clone = $__require("f6");
  var _clone2 = _interopRequireDefault(_clone);
  var _events = $__require("e7");
  var _prob = $__require("f4");
  var ProbJS = _interopRequireWildcard(_prob);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var privateNextId = 1;
  function nextId() {
    return privateNextId++;
  }
  function sum(a) {
    var i = void 0,
        l = void 0,
        total = 0;
    for (i = 0, l = a.length; i < l; ++i) {
      total += a[i];
    }
    return total;
  }
  function dot(a, b) {
    var i = void 0,
        l = void 0,
        total = 0;
    if (a.length !== b.length) throw new Error("market-agents: vector dimensions do not match in dot(a,b)");
    for (i = 0, l = a.length; i < l; ++i) {
      if (b[i]) total += a[i] * b[i];
    }
    return total;
  }
  function poissonWake() {
    var delta = ProbJS.exponential(this.rate)();
    var result = this.wakeTime + delta;
    if (result > 0) return result;
  }
  var Agent = exports.Agent = function (_EventEmitter) {
    _inherits(Agent, _EventEmitter);
    function Agent(options) {
      _classCallCheck(this, Agent);
      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Agent).call(this));
      var defaults = {
        id: nextId(),
        description: 'blank agent',
        inventory: {},
        money: 'money',
        values: {},
        costs: {},
        wakeTime: 0,
        rate: 1,
        period: {
          number: 0,
          duration: 1000,
          equalDuration: true
        },
        nextWake: poissonWake
      };
      Object.assign(_this, defaults, (0, _clone2.default)(options, false));
      _this.init();
      return _this;
    }
    _createClass(Agent, [{
      key: 'init',
      value: function init(newSettings) {
        if ((typeof newSettings === 'undefined' ? 'undefined' : _typeof(newSettings)) === 'object') {
          var mySettings = Object.assign({}, newSettings);
          Object.assign(this.inventory, mySettings.inventory);
          delete mySettings.inventory;
          Object.assign(this, mySettings);
        }
        if (this.money && !this.inventory[this.money]) this.inventory[this.money] = 0;
        this.wakeTime = this.nextWake();
      }
    }, {
      key: 'initPeriod',
      value: function initPeriod(period) {
        if ((typeof period === 'undefined' ? 'undefined' : _typeof(period)) === 'object') this.period = (0, _clone2.default)(period, false);else if (typeof period === 'number') this.period.number = period;
        if (this.period.equalDuration && this.period.duration) {
          this.period.startTime = this.period.number * this.period.duration;
          this.period.endTime = (1 + this.period.number) * this.period.duration;
        }
        if (typeof this.period.startTime === 'number') this.wakeTime = this.period.startTime;
        this.init(this.period.init);
        this.emit('pre-period');
      }
    }, {
      key: 'endPeriod',
      value: function endPeriod() {
        if (typeof this.produce === 'function') this.produce();
        if (typeof this.redeem === 'function') this.redeem();
        this.emit('post-period');
      }
    }, {
      key: 'pctPeriod',
      value: function pctPeriod() {
        if (this.period.startTime !== undefined && this.period.endTime > 0 && this.wakeTime !== undefined) {
          return (this.wakeTime - this.period.startTime) / (this.period.endTime - this.period.startTime);
        }
      }
    }, {
      key: 'poissonWakesRemainingInPeriod',
      value: function poissonWakesRemainingInPeriod() {
        if (this.rate > 0 && this.wakeTime !== undefined && this.period.endTime > 0) {
          return (this.period.endTime - this.wakeTime) * this.rate;
        }
      }
    }, {
      key: 'wake',
      value: function wake(info) {
        this.emit('wake', info);
        var nextTime = this.nextWake();
        if (this.period.endTime) {
          if (nextTime < this.period.endTime) this.wakeTime = nextTime;else this.wakeTime = undefined;
        } else {
          this.wakeTime = nextTime;
        }
      }
    }, {
      key: 'transfer',
      value: function transfer(myTransfers, memo) {
        if (myTransfers) {
          this.emit('pre-transfer', myTransfers, memo);
          var goods = Object.keys(myTransfers);
          for (var i = 0, l = goods.length; i < l; ++i) {
            if (this.inventory[goods[i]]) this.inventory[goods[i]] += myTransfers[goods[i]];else this.inventory[goods[i]] = myTransfers[goods[i]];
          }
          this.emit('post-transfer', myTransfers, memo);
        }
      }
    }, {
      key: 'unitCostFunction',
      value: function unitCostFunction(good, hypotheticalInventory) {
        var costs = this.costs[good];
        if (Array.isArray(costs) && hypotheticalInventory[good] <= 0) {
          return costs[-hypotheticalInventory[good]];
        }
      }
    }, {
      key: 'unitValueFunction',
      value: function unitValueFunction(good, hypotheticalInventory) {
        var vals = this.values[good];
        if (Array.isArray(vals) && hypotheticalInventory[good] >= 0) {
          return vals[hypotheticalInventory[good]];
        }
      }
    }, {
      key: 'redeem',
      value: function redeem() {
        if (this.values) {
          var trans = {};
          var goods = Object.keys(this.values);
          trans[this.money] = 0;
          for (var i = 0, l = goods.length; i < l; ++i) {
            var g = goods[i];
            if (this.inventory[g] > 0) {
              trans[g] = -this.inventory[g];
              trans[this.money] += sum(this.values[g].slice(0, this.inventory[g]));
            }
          }
          this.emit('pre-redeem', trans);
          this.transfer(trans, { isRedeem: 1 });
          this.emit('post-redeem', trans);
        }
      }
    }, {
      key: 'produce',
      value: function produce() {
        if (this.costs) {
          var trans = {};
          var goods = Object.keys(this.costs);
          trans[this.money] = 0;
          for (var i = 0, l = goods.length; i < l; ++i) {
            var g = goods[i];
            if (this.inventory[g] < 0) {
              trans[this.money] -= sum(this.costs[g].slice(0, -this.inventory[g]));
              trans[g] = -this.inventory[g];
            }
          }
          this.emit('pre-produce', trans);
          this.transfer(trans, { isProduce: 1 });
          this.emit('post-produce', trans);
        }
      }
    }]);
    return Agent;
  }(_events.EventEmitter);
  var Trader = exports.Trader = function (_Agent) {
    _inherits(Trader, _Agent);
    function Trader(options) {
      _classCallCheck(this, Trader);
      var defaults = {
        description: 'Trader',
        markets: [],
        minPrice: 0,
        maxPrice: 1000
      };
      var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Trader).call(this, Object.assign({}, defaults, options)));
      _this2.on('wake', _this2.sendBidsAndAsks);
      return _this2;
    }
    _createClass(Trader, [{
      key: 'bid',
      value: function bid(market, myPrice) {
        throw new Error("called placeholder for abstract method .bid(market,myPrice) -- you must implement this method");
      }
    }, {
      key: 'ask',
      value: function ask(market, myPrice) {
        throw new Error("called placeholder for abstract method .ask(market,myPrice) -- you must implement this method");
      }
    }, {
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        throw new Error("called placeholder for abstract method .bidPrice(marginalValue, market) -- you must implement this method");
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost, market) {
        throw new Error("called placeholder for abstract method .bidPrice(marginalValue, market) -- you must implement this method");
      }
    }, {
      key: 'sendBidsAndAsks',
      value: function sendBidsAndAsks() {
        for (var i = 0, l = this.markets.length; i < l; ++i) {
          var market = this.markets[i];
          var unitValue = this.unitValueFunction(market.goods, this.inventory);
          if (unitValue > 0) {
            if (this.ignoreBudgetConstraint) unitValue = this.maxPrice;
            var myPrice = this.bidPrice(unitValue, market);
            if (myPrice) this.bid(market, myPrice);
          }
          var unitCost = this.unitCostFunction(market.goods, this.inventory);
          if (unitCost > 0) {
            if (this.ignoreBudgetConstraint) unitCost = this.minPrice;
            var _myPrice = this.askPrice(unitCost, market);
            if (_myPrice) this.ask(market, _myPrice);
          }
        }
      }
    }]);
    return Trader;
  }(Agent);
  var TruthfulAgent = exports.TruthfulAgent = function (_Trader) {
    _inherits(TruthfulAgent, _Trader);
    function TruthfulAgent(options) {
      _classCallCheck(this, TruthfulAgent);
      return _possibleConstructorReturn(this, Object.getPrototypeOf(TruthfulAgent).call(this, Object.assign({}, { description: 'Truthful Agent bids=value or asks=cost' }, options)));
    }
    _createClass(TruthfulAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue) {
        if (typeof marginalValue !== 'number') return undefined;
        return this.integer ? Math.floor(marginalValue) : marginalValue;
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost) {
        if (typeof marginalCost !== 'number') return undefined;
        return this.integer ? Math.ceil(marginalCost) : marginalCost;
      }
    }]);
    return TruthfulAgent;
  }(Trader);
  var HoarderAgent = exports.HoarderAgent = function (_Trader2) {
    _inherits(HoarderAgent, _Trader2);
    function HoarderAgent(options) {
      _classCallCheck(this, HoarderAgent);
      return _possibleConstructorReturn(this, Object.getPrototypeOf(HoarderAgent).call(this, Object.assign({}, { description: 'Hoarder Agent always bids the current asking price and never asks' }, options)));
    }
    _createClass(HoarderAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        var currentAskPrice = market.currentAskPrice();
        if (currentAskPrice > 0) return currentAskPrice;
      }
    }, {
      key: 'askPrice',
      value: function askPrice() {
        return undefined;
      }
    }]);
    return HoarderAgent;
  }(Trader);
  var ZIAgent = exports.ZIAgent = function (_Trader3) {
    _inherits(ZIAgent, _Trader3);
    function ZIAgent(options) {
      _classCallCheck(this, ZIAgent);
      return _possibleConstructorReturn(this, Object.getPrototypeOf(ZIAgent).call(this, Object.assign({}, { description: 'Gode and Sunder Style ZI Agent' }, options)));
    }
    _createClass(ZIAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue) {
        if (typeof marginalValue !== 'number') return undefined;
        var p = void 0;
        if (marginalValue === this.minPrice) return marginalValue;
        if (marginalValue < this.minPrice) return undefined;
        if (this.integer) {
          do {
            p = Math.floor(ProbJS.uniform(this.minPrice, marginalValue + 1)());
          } while (p > marginalValue);
        } else {
          p = ProbJS.uniform(this.minPrice, marginalValue)();
        }
        return p;
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost) {
        if (typeof marginalCost !== 'number') return undefined;
        var p = void 0;
        if (marginalCost === this.maxPrice) return marginalCost;
        if (marginalCost > this.maxPrice) return undefined;
        if (this.integer) {
          do {
            p = Math.floor(ProbJS.uniform(marginalCost, this.maxPrice + 1)());
          } while (p > this.maxPrice);
        } else {
          p = ProbJS.uniform(marginalCost, this.maxPrice)();
        }
        return p;
      }
    }]);
    return ZIAgent;
  }(Trader);
  var um1p2 = ProbJS.uniform(-1, 2);
  var um1p1 = ProbJS.uniform(-1, 1);
  var UnitAgent = exports.UnitAgent = function (_ZIAgent) {
    _inherits(UnitAgent, _ZIAgent);
    function UnitAgent(options) {
      _classCallCheck(this, UnitAgent);
      var defaults = { description: "Paul Brewer's UNIT agent that bids/asks within 1 price unit of previous price" };
      return _possibleConstructorReturn(this, Object.getPrototypeOf(UnitAgent).call(this, Object.assign({}, defaults, options)));
    }
    _createClass(UnitAgent, [{
      key: 'randomDelta',
      value: function randomDelta() {
        var delta = void 0;
        if (this.integer) {
          do {
            delta = Math.floor(um1p2());
          } while (delta <= -2 || delta >= 2.0);
        } else {
          do {
            delta = um1p1();
          } while (delta < -1 || delta > 1);
        }
        return delta;
      }
    }, {
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        var p = void 0;
        if (typeof marginalValue !== 'number') return undefined;
        var previous = market.lastTradePrice();
        if (previous) p = previous + this.randomDelta();else p = _get(Object.getPrototypeOf(UnitAgent.prototype), 'bidPrice', this).call(this, marginalValue);
        if (p > marginalValue || p > this.maxPrice || p < this.minPrice) return undefined;
        return p && this.integer ? Math.floor(p) : p;
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost, market) {
        if (typeof marginalCost !== 'number') return undefined;
        var p = void 0;
        var previous = market.lastTradePrice();
        if (previous) p = previous + this.randomDelta();else p = _get(Object.getPrototypeOf(UnitAgent.prototype), 'askPrice', this).call(this, marginalCost);
        if (p < marginalCost || p > this.maxPrice || p < this.minPrice) return undefined;
        return p && this.integer ? Math.floor(p) : p;
      }
    }]);
    return UnitAgent;
  }(ZIAgent);
  var OneupmanshipAgent = exports.OneupmanshipAgent = function (_Trader4) {
    _inherits(OneupmanshipAgent, _Trader4);
    function OneupmanshipAgent(options) {
      _classCallCheck(this, OneupmanshipAgent);
      var defaults = { description: "Brewer's OneupmanshipAgent that increases the market bid or decreases the market ask by one price unit, if profitable to do so according to MV or MC" };
      return _possibleConstructorReturn(this, Object.getPrototypeOf(OneupmanshipAgent).call(this, Object.assign({}, defaults, options)));
    }
    _createClass(OneupmanshipAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        if (typeof marginalValue !== 'number') return undefined;
        var currentBid = market.currentBidPrice();
        if (!currentBid) return this.minPrice;
        if (currentBid < marginalValue - 1) return currentBid + 1;
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost, market) {
        if (typeof marginalCost !== 'number') return undefined;
        var currentAsk = market.currentAskPrice();
        if (!currentAsk) return this.maxPrice;
        if (currentAsk > marginalCost + 1) return currentAsk - 1;
      }
    }]);
    return OneupmanshipAgent;
  }(Trader);
  var MidpointAgent = exports.MidpointAgent = function (_Trader5) {
    _inherits(MidpointAgent, _Trader5);
    function MidpointAgent(options) {
      _classCallCheck(this, MidpointAgent);
      var defaults = { description: "Brewer's MidpointAgent bids/asks halfway between the bid and ask, if profitable to do according to MC or MV" };
      return _possibleConstructorReturn(this, Object.getPrototypeOf(MidpointAgent).call(this, Object.assign({}, defaults, options)));
    }
    _createClass(MidpointAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        if (typeof marginalValue !== 'number') return undefined;
        var currentBid = market.currentBidPrice();
        if (!currentBid) return this.minPrice <= marginalValue ? this.minPrice : undefined;
        var currentAsk = market.currentAskPrice();
        if (currentAsk) {
          var midpoint = (currentBid + currentAsk) / 2;
          var myBid = this.integer ? Math.ceil(midpoint) : midpoint;
          if (myBid <= marginalValue) return myBid;
        }
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost, market) {
        if (typeof marginalCost !== 'number') return undefined;
        var currentAsk = market.currentAskPrice();
        if (!currentAsk) return this.maxPrice >= marginalCost ? this.maxPrice : undefined;
        var currentBid = market.currentBidPrice();
        if (currentBid) {
          var midpoint = (currentBid + currentAsk) / 2;
          var myAsk = this.integer ? Math.floor(midpoint) : midpoint;
          if (myAsk >= marginalCost) return myAsk;
        }
      }
    }]);
    return MidpointAgent;
  }(Trader);
  var KaplanSniperAgent = exports.KaplanSniperAgent = function (_Trader6) {
    _inherits(KaplanSniperAgent, _Trader6);
    function KaplanSniperAgent(options) {
      _classCallCheck(this, KaplanSniperAgent);
      var defaults = {
        description: "Kaplan's snipers, trade on 'juicy' price, or low spread, or end of period",
        desiredSpread: 10
      };
      return _possibleConstructorReturn(this, Object.getPrototypeOf(KaplanSniperAgent).call(this, Object.assign({}, defaults, options)));
    }
    _createClass(KaplanSniperAgent, [{
      key: 'bidPrice',
      value: function bidPrice(marginalValue, market) {
        if (typeof marginalValue !== 'number') return undefined;
        var currentBid = market.currentBidPrice();
        var currentAsk = market.currentAskPrice();
        if (currentAsk <= marginalValue) {
          var juicyPrice = this.getJuicyAskPrice();
          if (juicyPrice > 0 && currentAsk <= juicyPrice) return currentAsk;
          if (currentAsk > 0 && currentBid > 0 && currentAsk - currentBid <= this.desiredSpread) return currentAsk;
          if (this.poissonWakesRemainingInPeriod() <= 3) return currentAsk;
        }
      }
    }, {
      key: 'askPrice',
      value: function askPrice(marginalCost, market) {
        if (typeof marginalCost !== 'number') return undefined;
        var currentBid = market.currentBidPrice();
        var currentAsk = market.currentAskPrice();
        if (currentBid >= marginalCost) {
          var juicyPrice = this.getJuicyBidPrice();
          if (juicyPrice > 0 && currentBid >= juicyPrice) return currentBid;
          if (currentAsk > 0 && currentBid > 0 && currentAsk - currentBid <= this.desiredSpread) return currentBid;
          if (this.poissonWakesRemainingInPeriod() <= 3) return currentBid;
        }
      }
    }]);
    return KaplanSniperAgent;
  }(Trader);
  var Pool = exports.Pool = function () {
    function Pool() {
      _classCallCheck(this, Pool);
      this.agents = [];
      this.agentsById = {};
    }
    _createClass(Pool, [{
      key: 'push',
      value: function push(agent) {
        if (!(agent instanceof Agent)) throw new Error("Pool.push(agent), agent is not an instance of Agent or descendents");
        if (!this.agentsById[agent.id]) {
          this.agents.push(agent);
          this.agentsById[agent.id] = agent;
        }
      }
    }, {
      key: 'next',
      value: function next() {
        if (this.nextCache) return this.nextCache;
        var tMin = 1e20,
            i = 0,
            l = this.agents.length,
            A = this.agents,
            t = 0,
            result = 0;
        for (; i < l; i++) {
          t = A[i].wakeTime;
          if (t > 0 && t < tMin) {
            result = A[i];
            tMin = t;
          }
        }
        this.nextCache = result;
        return result;
      }
    }, {
      key: 'wake',
      value: function wake() {
        var A = this.next();
        if (A) {
          A.wake();
          delete this.nextCache;
        }
      }
    }, {
      key: 'endTime',
      value: function endTime() {
        var endTime = 0;
        for (var i = 0, l = this.agents.length; i < l; ++i) {
          var a = this.agents[i];
          if (a.period.endTime > endTime) endTime = a.period.endTime;
        }
        if (endTime > 0) return endTime;
      }
    }, {
      key: 'runAsPromise',
      value: function runAsPromise(untilTime, batch) {
        var pool = this;
        return new Promise(function (resolve, reject) {
          function loop() {
            var nextAgent = 0;
            try {
              pool.syncRun(untilTime, batch || 1);
              nextAgent = pool.next();
            } catch (e) {
              return reject(e);
            }
            return nextAgent && nextAgent.wakeTime < untilTime ? setImmediate(loop) : resolve(pool);
          }
          setImmediate(loop);
        });
      }
    }, {
      key: 'syncRun',
      value: function syncRun(untilTime, limitCalls) {
        var nextAgent = this.next();
        var calls = 0;
        while (nextAgent && nextAgent.wakeTime < untilTime && !(calls >= limitCalls)) {
          this.wake();
          nextAgent = this.next();
          calls++;
        }
      }
    }, {
      key: 'initPeriod',
      value: function initPeriod(param) {
        if (Array.isArray(param) && param.length > 0) {
          for (var i = 0, l = this.agents.length; i < l; i++) {
            this.agents[i].initPeriod(param[i % param.length]);
          }
        } else {
          for (var _i = 0, _l = this.agents.length; _i < _l; _i++) {
            this.agents[_i].initPeriod(param);
          }
        }
      }
    }, {
      key: 'endPeriod',
      value: function endPeriod() {
        for (var i = 0, l = this.agents.length; i < l; i++) {
          this.agents[i].endPeriod();
        }
      }
    }, {
      key: 'trade',
      value: function trade(tradeSpec) {
        var i = void 0,
            l = void 0,
            buyerTransfer = void 0,
            sellerTransfer = void 0;
        if ((typeof tradeSpec === 'undefined' ? 'undefined' : _typeof(tradeSpec)) !== 'object') return;
        if (tradeSpec.bs && tradeSpec.goods && tradeSpec.money && Array.isArray(tradeSpec.prices) && Array.isArray(tradeSpec.buyQ) && Array.isArray(tradeSpec.sellQ) && Array.isArray(tradeSpec.buyId) && Array.isArray(tradeSpec.sellId)) {
          if (tradeSpec.bs === 'b') {
            if (tradeSpec.buyId.length !== 1) throw new Error("Pool.trade expected tradeSpec.buyId.length===1, got:" + tradeSpec.buyId.length);
            if (tradeSpec.buyQ[0] !== sum(tradeSpec.sellQ)) throw new Error("Pool.trade invalid buy -- tradeSpec buyQ[0] != sum(sellQ)");
            buyerTransfer = {};
            buyerTransfer[tradeSpec.goods] = tradeSpec.buyQ[0];
            buyerTransfer[tradeSpec.money] = -dot(tradeSpec.sellQ, tradeSpec.prices);
            this.agentsById[tradeSpec.buyId[0]].transfer(buyerTransfer, {
              isTrade: 1,
              isBuy: 1
            });
            for (i = 0, l = tradeSpec.prices.length; i < l; ++i) {
              sellerTransfer = {};
              sellerTransfer[tradeSpec.goods] = -tradeSpec.sellQ[i];
              sellerTransfer[tradeSpec.money] = tradeSpec.prices[i] * tradeSpec.sellQ[i];
              this.agentsById[tradeSpec.sellId[i]].transfer(sellerTransfer, {
                isTrade: 1,
                isSellAccepted: 1
              });
            }
          } else if (tradeSpec.bs === 's') {
            if (tradeSpec.sellId.length !== 1) throw new Error("Pool.trade expected tradeSpec.sellId.length===1. got:" + tradeSpec.sellId.length);
            if (tradeSpec.sellQ[0] !== sum(tradeSpec.buyQ)) throw new Error("Pool.trade invalid sell -- tradeSpec sellQ[0] != sum(buyQ)");
            sellerTransfer = {};
            sellerTransfer[tradeSpec.goods] = -tradeSpec.sellQ[0];
            sellerTransfer[tradeSpec.money] = dot(tradeSpec.buyQ, tradeSpec.prices);
            this.agentsById[tradeSpec.sellId[0]].transfer(sellerTransfer, {
              isTrade: 1,
              isSell: 1
            });
            for (i = 0, l = tradeSpec.prices.length; i < l; ++i) {
              buyerTransfer = {};
              buyerTransfer[tradeSpec.goods] = tradeSpec.buyQ[i];
              buyerTransfer[tradeSpec.money] = -tradeSpec.prices[i] * tradeSpec.buyQ[i];
              this.agentsById[tradeSpec.buyId[i]].transfer(buyerTransfer, {
                isTrade: 1,
                isBuyAccepted: 1
              });
            }
          }
        }
      }
    }, {
      key: 'distribute',
      value: function distribute(field, good, aggregateArray) {
        var i = void 0,
            l = void 0;
        var myCopy = void 0;
        if (Array.isArray(aggregateArray)) {
          myCopy = aggregateArray.slice();
        } else {
          throw new Error("Error: Pool.prototype.distribute: expected aggregate to be Array, got: " + (typeof aggregateArray === 'undefined' ? 'undefined' : _typeof(aggregateArray)));
        }
        if (field !== 'values' && field !== 'costs') throw new Error("Pool.distribute(field,good,aggArray) field should be 'values' or 'costs', got:" + field);
        for (i = 0, l = this.agents.length; i < l; ++i) {
          if (typeof this.agents[i][field] === 'undefined') this.agents[i][field] = {};
          this.agents[i][field][good] = [];
        }
        i = 0;
        l = this.agents.length;
        while (myCopy.length > 0) {
          this.agents[i][field][good].push(myCopy.shift());
          i = (i + 1) % l;
        }
      }
    }]);
    return Pool;
  }();
});
$__System.registerDynamic("f7", ["f5"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("f5");
});
$__System.registerDynamic("f8", [], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* jshint node:true,esnext:true,eqeqeq:true,undef:true,lastsemic:true,strict:true */

	var toNumber = function (s) {
		return +s;
	};

	var gt0 = function (n) {
		return n > 0;
	};

	module.exports = function (myInput) {
		'use strict';

		if (typeof myInput === "string") return myInput.replace(/^\[/, "").replace(/\]$/, "").replace(/,/g, " ").split(/\s+/).map(toNumber).filter(gt0);
		if (typeof myInput === "number") return myInput > 0 ? [myInput] : [];
		if (Array.isArray(myInput)) return myInput.map(toNumber).filter(gt0);
	};
});
$__System.registerDynamic("e2", ["f8"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("f8");
});
$__System.registerDynamic('f9', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  if ($__System._nodeRequire) {
    module.exports = $__System._nodeRequire('fs');
  } else {

    exports.readFileSync = function (address) {
      var output;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', address, false);
      xhr.onreadystatechange = function (e) {
        if (xhr.readyState == 4) {
          var status = xhr.status;
          if (status > 399 && status < 600 || status == 400) {
            throw 'File read error on ' + address;
          } else output = xhr.responseText;
        }
      };
      xhr.send(null);
      return output;
    };
  }
});
$__System.registerDynamic("fa", ["f9"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("f9");
});
$__System.registerDynamic("fb", ["e5", "f0", "f7", "e2", "fa"], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Simulation = exports.logNames = exports.logHeaders = undefined;
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.agentRegister = agentRegister;
  var _simpleIsomorphicLogger = $__require("e5");
  var _simpleIsomorphicLogger2 = _interopRequireDefault(_simpleIsomorphicLogger);
  var _marketExampleContingent = $__require("f0");
  var MEC = _interopRequireWildcard(_marketExampleContingent);
  var _marketAgents = $__require("f7");
  var MarketAgents = _interopRequireWildcard(_marketAgents);
  var _positiveNumberArray = $__require("e2");
  var _positiveNumberArray2 = _interopRequireDefault(_positiveNumberArray);
  var _fs = $__require("fa");
  var fs = _interopRequireWildcard(_fs);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Market = MEC.Market;
  var Pool = MarketAgents.Pool;
  var AgentFactoryWarehouse = {};
  function newAgentFactory(name, options) {
    return new AgentFactoryWarehouse[name](options);
  }
  function agentRegister(obj) {
    Object.assign(AgentFactoryWarehouse, obj);
  }
  agentRegister(MarketAgents);
  var orderHeader = ['period', 't', 'tp', 'id', 'x', 'buyLimitPrice', 'value', 'sellLimitPrice', 'cost'];
  var logHeaders = exports.logHeaders = {
    ohlc: ['period', 'open', 'high', 'low', 'close'],
    buyorder: orderHeader,
    sellorder: orderHeader,
    rejectbuyorder: orderHeader,
    rejectsellorder: orderHeader,
    trade: ['period', 't', 'tp', 'price', 'buyerAgentId', 'buyerValue', 'buyerProfit', 'sellerAgentId', 'sellerCost', 'sellerProfit'],
    volume: ['period', 'volume'],
    effalloc: ['period', 'efficiencyOfAllocation']
  };
  var logNames = exports.logNames = ['trade', 'buyorder', 'sellorder', 'rejectbuyorder', 'rejectsellorder', 'profit', 'ohlc', 'volume', 'effalloc'];
  var Simulation = exports.Simulation = function () {
    function Simulation(config) {
      _classCallCheck(this, Simulation);
      this.config = config;
      this.initLogs();
      this.initMarket();
      this.initAgents();
      this.period = 0;
      this.periodTradePrices = [];
      if (!this.config.silent) {
        console.log("duration of each period = " + this.periodDuration);
        console.log(" ");
        console.log("Number of Buyers  = " + this.numberOfBuyers);
        console.log("Number of Sellers = " + this.numberOfSellers);
        console.log("Total Number of Agents  = " + this.numberOfAgents);
        console.log(" ");
        console.log("minPrice = " + this.config.L);
        console.log("maxPrice = " + this.config.H);
      }
    }
    _createClass(Simulation, [{
      key: 'initLogs',
      value: function initLogs() {
        var sim = this;
        sim.logs = {};
        var withoutOrderLogs = logNames.filter(function (s) {
          return s.indexOf('order') === -1;
        });
        var actualLogs = sim.config.withoutOrderLogs ? withoutOrderLogs : logNames;
        var logDir = sim.config.logDir || ".";
        var logToFS = sim.config.logToFileSystem;
        actualLogs.forEach(function (name) {
          sim.logs[name] = new _simpleIsomorphicLogger2.default(logDir + "/" + name + ".csv", logToFS).setHeader(logHeaders[name]);
        });
      }
    }, {
      key: 'initMarket',
      value: function initMarket() {
        var sim = this;
        var xDefaults = {
          goods: "X",
          money: "money"
        };
        sim.xMarket = new Market(Object.assign({}, xDefaults, sim.config.xMarket));
        sim.xMarket.on('trade', function (tradespec) {
          sim.logTrade(tradespec);
          sim.pool.trade(tradespec);
        });
        if (!sim.config.withoutOrderLogs) {
          sim.xMarket.on('preorder', function (myorder) {
            sim.logOrder('', myorder);
          });
          sim.xMarket.on('reject', function (myorder) {
            sim.logOrder('reject', myorder);
          });
        }
      }
    }, {
      key: 'initAgents',
      value: function initAgents() {
        var sim = this;
        var config = sim.config;
        sim.pool = new Pool();
        sim.buyersPool = new Pool();
        sim.sellersPool = new Pool();
        sim.numberOfBuyers = config.numberOfBuyers || config.buyerValues.length;
        sim.numberOfSellers = config.numberOfSellers || config.sellerCosts.length;
        config.buyerRate = (0, _positiveNumberArray2.default)(config.buyerRate) || [1];
        config.sellerRate = (0, _positiveNumberArray2.default)(config.sellerRate) || [1];
        if (!sim.numberOfBuyers || !sim.numberOfSellers) throw new Error("single-market-robot-simulation: can not determine numberOfBuyers and/or numberOfSellers ");
        sim.numberOfAgents = sim.numberOfBuyers + sim.numberOfSellers;
        var common = {
          integer: config.integer,
          ignoreBudgetConstraint: config.ignoreBudgetConstraint,
          period: {
            number: 0,
            equalDuration: true,
            duration: config.periodDuration || 1000,
            init: { inventory: {
                X: 0,
                money: 0
              } }
          },
          minPrice: config.L,
          maxPrice: config.H
        };
        sim.periodDuration = common.period.duration;
        for (var i = 0, l = sim.numberOfBuyers; i < l; ++i) {
          var a = sim.newBuyerAgent(i, common);
          sim.buyersPool.push(a);
          sim.pool.push(a);
        }
        for (var _i = 0, _l = sim.numberOfSellers; _i < _l; ++_i) {
          var _a = sim.newSellerAgent(_i, common);
          sim.sellersPool.push(_a);
          sim.pool.push(_a);
        }
        sim.buyersPool.distribute('values', 'X', config.buyerValues);
        sim.sellersPool.distribute('costs', 'X', config.sellerCosts);
      }
    }, {
      key: 'newBuyerAgent',
      value: function newBuyerAgent(i, common) {
        var sim = this;
        var lType = sim.config.buyerAgentType.length;
        var lRate = sim.config.buyerRate.length;
        var a = newAgentFactory(sim.config.buyerAgentType[i % lType], Object.assign({}, common, { rate: sim.config.buyerRate[i % lRate] }));
        sim.teachAgent(a);
        return a;
      }
    }, {
      key: 'newSellerAgent',
      value: function newSellerAgent(i, common) {
        var sim = this;
        var lType = sim.config.sellerAgentType.length;
        var lRate = sim.config.sellerRate.length;
        var a = newAgentFactory(sim.config.sellerAgentType[i % lType], Object.assign({}, common, { rate: sim.config.sellerRate[i % lRate] }));
        sim.teachAgent(a);
        return a;
      }
    }, {
      key: 'teachAgent',
      value: function teachAgent(A) {
        var sim = this;
        A.bid = function (market, price) {
          var order = MEC.oa({
            t: this.wakeTime,
            id: this.id,
            cancel: !sim.config.keepPreviousOrders,
            q: 1,
            buyPrice: price
          });
          if (market.goods === 'X') {
            market.submit(order);
            while (market.process()) {}
          }
        };
        A.ask = function (market, price) {
          var order = MEC.oa({
            t: this.wakeTime,
            id: this.id,
            cancel: !sim.config.keepPreviousOrders,
            q: 1,
            sellPrice: price
          });
          if (market.goods === 'X') {
            market.submit(order);
            while (market.process()) {}
          }
        };
        A.markets = [sim.xMarket];
        if (A instanceof MarketAgents.KaplanSniperAgent) {
          A.getJuicyBidPrice = function () {
            if (sim.logs && sim.logs.ohlc) return sim.logs.ohlc.lastByKey('high');
          };
          A.getJuicyAskPrice = function () {
            if (sim.logs && sim.logs.ohlc) return sim.logs.ohlc.lastByKey('low');
          };
        }
      }
    }, {
      key: 'runPeriod',
      value: function runPeriod(sync) {
        var sim = this;
        function atEndOfPeriod() {
          sim.pool.endPeriod();
          sim.logPeriod();
          return sim;
        }
        sim.period++;
        if (!sim.config.silent) console.log("period: " + sim.period);
        sim.pool.initPeriod(sim.period);
        sim.xMarket.clear();
        if (sync) {
          sim.pool.syncRun(sim.pool.endTime());
          return atEndOfPeriod();
        }
        if (!sim.config.realtime) {
          return sim.pool.runAsPromise(sim.pool.endTime(), 10).then(atEndOfPeriod);
        }
        return new Promise(function (resolve, reject) {
          function onRealtimeWake(endTime) {
            if (!endTime) return reject("period endTime required for onRealtimeWake, got: " + endTime);
            return function () {
              var now = Date.now() / 1000.0 - sim.realtime;
              if (now >= endTime) {
                clearInterval(sim.realtimeIntervalId);
                delete sim.realtimeIntervalId;
                sim.pool.syncRun(endTime);
                return resolve(atEndOfPeriod());
              }
              sim.pool.syncRun(now);
            };
          }
          if (sim.realtimeIntervalId) {
            clearInterval(sim.realtimeIntervalId);
            return reject("sim has unexpected realtimeIntervalId");
          }
          sim.realtime = Date.now() / 1000.0 - sim.pool.agents[0].period.startTime;
          sim.realtimeIntervalId = setInterval(onRealtimeWake(sim.pool.endTime()), 40);
        });
      }
    }, {
      key: 'getMaximumPossibleGainsFromTrade',
      value: function getMaximumPossibleGainsFromTrade() {
        var sim = this;
        if (sim.maximumPossibleGainsFromTrade) return sim.maximumPossibleGainsFromTrade;
        var result = 0;
        if (Array.isArray(sim.config.buyerValues) && Array.isArray(sim.config.sellerCosts)) {
          var buyerV = sim.config.buyerValues.slice().sort(function (a, b) {
            return +b - a;
          });
          var sellerC = sim.config.sellerCosts.slice().sort(function (a, b) {
            return +a - b;
          });
          var i = 0;
          var l = Math.min(buyerV.length, sellerC.length);
          while (i < l && buyerV[i] > sellerC[i]) {
            result += buyerV[i] - sellerC[i];
            ++i;
          }
        }
        sim.maximumPossibleGainsFromTrade = result;
        return result;
      }
    }, {
      key: 'logPeriod',
      value: function logPeriod() {
        var sim = this;
        var finalMoney = sim.pool.agents.map(function (A) {
          return A.inventory.money;
        });
        function ohlc() {
          if (sim.periodTradePrices.length > 0) {
            var o = sim.periodTradePrices[0];
            var c = sim.periodTradePrices[sim.periodTradePrices.length - 1];
            var h = Math.max.apply(Math, _toConsumableArray(sim.periodTradePrices));
            var l = Math.min.apply(Math, _toConsumableArray(sim.periodTradePrices));
            return [sim.period, o, h, l, c];
          }
        }
        if (sim.logs.profit) sim.logs.profit.write(finalMoney);
        if (sim.logs.ohlc) sim.logs.ohlc.write(ohlc());
        if (sim.logs.volume) sim.logs.volume.write([sim.period, sim.periodTradePrices.length]);
        if (sim.logs.effalloc) {
          var finalMoneySum = 0.0;
          for (var i = 0, l = finalMoney.length; i < l; ++i) {
            finalMoneySum += finalMoney[i];
          }
          var maxPossible = sim.getMaximumPossibleGainsFromTrade();
          if (maxPossible > 0) sim.logs.effalloc.write([sim.period, 100 * (finalMoneySum / maxPossible)]);
        }
        sim.periodTradePrices = [];
      }
    }, {
      key: 'logOrder',
      value: function logOrder(prefix, orderArray) {
        var sim = this;
        var order = MEC.ao(orderArray);
        var agent = sim.pool.agentsById[order.id];
        var buyLog = prefix + 'buyorder';
        var sellLog = prefix + 'sellorder';
        if (agent && order.buyPrice && sim.logs[buyLog]) {
          sim.logs[buyLog].write([sim.period, order.t, order.t - sim.period * sim.periodDuration, order.id, agent.inventory.X, order.buyPrice, agent.unitValueFunction('X', agent.inventory), '', '']);
        }
        if (agent && order.sellPrice && sim.logs[sellLog]) {
          sim.logs[sellLog].write([sim.period, order.t, order.t - sim.period * sim.periodDuration, order.id, agent.inventory.X, '', '', order.sellPrice, agent.unitCostFunction('X', agent.inventory)]);
        }
      }
    }, {
      key: 'logTrade',
      value: function logTrade(tradespec) {
        var sim = this;
        var idCol = sim.xMarket.o.idCol;
        if (idCol === undefined) throw new Error("Simulation.prototype.logTrade: sim.xMarket.o.idCol is undefined");
        if (tradespec.totalQ !== 1 || tradespec.buyA.length !== 1 || tradespec.sellA.length !== 1) throw new Error("Simulation.prototype.logTrade: single unit trades required, got: " + tradespec.totalQ);
        var buyerid = sim.xMarket.a[tradespec.buyA[0]][idCol];
        if (buyerid === undefined) throw new Error("Simulation.prototype.logTrade: buyerid is undefined, tradespec=" + JSON.stringify(tradespec));
        var sellerid = sim.xMarket.a[tradespec.sellA[0]][idCol];
        if (sellerid === undefined) throw new Error("Simulation.prototype.logTrade: sellerid is undefined, tradespec=" + JSON.stringify(tradespec));
        var tradePrice = tradespec.prices[0];
        if (!tradePrice) throw new Error("Simulation.prototype.logTrade: undefined price in trade ");
        var tradeBuyerValue = sim.pool.agentsById[buyerid].unitValueFunction('X', sim.pool.agentsById[buyerid].inventory);
        var tradeBuyerProfit = tradeBuyerValue - tradePrice;
        var tradeSellerCost = sim.pool.agentsById[sellerid].unitCostFunction('X', sim.pool.agentsById[sellerid].inventory);
        var tradeSellerProfit = tradePrice - tradeSellerCost;
        var tradeOutput = [sim.period, tradespec.t, tradespec.t - sim.period * sim.periodDuration, tradePrice, buyerid, tradeBuyerValue, tradeBuyerProfit, sellerid, tradeSellerCost, tradeSellerProfit];
        sim.periodTradePrices.push(tradePrice);
        if (sim.logs.trade) sim.logs.trade.write(tradeOutput);
      }
    }, {
      key: 'run',
      value: function run() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          sync: false,
          update: function update(s) {
            return s;
          },
          delay: 20
        },
            sync = _ref.sync,
            update = _ref.update,
            delay = _ref.delay;
        var sim = this;
        var config = this.config;
        if (!config.silent) console.log("Periods = " + config.periods);
        if (sync) {
          while (sim.period < config.periods) {
            sim.runPeriod({ sync: true });
            if (typeof update === 'function') update(sim);
          }
          if (!config.silent) console.log("done");
          return sim;
        }
        return new Promise(function (resolve, reject) {
          function loop() {
            sim.runPeriod().then(update).then(function (s) {
              return s.period < config.periods ? setTimeout(loop, delay) : resolve(s);
            }, function (e) {
              return reject(e);
            });
          }
          loop();
        });
      }
    }]);
    return Simulation;
  }();
  function main() {
    global.fs = fs;
    function mainPeriod(sim) {
      fs.writeFileSync('./period', sim.period);
    }
    var config = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    new Simulation(config).run({
      sync: true,
      update: mainPeriod
    });
  }
  if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {
    if ($__require && $__require.main === module) main();
  }
});
$__System.registerDynamic("fc", ["fb"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("fb");
});
$__System.registerDynamic('fd', [], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  // https://d3js.org/d3-array/ Version 0.8.1. Copyright 2016 Mike Bostock.

  var global = this || self,
      GLOBAL = global;
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof undefined === 'function' && define.amd ? define(['exports'], factory) : factory(global.d3 = global.d3 || {});
  })(this, function (exports) {
    'use strict';

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function (a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          }
          return lo;
        },
        right: function (a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function (d, x) {
        return ascending(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending);
    var bisectRight = ascendingBisect.right;
    var bisectLeft = ascendingBisect.left;

    function descending(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function number(x) {
      return x === null ? NaN : +x;
    }

    function variance(array, f) {
      var n = array.length,
          m = 0,
          a,
          d,
          s = 0,
          i = -1,
          j = 0;

      if (f == null) {
        while (++i < n) {
          if (!isNaN(a = number(array[i]))) {
            d = a - m;
            m += d / ++j;
            s += d * (a - m);
          }
        }
      } else {
        while (++i < n) {
          if (!isNaN(a = number(f(array[i], i, array)))) {
            d = a - m;
            m += d / ++j;
            s += d * (a - m);
          }
        }
      }

      if (j > 1) return s / (j - 1);
    }

    function deviation(array, f) {
      var v = variance(array, f);
      return v ? Math.sqrt(v) : v;
    }

    function extent(array, f) {
      var i = -1,
          n = array.length,
          a,
          b,
          c;

      if (f == null) {
        while (++i < n) if ((b = array[i]) != null && b >= b) {
          a = c = b;break;
        }
        while (++i < n) if ((b = array[i]) != null) {
          if (a > b) a = b;
          if (c < b) c = b;
        }
      } else {
        while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
          a = c = b;break;
        }
        while (++i < n) if ((b = f(array[i], i, array)) != null) {
          if (a > b) a = b;
          if (c < b) c = b;
        }
      }

      return [a, c];
    }

    var array = Array.prototype;

    var slice = array.slice;
    var map = array.map;

    function constant(x) {
      return function () {
        return x;
      };
    }

    function identity(x) {
      return x;
    }

    function range(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    var e10 = Math.sqrt(50);
    var e5 = Math.sqrt(10);
    var e2 = Math.sqrt(2);
    function ticks(start, stop, count) {
      var step = tickStep(start, stop, count);
      return range(Math.ceil(start / step) * step, Math.floor(stop / step) * step + step / 2, // inclusive
      step);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function sturges(values) {
      return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
    }

    function histogram() {
      var value = identity,
          domain = extent,
          threshold = sturges;

      function histogram(data) {
        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] >= x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function (_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
      };

      histogram.domain = function (_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function (_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
      };

      return histogram;
    }

    function quantile(array, p, f) {
      if (f == null) f = number;
      if (!(n = array.length)) return;
      if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
      if (p >= 1) return +f(array[n - 1], n - 1, array);
      var n,
          h = (n - 1) * p,
          i = Math.floor(h),
          a = +f(array[i], i, array),
          b = +f(array[i + 1], i + 1, array);
      return a + (b - a) * (h - i);
    }

    function freedmanDiaconis(values, min, max) {
      values = map.call(values, number).sort(ascending);
      return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
    }

    function scott(values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
    }

    function max(array, f) {
      var i = -1,
          n = array.length,
          a,
          b;

      if (f == null) {
        while (++i < n) if ((b = array[i]) != null && b >= b) {
          a = b;break;
        }
        while (++i < n) if ((b = array[i]) != null && b > a) a = b;
      } else {
        while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
          a = b;break;
        }
        while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
      }

      return a;
    }

    function mean(array, f) {
      var s = 0,
          n = array.length,
          a,
          i = -1,
          j = n;

      if (f == null) {
        while (++i < n) if (!isNaN(a = number(array[i]))) s += a;else --j;
      } else {
        while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a;else --j;
      }

      if (j) return s / j;
    }

    function median(array, f) {
      var numbers = [],
          n = array.length,
          a,
          i = -1;

      if (f == null) {
        while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
      } else {
        while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
      }

      return quantile(numbers.sort(ascending), 0.5);
    }

    function merge(arrays) {
      var n = arrays.length,
          m,
          i = -1,
          j = 0,
          merged,
          array;

      while (++i < n) j += arrays[i].length;
      merged = new Array(j);

      while (--n >= 0) {
        array = arrays[n];
        m = array.length;
        while (--m >= 0) {
          merged[--j] = array[m];
        }
      }

      return merged;
    }

    function min(array, f) {
      var i = -1,
          n = array.length,
          a,
          b;

      if (f == null) {
        while (++i < n) if ((b = array[i]) != null && b >= b) {
          a = b;break;
        }
        while (++i < n) if ((b = array[i]) != null && a > b) a = b;
      } else {
        while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) {
          a = b;break;
        }
        while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
      }

      return a;
    }

    function pairs(array) {
      var i = 0,
          n = array.length - 1,
          p = array[0],
          pairs = new Array(n < 0 ? 0 : n);
      while (i < n) pairs[i] = [p, p = array[++i]];
      return pairs;
    }

    function permute(array, indexes) {
      var i = indexes.length,
          permutes = new Array(i);
      while (i--) permutes[i] = array[indexes[i]];
      return permutes;
    }

    function scan(array, compare) {
      if (!(n = array.length)) return;
      var i = 0,
          n,
          j = 0,
          xi,
          xj = array[j];

      if (!compare) compare = ascending;

      while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

      if (compare(xj, xj) === 0) return j;
    }

    function shuffle(array, i0, i1) {
      var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
      }

      return array;
    }

    function sum(array, f) {
      var s = 0,
          n = array.length,
          a,
          i = -1;

      if (f == null) {
        while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
      } else {
        while (++i < n) if (a = +f(array[i], i, array)) s += a;
      }

      return s;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    exports.bisect = bisectRight;
    exports.bisectRight = bisectRight;
    exports.bisectLeft = bisectLeft;
    exports.ascending = ascending;
    exports.bisector = bisector;
    exports.descending = descending;
    exports.deviation = deviation;
    exports.extent = extent;
    exports.histogram = histogram;
    exports.thresholdFreedmanDiaconis = freedmanDiaconis;
    exports.thresholdScott = scott;
    exports.thresholdSturges = sturges;
    exports.max = max;
    exports.mean = mean;
    exports.median = median;
    exports.merge = merge;
    exports.min = min;
    exports.pairs = pairs;
    exports.permute = permute;
    exports.quantile = quantile;
    exports.range = range;
    exports.scan = scan;
    exports.shuffle = shuffle;
    exports.sum = sum;
    exports.ticks = ticks;
    exports.tickStep = tickStep;
    exports.transpose = transpose;
    exports.variance = variance;
    exports.zip = zip;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
});
$__System.registerDynamic("fe", ["fd"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("fd");
});
$__System.registerDynamic('ff', [], true, function ($__require, exports, module) {
			var global = this || self,
			    GLOBAL = global;
			/* jshint node:true,esnext:true,eqeqeq:true,undef:true,lastsemic:true,strict:true */
			module.exports = function (aoa, header, start) {
						'use strict';

						var h, s, i, l, row, j, k;
						var result = {};
						if (!Array.isArray(aoa)) return;
						if (aoa.length < 1) return;
						if (!Array.isArray(aoa[0])) return;
						if (typeof header === 'object') {
									s = start || 0;
									if (Array.isArray(header.pluck)) {
												s = start || 1;
												h = {};
												for (i = 0, l = header.pluck.length; i < l; ++i) {
															j = aoa[0].indexOf(header.pluck[i]);
															if (j >= 0) h[j] = aoa[0][j];
												}
									} else {
												h = header;
									}
						} else if (typeof header === 'undefined') {
									h = aoa[0];
									s = 1;
						} else {
									return;
						}
						if (Array.isArray(h)) {
									for (i = 0, l = h.length; i < l; ++i) if (h[i]) result[h[i]] = [];
						} else {
									for (i in h) if (h.hasOwnProperty(i)) result[h[i]] = [];
						}
						for (i = s, l = aoa.length; i < l; ++i) {
									row = aoa[i];
									for (j = 0, k = row.length; j < k; ++j) if (h[j]) result[h[j]][i - s] = row[j];
						}
						return result;
			};
});
$__System.registerDynamic("100", ["ff"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("ff");
});
$__System.registerDynamic('101', ['102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var clone = function () {
      'use strict';

      function clone(parent, circular, depth, prototype) {
        var filter;
        if (typeof circular === 'object') {
          depth = circular.depth;
          prototype = circular.prototype;
          filter = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != 'undefined';
        if (typeof circular == 'undefined') circular = true;
        if (typeof depth == 'undefined') depth = Infinity;
        function _clone(parent, depth) {
          if (parent === null) return null;
          if (depth == 0) return parent;
          var child;
          var proto;
          if (typeof parent != 'object') {
            return parent;
          }
          if (clone.__isArray(parent)) {
            child = [];
          } else if (clone.__isRegExp(parent)) {
            child = new RegExp(parent.source, __getRegExpFlags(parent));
            if (parent.lastIndex) child.lastIndex = parent.lastIndex;
          } else if (clone.__isDate(parent)) {
            child = new Date(parent.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent)) {
            child = new Buffer(parent.length);
            parent.copy(child);
            return child;
          } else {
            if (typeof prototype == 'undefined') {
              proto = Object.getPrototypeOf(parent);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent);
            allChildren.push(child);
          }
          for (var i in parent) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent[i], depth - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone.clonePrototype = function clonePrototype(parent) {
        if (parent === null) return null;
        var c = function () {};
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      ;
      clone.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Date]';
      }
      ;
      clone.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Array]';
      }
      ;
      clone.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
      }
      ;
      clone.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = '';
        if (re.global) flags += 'g';
        if (re.ignoreCase) flags += 'i';
        if (re.multiline) flags += 'm';
        return flags;
      }
      ;
      clone.__getRegExpFlags = __getRegExpFlags;
      return clone;
    }();
    if (typeof module === 'object' && module.exports) {
      module.exports = clone;
    }
  })($__require('102').Buffer);
});
$__System.registerDynamic("103", ["101"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("101");
});
$__System.registerDynamic('104', ['103'], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* */
	var clone = $__require('103');

	module.exports = function (trace) {
		var i,
		    l,
		    xin,
		    yin,
		    xout = [],
		    yout = [],
		    T;
		if (typeof trace.steps !== 'undefined') {
			if (trace.steps && trace.x && trace.y && trace.x.length && trace.y.length) {
				T = clone(trace);
				xin = T.x.slice(0);
				yin = T.y.slice(0);
				xout = [xin[0]];
				for (i = 1, l = xin.length; i < l; ++i) xout.push(xin[i] * (1.0 - Number.EPSILON), xin[i]);
				for (i = 0, l = yin.length - 1; i < l; ++i) yout.push(yin[i], yin[i]);
				yout.push(yin[yin.length - 1]);
				T.x = xout;
				T.y = yout;
				delete T.steps;
				return T;
			}
			delete trace.steps;
		}
		return trace;
	};
});
$__System.registerDynamic("105", ["104"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("104");
});
$__System.registerDynamic("106", ["fe", "100", "105"], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.helpers = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }; /* Copyright 2016 Paul Brewer, Economic and Financial Technology Consulting LLC */
    /* This file is open source software.  The MIT License applies to this software. */

    exports.yaxisRange = yaxisRange;
    exports.plotFactory = plotFactory;
    exports.build = build;

    var _d3Array = $__require("fe");

    var d3A = _interopRequireWildcard(_d3Array);

    var _transpluck = $__require("100");

    var _transpluck2 = _interopRequireDefault(_transpluck);

    var _stepifyPlotly = $__require("105");

    var _stepifyPlotly2 = _interopRequireDefault(_stepifyPlotly);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }newObj.default = obj;return newObj;
        }
    }

    function yaxisRange(sim) {
        return {
            yaxis: {
                range: [sim.config.L || 0, sim.config.H || 200]
            }
        };
    }

    /* this exports all the functions below, and also assigns them to the helpers object.
     * Depending on the version of the babel compiler, sometimes it exports the helpers object because exports are static and not dynamically computed in es6 ... which might be counterintuitive.
     */

    function plotFactory(chart) {

        /* chart properties are title, log or logs, names, xs, ys, modes, layout */

        return function (sim) {
            var series = null;
            if (chart.log) series = (0, _transpluck2.default)(sim.logs[chart.log].data, { pluck: [].concat(chart.xs, chart.ys) });
            var traces = chart.names.map(function (name, i) {
                var xvar = chart.xs[i % chart.xs.length];
                var yvar = chart.ys[i % chart.ys.length];
                var mode = chart.modes[i % chart.modes.length];
                var type = 'scatter';
                if (chart.logs) series = (0, _transpluck2.default)(sim.logs[chart.logs[i % chart.logs.length]].data, { pluck: [xvar, yvar] });
                var x = series[xvar];
                var y = series[yvar];
                return { name: name, mode: mode, type: type, x: x, y: y };
            });
            var layout = Object.assign({}, { title: chart.title }, yaxisRange(sim), chart.layout);
            return [traces, layout];
        };
    }

    var helpers = exports.helpers = {
        supplyDemand: function supplyDemand() {
            return function (sim) {
                var i = void 0,
                    l = void 0;
                var xboth = [];
                var buyerValues = sim.config.buyerValues.slice().sort(function (a, b) {
                    return +b - a;
                });
                var sellerCosts = sim.config.sellerCosts.slice().sort(function (a, b) {
                    return +a - b;
                });
                for (i = 0, l = Math.max(buyerValues.length, sellerCosts.length); i < l; ++i) {
                    xboth[i] = i;
                }
                var demand = {
                    name: 'unit value',
                    x: xboth.slice(0, buyerValues.length),
                    y: buyerValues,
                    mode: 'lines+markers',
                    type: 'scatter',
                    steps: true
                };
                var supply = {
                    name: 'unit cost',
                    x: xboth.slice(0, sellerCosts.length),
                    y: sellerCosts,
                    mode: 'lines+markers',
                    type: 'scatter',
                    steps: true
                };
                var layout = Object.assign({}, yaxisRange(sim), { xaxis: { range: [0, xboth.length] } });
                var plotlyData = [demand, supply].map(_stepifyPlotly2.default);
                return [plotlyData, layout];
            };
        },

        plotFactory: plotFactory,

        histogramFactory: function histogramFactory(chart) {

            /* req chart properties are title, names, logs, vars */
            /* opt chart properties are bins, range */

            return function (sim) {
                var traces = chart.names.map(function (name, i) {
                    var mylog = chart.logs[i % chart.logs.length];
                    var mylet = chart.vars[i % chart.vars.length];
                    return {
                        name: name,
                        x: (0, _transpluck2.default)(sim.logs[mylog].data, { pluck: [mylet] })[mylet],
                        type: 'histogram',
                        opacity: 0.60,
                        nbinsx: 100
                    };
                });
                var myrange = void 0,
                    mybins = void 0;
                var mymin = void 0,
                    mymax = void 0;
                if (chart.range) {
                    myrange = chart.range;
                } else {
                    mymin = d3A.min(traces, function (trace) {
                        return d3A.min(trace.x);
                    });
                    mymax = d3A.max(traces, function (trace) {
                        return d3A.max(trace.x);
                    });
                    myrange = [mymin, mymax];
                }
                if (chart.bins) {
                    mybins = chart.bins;
                } else {
                    mybins = Math.max(0, Math.min(200, Math.floor(1 + mymax - mymin)));
                }
                if (mybins && mybins !== 100) traces.forEach(function (trace) {
                    trace.nbinsx = mybins;
                });
                var layout = {
                    barmode: 'overlay',
                    xaxis: {
                        range: myrange
                    },
                    title: chart.title
                };
                return [traces, layout];
            };
        },
        histogram2DFactory: function histogram2DFactory(chart) {

            /* req chart properties are title, names, logs, vars */

            ['names', 'logs', 'vars'].forEach(function (prop) {
                if (!Array.isArray(chart[prop])) throw new Error("histogram2DFactory: Expected array for chart." + prop + " got: " + _typeof(chart[prop]));
                if (chart[prop].length === 0 || chart[prop].length > 2) throw new Error("histogram2DFactory: Expected " + prop + " to be array of length 1 or 2, got: " + chart[prop].length);
            });

            return function (sim) {
                var series = chart.names.map(function (name, i) {
                    var mylog = chart.logs[i % chart.logs.length];
                    var mylet = chart.vars[i % chart.vars.length];
                    return (0, _transpluck2.default)(sim.logs[mylog].data, { pluck: [mylet] })[mylet];
                });

                var points = Object.assign({}, {
                    x: series[0],
                    y: series[1],
                    mode: 'markers',
                    name: 'points',
                    marker: {
                        color: 'rgb(102,0,0)',
                        size: 2,
                        opacity: 0.4
                    }
                }, chart.points);

                var density = Object.assign({}, {
                    x: series[0],
                    y: series[1],
                    name: 'density',
                    ncontours: 30,
                    colorscale: 'Hot',
                    reversescale: true,
                    showscale: false,
                    type: 'histogram2dcontour'
                }, chart.density);

                var upper = Object.assign({}, {
                    x: series[0],
                    name: chart.names[0],
                    marker: { color: points.marker.color },
                    yaxis: 'y2',
                    type: 'histogram'
                }, chart.upper);

                var right = Object.assign({}, {
                    y: series[1],
                    name: chart.names[1],
                    marker: { color: points.marker.color },
                    xaxis: 'x2',
                    type: 'histogram'
                }, chart.right);

                var axiscommon = Object.assign({}, {
                    showgrid: false,
                    zeroline: false
                }, chart.axiscommon);

                var layout = Object.assign({}, {
                    title: chart.title,
                    showlegend: false,
                    margin: { t: 50 },
                    hovermode: 'closest',
                    bargap: 0,
                    xaxis: Object.assign({}, axiscommon, { domain: [0, 0.8] }),
                    yaxis: Object.assign({}, axiscommon, { domain: [0, 0.8] }),
                    xaxis2: Object.assign({}, axiscommon, { domain: [0.8, 1] }),
                    yaxis2: Object.assign({}, axiscommon, { domain: [0.8, 1] })
                }, chart.layout);

                return [[points, density, upper, right], layout];
            };
        },
        plotOHLCTimeSeries: function plotOHLCTimeSeries() {
            return plotFactory({
                title: 'Open,High,Low,Close Trade prices for each period',
                log: 'ohlc',
                names: ['open', 'high', 'low', 'close'],
                xs: ['period'],
                ys: ['open', 'high', 'low', 'close'],
                modes: ['markers', 'markers', 'markers', 'lines+markers']
            });
        },
        plotBidAskTradeTimeSeries: function plotBidAskTradeTimeSeries() {
            return plotFactory({
                title: 'Bid,Ask,Trade time series',
                names: ['bids', 'asks', 'trades'],
                logs: ['buyorder', 'sellorder', 'trade'],
                modes: ['markers', 'markers', 'lines+markers'],
                xs: ['t'],
                ys: ['buyLimitPrice', 'sellLimitPrice', 'price']
            });
        },
        plotProfitTimeSeries: function plotProfitTimeSeries(chart) {
            return function (sim) {
                var numberOfPeriods = sim.logs.profit.data.length;
                var periods = [];
                for (var i = 1, l = numberOfPeriods; i <= l; ++i) {
                    periods.push(i);
                }var profitHeader = [];
                for (var _i = 1, _l = sim.numberOfBuyers; _i <= _l; ++_i) {
                    profitHeader.push('Buyer' + _i);
                }for (var _i2 = 1, _l2 = sim.numberOfSellers; _i2 <= _l2; ++_i2) {
                    profitHeader.push('Seller' + _i2);
                }var profitsByAgent = (0, _transpluck2.default)(sim.logs.profit.data, profitHeader);
                var traces = [];
                for (var _i3 = 0, _l3 = sim.numberOfAgents; _i3 < _l3; ++_i3) {
                    traces.push({
                        x: periods,
                        y: profitsByAgent[profitHeader[_i3]],
                        name: profitHeader[_i3],
                        mode: 'markers',
                        marker: {
                            symbol: _i3 < sim.numberOfBuyers ? "circle" : "square"
                        },
                        type: 'scatter'
                    });
                }var layout = Object.assign({}, { title: "Profits for each agent and period" }, yaxisRange(sim), chart.layout);
                return [traces, layout];
            };
        }
    };

    function build(arrayOfVisuals) {
        var myLibrary = arguments.length <= 1 || arguments[1] === undefined ? helpers : arguments[1];

        return arrayOfVisuals.map(function (visual) {
            try {
                var f = myLibrary[visual.f](visual);
                if (typeof f !== "function") throw new Error("visualization function named " + visual.f + " does not exist");
                f.meta = visual;
                return f;
            } catch (e) {
                console.log(e); // eslint-disable-line no-console
                return undefined;
            }
        }).filter(function (visualFunction) {
            return typeof visualFunction === "function";
        });
    }
});
$__System.registerDynamic("107", ["106"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("106");
});
$__System.registerDynamic('108', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;

  exports.shim = shim;
  function shim(obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }
});
$__System.registerDynamic('109', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var supportsArgumentsClass = function () {
    return Object.prototype.toString.call(arguments);
  }() == '[object Arguments]';

  exports = module.exports = supportsArgumentsClass ? supported : unsupported;

  exports.supported = supported;
  function supported(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  };

  exports.unsupported = unsupported;
  function unsupported(object) {
    return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
  };
});
$__System.registerDynamic('10a', ['108', '109'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var pSlice = Array.prototype.slice;
  var objectKeys = $__require('108');
  var isArguments = $__require('109');
  var deepEqual = module.exports = function (actual, expected, opts) {
    if (!opts) opts = {};
    if (actual === expected) {
      return true;
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();
    } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
      return opts.strict ? actual === expected : actual == expected;
    } else {
      return objEquiv(actual, expected, opts);
    }
  };
  function isUndefinedOrNull(value) {
    return value === null || value === undefined;
  }
  function isBuffer(x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number') return false;
    return true;
  }
  function objEquiv(a, b, opts) {
    var i, key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
    if (a.prototype !== b.prototype) return false;
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepEqual(a, b, opts);
    }
    if (isBuffer(a)) {
      if (!isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) return false;
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    try {
      var ka = objectKeys(a),
          kb = objectKeys(b);
    } catch (e) {
      return false;
    }
    if (ka.length != kb.length) return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i]) return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual(a[key], b[key], opts)) return false;
    }
    return typeof a === typeof b;
  }
});
$__System.registerDynamic("10b", ["10a"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("10a");
});
$__System.registerDynamic("10c", ["10b"], true, function ($__require, exports, module) {
    /* */
    "use strict";

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.init = init;
    exports.openList = openList;
    exports.promiseUpload = promiseUpload;
    exports.promiseList = promiseList;
    exports.promiseListRange = promiseListRange;
    exports.promiseSaveItem = promiseSaveItem;
    exports.promiseRemoveItem = promiseRemoveItem;
    exports.promiseMoveItem = promiseMoveItem;

    var _deepEqual = $__require("10b");

    var _deepEqual2 = _interopRequireDefault(_deepEqual);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    /* Copyright 2017 Paul Brewer, Economic and Financial Technology Consulting LLC */
    /* This file is open source software.  The MIT License applies to this software. */

    /*
     * store should be set to window.localStorage or window.sessionStorage with init(_)
     *
     */

    var store = null;

    function init(obj) {
        store = obj;
    }

    function openList(name) {
        var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        if (defaultValue && !store.getItem(name)) {
            store.setItem(name, JSON.stringify(defaultValue));
        }
        return name;
    }

    function promiseUpload() {
        throw new Error("upload unavailable when using local storage");
    }

    function promiseList(list) {
        return new Promise(function (resolve, reject) {
            var S = store;
            var data = S.getItem(list);
            setTimeout(function () {
                if (data) return resolve(JSON.parse(data));
                reject("storage for  " + list + " does not exist locally");
            }, 0);
        });
    }

    function promiseListRange(list, iFrom, iTo) {
        return promiseList(list).then(function (data) {
            return data.slice(iFrom, iTo);
        });
    }

    function promiseSaveItem(item, list) {
        return promiseList(list).then(function (data) {
            data.unshift(item);
            store.setItem(list, JSON.stringify(data));
        });
    }

    function promiseRemoveItem(item, list) {
        return promiseList(list).then(function (data) {
            var newData = data.filter(function (x) {
                return !(0, _deepEqual2.default)(x, item, true);
            });
            store.setItem(list, JSON.stringify(newData));
        });
    }

    function promiseMoveItem(item, list1, list2) {
        return Promise.all([promiseSaveItem(item, list2), promiseRemoveItem(item, list1)]);
    }
});
$__System.registerDynamic("10d", ["10c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("10c");
});
$__System.registerDynamic("10e", [], true, function ($__require, exports, module) {
	/* */
	"format cjs";
	/* FileSaver.js
  * A saveAs() FileSaver implementation.
  * 1.1.20160520
  *
  * By Eli Grey, http://eligrey.com
  * License: MIT
  *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
  */

	/*global self */
	/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

	/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

	var global = this || self,
	    GLOBAL = global;
	var saveAs = saveAs || function (view) {
		"use strict";
		// IE <10 is explicitly unsupported

		if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var doc = view.document
		// only get URL when necessary in case Blob.js hasn't overridden it yet
		,
		    get_URL = function () {
			return view.URL || view.webkitURL || view;
		},
		    save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
		    can_use_save_link = "download" in save_link,
		    click = function (node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		},
		    is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent),
		    webkit_req_fs = view.webkitRequestFileSystem,
		    req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
		    throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function () {
				throw ex;
			}, 0);
		},
		    force_saveable_type = "application/octet-stream",
		    fs_min_size = 0
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		,
		    arbitrary_revoke_timeout = 1000 * 40 // in ms
		,
		    revoke = function (file) {
			var revoker = function () {
				if (typeof file === "string") {
					// file is an object URL
					get_URL().revokeObjectURL(file);
				} else {
					// file is a File
					file.remove();
				}
			};
			/* // Take note W3C:
   var
     uri = typeof file === "string" ? file : file.toURL()
   , revoker = function(evt) {
   	// idealy DownloadFinishedEvent.data would be the URL requested
   	if (evt.data === uri) {
   		if (typeof file === "string") { // file is an object URL
   			get_URL().revokeObjectURL(file);
   		} else { // file is a File
   			file.remove();
   		}
   	}
   }
   ;
   view.addEventListener("downloadfinished", revoker);
   */
			setTimeout(revoker, arbitrary_revoke_timeout);
		},
		    dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		},
		    auto_bom = function (blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\xEF\xBB\xBF", blob], { type: blob.type });
			}
			return blob;
		},
		    FileSaver = function (blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var filesaver = this,
			    type = blob.type,
			    blob_changed = false,
			    object_url,
			    target_view,
			    dispatch_all = function () {
				dispatch(filesaver, "writestart progress write writeend".split(" "));
			}
			// on any filesys errors revert to saving with object URLs
			,
			    fs_error = function () {
				if (target_view && is_safari && typeof FileReader !== "undefined") {
					// Safari doesn't allow downloading of blob urls
					var reader = new FileReader();
					reader.onloadend = function () {
						var base64Data = reader.result;
						target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/));
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
					};
					reader.readAsDataURL(blob);
					filesaver.readyState = filesaver.INIT;
					return;
				}
				// don't create more object URLs than needed
				if (blob_changed || !object_url) {
					object_url = get_URL().createObjectURL(blob);
				}
				if (target_view) {
					target_view.location.href = object_url;
				} else {
					var new_tab = view.open(object_url, "_blank");
					if (new_tab === undefined && is_safari) {
						// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
						view.location.href = object_url;
					}
				}
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
			},
			    abortable = function (func) {
				return function () {
					if (filesaver.readyState !== filesaver.DONE) {
						return func.apply(this, arguments);
					}
				};
			},
			    create_if_not_found = { create: true, exclusive: false },
			    slice;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function () {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
					var save = function () {
						dir.getFile(name, create_if_not_found, abortable(function (file) {
							file.createWriter(abortable(function (writer) {
								writer.onwriteend = function (event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function () {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function (event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function () {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, { create: false }, abortable(function (file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function (ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		},
		    FS_proto = FileSaver.prototype,
		    saveAs = function (blob, name, no_auto_bom) {
			return new FileSaver(blob, name, no_auto_bom);
		};
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function (blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name || "download");
			};
		}

		FS_proto.abort = function () {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;

		FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;

		return saveAs;
	}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content);
	// `self` is undefined in Firefox for Android content script context
	// while `this` is nsIContentFrameMessageManager
	// with an attribute `content` that corresponds to the window

	if (typeof module !== "undefined" && module.exports) {
		module.exports.saveAs = saveAs;
	} else if (typeof undefined !== "undefined" && define !== null && define.amd !== null) {
		define([], function () {
			return saveAs;
		});
	}
});
$__System.registerDynamic("10f", ["10e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("10e");
});
$__System.registerDynamic('110', ['111', '112', '10f'], true, function ($__require, exports, module) {
			var global = this || self,
			    GLOBAL = global;
			/* Copyright 2016 Paul Brewer, Economic and Financial Technology Consulting LLC */
			/* This file is open source software.  The MIT License applies to this software. */

			/* jshint browserify:true,jquery:true,esnext:true,eqeqeq:true,undef:true,lastsemic:true,strict:true,unused:true */

			const JSzip = $__require('111');
			const Study = $__require('112');
			const saveAs = $__require('10f').saveAs;

			// see http://stackoverflow.com/a/7220510/103081 by http://stackoverflow.com/users/27862/user123444555621 for pretty printed stringify

			module.exports = function savezip(_obj) {
						"use strict";

						var config = _obj.config,
						    sims = _obj.sims,
						    download = _obj.download;
						if (!config || !Array.isArray(sims)) throw new Error("single-market-robot-simulator-savezip: no config or sims to save");
						var stamp = Study.myDateStamp();
						var zip = new JSzip();
						config.zipfileName = stamp;
						config.zipfileDate = Date.now();
						zip.folder(stamp).file("config.json", JSON.stringify(config, null, 2));
						sims.forEach(function (sim, i) {
									var folder = zip.folder(stamp).folder(Study.letter(i));
									var logs = sim.logs;
									var logNames = Object.keys(logs);
									logNames.forEach(function (L) {
												folder.file(L + ".csv", logs[L].toString());
									});
									delete sim.logs;
									folder.file("sim.json", JSON.stringify(sim.config, null, 2));
									sim.logs = logs;
						});
						return zip.generateAsync({ type: "blob", compression: "DEFLATE" }).then(function (blob) {
									if (download) saveAs(blob, stamp + ".zip");
									return blob;
						});
			};
});
$__System.registerDynamic("113", ["110"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("110");
});
$__System.registerDynamic('114', ['115', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var GenericWorker = $__require('115');
  var utils = $__require('116');
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
      data: utils.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  module.exports = ConvertWorker;
});
$__System.registerDynamic('117', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
});
$__System.registerDynamic('118', ['117', '119', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (isUndefined(global.process)) {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('117');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('119');
    exports._extend = function (origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('96'));
});
$__System.registerDynamic("11a", ["118"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("118");
});
$__System.registerDynamic('11b', ['11a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('util') : $__require('11a');
});
$__System.registerDynamic("11c", ["11b"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("11b");
});
$__System.registerDynamic('11d', ['11e', '11c'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var Readable = $__require('11e').Readable;

    var util = $__require('11c');
    util.inherits(NodejsStreamOutputAdapter, Readable);

    /**
    * A nodejs stream using a worker as source.
    * @see the SourceWrapper in http://nodejs.org/api/stream.html
    * @constructor
    * @param {StreamHelper} helper the helper wrapping the worker
    * @param {Object} options the nodejs stream options
    * @param {Function} updateCb the update callback.
    */
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
        Readable.call(this, options);
        this._helper = helper;

        var self = this;
        helper.on("data", function (data, meta) {
            if (!self.push(data)) {
                self._helper.pause();
            }
            if (updateCb) {
                updateCb(meta);
            }
        }).on("error", function (e) {
            self.emit('error', e);
        }).on("end", function () {
            self.push(null);
        });
    }

    NodejsStreamOutputAdapter.prototype._read = function () {
        this._helper.resume();
    };

    module.exports = NodejsStreamOutputAdapter;
});
$__System.registerDynamic('11f', ['116', '114', '115', '120', '121', '122', '11d', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var utils = $__require('116');
    var ConvertWorker = $__require('114');
    var GenericWorker = $__require('115');
    var base64 = $__require('120');
    var support = $__require('121');
    var external = $__require('122');
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = $__require('11d');
      } catch (e) {}
    }
    function transformZipOutput(resultType, chunkType, dataArray, mimeType) {
      var content = null;
      switch (resultType) {
        case "blob":
          return utils.newBlob(dataArray, mimeType);
        case "base64":
          content = concat(chunkType, dataArray);
          return base64.encode(content);
        default:
          content = concat(chunkType, dataArray);
          return utils.transformTo(resultType, content);
      }
    }
    function concat(type, dataArray) {
      var i,
          index = 0,
          res = null,
          totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function (resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper.on('data', function (data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on('error', function (err) {
          dataArray = [];
          reject(err);
        }).on('end', function () {
          try {
            var result = transformZipOutput(resultType, chunkType, dataArray, mimeType);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
          internalType = "arraybuffer";
          break;
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      accumulate: function (updateCb) {
        return accumulate(this, updateCb);
      },
      on: function (evt, fn) {
        var self = this;
        if (evt === "data") {
          this._worker.on(evt, function (chunk) {
            fn.call(self, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function () {
            utils.delay(fn, arguments, self);
          });
        }
        return this;
      },
      resume: function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      pause: function () {
        this._worker.pause();
        return this;
      },
      toNodejsStream: function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, { objectMode: this._outputType !== "nodebuffer" }, updateCb);
      }
    };
    module.exports = StreamHelper;
  })($__require('102').Buffer);
});
$__System.registerDynamic('123', ['11f', '124', '125', '126', '115', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var StreamHelper = $__require('11f');
    var DataWorker = $__require('124');
    var utf8 = $__require('125');
    var CompressedObject = $__require('126');
    var GenericWorker = $__require('115');
    var ZipObject = function (name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      internalStream: function (type) {
        var outputType = type.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        var result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf8.Utf8EncodeWorker());
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf8.Utf8DecodeWorker());
        }
        return new StreamHelper(result, outputType, "");
      },
      async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      _compressWorker: function (compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      _decompressWorker: function () {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function () {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (var i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    module.exports = ZipObject;
  })($__require('102').Buffer);
});
$__System.registerDynamic('127', ['116', '115', '125', '128', '129'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var GenericWorker = $__require('115');
  var utf8 = $__require('125');
  var crc32 = $__require('128');
  var signature = $__require('129');
  var decToHex = function (dec, bytes) {
    var hex = "",
        i;
    for (i = 0; i < bytes; i++) {
      hex += String.fromCharCode(dec & 0xff);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function (unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
  };
  var generateDosExternalFileAttr = function (dosPermissions, isDir) {
    return (dosPermissions || 0) & 0x3F;
  };
  var generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
        compression = streamInfo['compression'],
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment,
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir = file.dir,
        date = file.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo['crc32'];
      dataInfo.compressedSize = streamInfo['compressedSize'];
      dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 0x0800;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 0x00010;
    }
    if (platform === "UNIX") {
      versionMadeBy = 0x031E;
      extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
      versionMadeBy = 0x0014;
      extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
      extraFields += "\x75\x70" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
      extraFields += "\x75\x63" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
    }
    var header = "";
    header += "\x0A\x00";
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
    return {
      fileRecord: fileRecord,
      dirRecord: dirRecord
    };
  };
  var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));
    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo['crc32'], 4) + decToHex(streamInfo['compressedSize'], 4) + decToHex(streamInfo['uncompressedSize'], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function (chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function () {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;
    previous.on('data', function (chunk) {
      self.processChunk(chunk);
    });
    previous.on('end', function () {
      self.closedSource(self.previous.streamInfo);
      if (self._sources.length) {
        self.prepareNextSource();
      } else {
        self.end();
      }
    });
    previous.on('error', function (e) {
      self.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e) {}
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  module.exports = ZipFileWorker;
});
$__System.registerDynamic('12a', ['12b', '127'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var compressions = $__require('12b');
  var ZipFileWorker = $__require('127');
  var getCompression = function (fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  exports.generateWorker = function (zip, options, comment) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function (relativePath, file) {
        entriesCount++;
        var compression = getCompression(file.options.compression, options.compression);
        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
        var dir = file.dir,
            date = file.date;
        file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir: dir,
          date: date,
          comment: file.comment || "",
          unixPermissions: file.unixPermissions,
          dosPermissions: file.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
});
$__System.registerDynamic('12c', ['116', '115'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var GenericWorker = $__require('115');
  function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
  }
  utils.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream.on("data", function (chunk) {
      self.push({
        data: chunk,
        meta: { percent: 0 }
      });
    }).on("error", function (e) {
      if (self.isPaused) {
        this.generatedError = e;
      } else {
        self.error(e);
      }
    }).on("end", function () {
      if (self.isPaused) {
        self._upstreamEnded = true;
      } else {
        self.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function () {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  module.exports = NodejsStreamInputAdapter;
});
$__System.registerDynamic('12d', ['125', '116', '115', '11f', '12e', '126', '123', '12a', '12f', '12c', '102', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    var utf8 = $__require('125');
    var utils = $__require('116');
    var GenericWorker = $__require('115');
    var StreamHelper = $__require('11f');
    var defaults = $__require('12e');
    var CompressedObject = $__require('126');
    var ZipObject = $__require('123');
    var generate = $__require('12a');
    var nodejsUtils = $__require('12f');
    var NodejsStreamInputAdapter = $__require('12c');
    var fileAdd = function (name, data, originalOptions) {
      var dataType = utils.getTypeOf(data),
          parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 0x4000) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 0x0010) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object;
    };
    var parentFolder = function (path) {
      if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf('/');
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function (path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    };
    var folderAdd = function (name, createFolders) {
      createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders: createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var out = {
      load: function () {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      forEach: function (cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          if (!this.files.hasOwnProperty(filename)) {
            continue;
          }
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      filter: function (search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      file: function (name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function (relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      folder: function (arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function (relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      remove: function (name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function (relativePath, file) {
            return file.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      generate: function (options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      generateInternalStream: function (options) {
        var worker,
            opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: 'application/zip',
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
            opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      generateAsync: function (options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      generateNodeStream: function (options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module.exports = out;
  })($__require('102').Buffer, $__require('96'));
});
$__System.registerDynamic("129", [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  exports.LOCAL_FILE_HEADER = "PK\x03\x04";
  exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
  exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
  exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
  exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
  exports.DATA_DESCRIPTOR = "PK\x07\x08";
});
$__System.registerDynamic('130', ['131', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DataReader = $__require('131');
  var utils = $__require('116');
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function (i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader.prototype.lastIndexOfSignature = function (sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = StringReader;
});
$__System.registerDynamic('132', ['133', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var Uint8ArrayReader = $__require('133');
  var utils = $__require('116');
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function (size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = NodeBufferReader;
});
$__System.registerDynamic('131', ['116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    checkOffset: function (offset) {
      this.checkIndex(this.index + offset);
    },
    checkIndex: function (newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    setIndex: function (newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    skip: function (n) {
      this.setIndex(this.index + n);
    },
    byteAt: function (i) {},
    readInt: function (size) {
      var result = 0,
          i;
      this.checkOffset(size);
      for (i = this.index + size - 1; i >= this.index; i--) {
        result = (result << 8) + this.byteAt(i);
      }
      this.index += size;
      return result;
    },
    readString: function (size) {
      return utils.transformTo("string", this.readData(size));
    },
    readData: function (size) {},
    lastIndexOfSignature: function (sig) {},
    readAndCheckSignature: function (sig) {},
    readDate: function () {
      var dostime = this.readInt(4);
      return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, (dostime >> 21 & 0x0f) - 1, dostime >> 16 & 0x1f, dostime >> 11 & 0x1f, dostime >> 5 & 0x3f, (dostime & 0x1f) << 1));
    }
  };
  module.exports = DataReader;
});
$__System.registerDynamic('134', ['131', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DataReader = $__require('131');
  var utils = $__require('116');
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
      data[i] = data[i] & 0xFF;
    }
  }
  utils.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function (i) {
    return this.data[this.zero + i];
  };
  ArrayReader.prototype.lastIndexOfSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = ArrayReader;
});
$__System.registerDynamic('133', ['134', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ArrayReader = $__require('134');
  var utils = $__require('116');
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function (size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  module.exports = Uint8ArrayReader;
});
$__System.registerDynamic('135', ['116', '121', '134', '130', '132', '133', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var utils = $__require('116');
    var support = $__require('121');
    var ArrayReader = $__require('134');
    var StringReader = $__require('130');
    var NodeBufferReader = $__require('132');
    var Uint8ArrayReader = $__require('133');
    module.exports = function (data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  })($__require('102').Buffer);
});
$__System.registerDynamic('124', ['116', '115'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var GenericWorker = $__require('115');
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function (data) {
      self.dataIsReady = true;
      self.data = data;
      self.max = data && data.length || 0;
      self.type = utils.getTypeOf(data);
      if (!self.isPaused) {
        self._tickAndRepeat();
      }
    }, function (e) {
      self.error(e);
    });
  }
  utils.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function () {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function () {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function () {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null,
        nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data: data,
        meta: { percent: this.max ? this.index / this.max * 100 : 0 }
      });
    }
  };
  module.exports = DataWorker;
});
$__System.registerDynamic('136', ['116', '115'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var GenericWorker = $__require('115');
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function (chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  module.exports = DataLengthProbe;
});
$__System.registerDynamic('126', ['122', '124', '136', '137', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var external = $__require('122');
    var DataWorker = $__require('124');
    var DataLengthProbe = $__require('136');
    var Crc32Probe = $__require('137');
    var DataLengthProbe = $__require('136');
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      getContentWorker: function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function () {
          if (this.streamInfo['data_length'] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      getCompressedWorker: function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        ;
      }
    };
    CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module.exports = CompressedObject;
  })($__require('102').Buffer);
});
$__System.registerDynamic('138', ['139', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('139');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 0xff;
      s.pending_buf[s.pending++] = w >>> 8 & 0xff;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  })($__require('96'));
});
$__System.registerDynamic('13a', ['139', '138', '13b', '13c', '13d', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var utils = $__require('139');
    var trees = $__require('138');
    var adler32 = $__require('13b');
    var crc32 = $__require('13c');
    var msg = $__require('13d');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (;;) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (;;) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (;;) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, s.gzhead.time >> 8 & 0xff);
            put_byte(s, s.gzhead.time >> 16 & 0xff);
            put_byte(s, s.gzhead.time >> 24 & 0xff);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, strm.adler >> 8 & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  })($__require('102').Buffer);
});
$__System.registerDynamic('13e', ['13a', '139', '13f', '13d', '140'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var zlib_deflate = $__require('13a');
  var utils = $__require('139');
  var strings = $__require('13f');
  var msg = $__require('13d');
  var ZStream = $__require('140');
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ''
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === 'string') {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function (data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === 'string') {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === 'string') {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function (status) {
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});
$__System.registerDynamic('13b', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // Note: adler32 takes 12% for level 0 and 2% for level 6.
  // It doesn't worth to make additional optimizationa as in original.
  // Small size is preferable.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var global = this || self,
      GLOBAL = global;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 0xffff | 0,
        s2 = adler >>> 16 & 0xffff | 0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return s1 | s2 << 16 | 0;
  }

  module.exports = adler32;
});
$__System.registerDynamic('13c', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // Note: we can't get significant speed boost here.
  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // Use ordinary array, since untyped makes no boost here

  var global = this || self,
      GLOBAL = global;
  function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }

    return table;
  }

  // Create table on load. Just 255 signed longs. Not a problem.
  var crcTable = makeTable();

  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc ^= -1;

    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
  }

  module.exports = crc32;
});
$__System.registerDynamic('141', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // See state defs from inflate.js

  var global = this || self,
      GLOBAL = global;
  var BAD = 30; /* got a data error -- remain here until reset */
  var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.
  
     Entry assumptions:
  
          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8
  
     On return, state.mode is one of:
  
          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data
  
     Notes:
  
      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.
  
      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in; /* local strm.input */
    var last; /* have enough input while in < last */
    var _out; /* local strm.output */
    var beg; /* inflate()'s initial strm.output */
    var end; /* while out < end, enough space available */
    //#ifdef INFLATE_STRICT
    var dmax; /* maximum distance from zlib header */
    //#endif
    var wsize; /* window size or zero if not using window */
    var whave; /* valid bytes in the window */
    var wnext; /* window write index */
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools
    var s_window; /* allocated sliding window, if wsize != 0 */
    var hold; /* local strm.hold */
    var bits; /* local strm.bits */
    var lcode; /* local strm.lencode */
    var dcode; /* local strm.distcode */
    var lmask; /* mask for first level of length codes */
    var dmask; /* mask for first level of distance codes */
    var here; /* retrieved table entry */
    var op; /* code bits, operation, extra bits, or */
    /*  window position, window bytes to copy */
    var len; /* match length, unused bytes */
    var dist; /* match distance */
    var from; /* where to copy match from */
    var from_source;

    var input, output; // JS specific, because we have no pointers

    /* copy state to local variables */
    state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    //#ifdef INFLATE_STRICT
    dmax = state.dmax;
    //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen: for (;;) {
        // Goto emulation
        op = here >>> 24 /*here.bits*/;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 0xff /*here.op*/;
        if (op === 0) {
          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          output[_out++] = here & 0xffff /*here.val*/;
        } else if (op & 16) {
          /* length base */
          len = here & 0xffff /*here.val*/;
          op &= 15; /* number of extra bits */
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          }
          //Tracevv((stderr, "inflate:         length %u\n", len));
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];

          dodist: for (;;) {
            // goto emulation
            op = here >>> 24 /*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff /*here.op*/;

            if (op & 16) {
              /* distance base */
              dist = here & 0xffff /*here.val*/;
              op &= 15; /* number of extra bits */
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & (1 << op) - 1;
              //#ifdef INFLATE_STRICT
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }
              //#endif
              hold >>>= op;
              bits -= op;
              //Tracevv((stderr, "inflate:         distance %u\n", dist));
              op = _out - beg; /* max distance in output */
              if (dist > op) {
                /* see if copy from window */
                op = dist - op; /* distance back in window */
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }

                  // (!) This block is disabled in zlib defailts,
                  // don't enable it for binary compatibility
                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                  //                if (len <= op - whave) {
                  //                  do {
                  //                    output[_out++] = 0;
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //                len -= op - whave;
                  //                do {
                  //                  output[_out++] = 0;
                  //                } while (--op > whave);
                  //                if (op === 0) {
                  //                  from = _out - dist;
                  //                  do {
                  //                    output[_out++] = output[from++];
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //#endif
                }
                from = 0; // window index
                from_source = s_window;
                if (wnext === 0) {
                  /* very common case */
                  from += wsize - op;
                  if (op < len) {
                    /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                } else if (wnext < op) {
                  /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    /* some from end of window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      /* some from start of window */
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist; /* rest from output */
                      from_source = output;
                    }
                  }
                } else {
                  /* contiguous in window */
                  from += wnext - op;
                  if (op < len) {
                    /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist; /* copy direct from output */
                do {
                  /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              /* 2nd level distance code */
              here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        } else if ((op & 64) === 0) {
          /* 2nd level length code */
          here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;

    /* update state and return */
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});
$__System.registerDynamic('142', ['139', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('139');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
          max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (;;) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  })($__require('96'));
});
$__System.registerDynamic('143', ['139', '13b', '13c', '141', '142', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('139');
    var adler32 = $__require('13b');
    var crc32 = $__require('13c');
    var inflate_fast = $__require('141');
    var inflate_table = $__require('142');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix, distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (;;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 0x8b1f) {
              state.check = 0;
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              hbuf[2] = hold >>> 16 & 0xff;
              hbuf[3] = hold >>> 24 & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 0xff;
              state.head.os = hold >> 8;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 0x0400) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 0x0200) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 0x01;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 0x03) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 0x1f) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 0x1f) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 0x0f) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 0x07;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 0x7f);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;;) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;;) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  })($__require('96'));
});
$__System.registerDynamic('139', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

  exports.assign = function (obj /*from1, from2, from3, ...*/) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };

  // reduce buffer size, avoiding mem copy
  exports.shrinkBuf = function (buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };

  var fnTyped = {
    arraySet: function (dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      // Fallback to ordinary array
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function (chunks) {
      var i, l, len, pos, chunk, result;

      // calculate data length
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }

      // join chunks
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }

      return result;
    }
  };

  var fnUntyped = {
    arraySet: function (dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function (chunks) {
      return [].concat.apply([], chunks);
    }
  };

  // Enable/Disable typed arrays use, for testing
  //
  exports.setTyped = function (on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };

  exports.setTyped(TYPED_OK);
});
$__System.registerDynamic('13f', ['139', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('139');
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (var q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function (str) {
      var buf,
          c,
          c2,
          m_pos,
          i,
          str_len = str.length,
          buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | c >>> 6;
          buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | c >>> 12;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        } else {
          buf[i++] = 0xf0 | c >>> 18;
          buf[i++] = 0x80 | c >>> 12 & 0x3f;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65537) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = '';
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function (buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function (str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function (buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 0x3f;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
          utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function (buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  })($__require('96'));
});
$__System.registerDynamic('13d', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var global = this || self,
      GLOBAL = global;
  module.exports = {
    2: 'need dictionary', /* Z_NEED_DICT       2  */
    1: 'stream end', /* Z_STREAM_END      1  */
    0: '', /* Z_OK              0  */
    '-1': 'file error', /* Z_ERRNO         (-1) */
    '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
    '-3': 'data error', /* Z_DATA_ERROR    (-3) */
    '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
    '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
    '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
  };
});
$__System.registerDynamic('140', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var global = this || self,
      GLOBAL = global;
  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */
    this.avail_in = 0;
    /* total number of input bytes read so far */
    this.total_in = 0;
    /* next output byte should be put there */
    this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */
    this.avail_out = 0;
    /* total number of bytes output so far */
    this.total_out = 0;
    /* last error message, NULL if no error */
    this.msg = '' /*Z_NULL*/;
    /* not visible by applications */
    this.state = null;
    /* best guess about the data type: binary or text */
    this.data_type = 2 /*Z_UNKNOWN*/;
    /* adler32 value of the uncompressed data */
    this.adler = 0;
  }

  module.exports = ZStream;
});
$__System.registerDynamic('144', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var global = this || self,
      GLOBAL = global;
  function GZheader() {
    /* true if compressed data believed to be text */
    this.text = 0;
    /* modification time */
    this.time = 0;
    /* extra flags (not used when writing a gzip file) */
    this.xflags = 0;
    /* operating system */
    this.os = 0;
    /* pointer to extra field or Z_NULL if none */
    this.extra = null;
    /* extra field length (valid if extra != Z_NULL) */
    this.extra_len = 0; // Actually, we don't need it in JS,
    // but leave for few code modifications

    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //

    /* space at extra (only when reading header) */
    // this.extra_max  = 0;
    /* pointer to zero-terminated file name or Z_NULL */
    this.name = '';
    /* space at name (only when reading header) */
    // this.name_max   = 0;
    /* pointer to zero-terminated comment or Z_NULL */
    this.comment = '';
    /* space at comment (only when reading header) */
    // this.comm_max   = 0;
    /* true if there was or will be a header crc */
    this.hcrc = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */
    this.done = false;
  }

  module.exports = GZheader;
});
$__System.registerDynamic('145', ['143', '139', '13f', '146', '13d', '140', '144', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var zlib_inflate = $__require('143');
    var utils = $__require('139');
    var strings = $__require('13f');
    var c = $__require('146');
    var msg = $__require('13d');
    var ZStream = $__require('140');
    var GZheader = $__require('144');
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ''
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = '';
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
    }
    Inflate.prototype.push = function (data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var dict;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === 'string') {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          if (typeof dictionary === 'string') {
            dict = strings.string2buf(dictionary);
          } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
            dict = new Uint8Array(dictionary);
          } else {
            dict = dictionary;
          }
          status = zlib_inflate.inflateSetDictionary(this.strm, dict);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === 'string') {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function (status) {
      if (status === c.Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  })($__require('96'));
});
$__System.registerDynamic('146', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var global = this || self,
      GLOBAL = global;
  module.exports = {

    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,

    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,

    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
});
$__System.registerDynamic('147', ['139', '13e', '145', '146'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var assign = $__require('139').assign;
  var deflate = $__require('13e');
  var inflate = $__require('145');
  var constants = $__require('146');
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
});
$__System.registerDynamic("148", ["147"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("147");
});
$__System.registerDynamic('149', ['148', '116', '115'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';
  var pako = $__require('148');
  var utils = $__require('116');
  var GenericWorker = $__require('115');
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  exports.magic = "\x08\x00";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = new pako[action]({
      raw: true,
      level: options.level || -1
    });
    this.meta = {};
    var self = this;
    this._pako.onData = function (data) {
      self.push({
        data: data,
        meta: self.meta
      });
    };
  }
  utils.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
  };
});
$__System.registerDynamic('12b', ['115', '149'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var GenericWorker = $__require('115');
  exports.STORE = {
    magic: "\x00\x00",
    compressWorker: function (compressionOptions) {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function () {
      return new GenericWorker("STORE decompression");
    }
  };
  exports.DEFLATE = $__require('149');
});
$__System.registerDynamic('14a', ['135', '116', '126', '128', '125', '12b', '121', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var readerFor = $__require('135');
    var utils = $__require('116');
    var CompressedObject = $__require('126');
    var crc32fn = $__require('128');
    var utf8 = $__require('125');
    var compressions = $__require('12b');
    var support = $__require('121');
    var MADE_BY_DOS = 0x00;
    var MADE_BY_UNIX = 0x03;
    var findCompression = function (compressionMethod) {
      for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      isEncrypted: function () {
        return (this.bitFlag & 0x0001) === 0x0001;
      },
      useUTF8: function () {
        return (this.bitFlag & 0x0800) === 0x0800;
      },
      readLocalPart: function (reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      readCentralPart: function (reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 0x3F;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
          this.dir = true;
        }
      },
      parseZIP64ExtraField: function (reader) {
        if (!this.extraFields[0x0001]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[0x0001].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      readExtraFields: function (reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      handleUTF8: function () {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      findExtraFieldUnicodePath: function () {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      findExtraFieldUnicodeComment: function () {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module.exports = ZipEntry;
  })($__require('96'));
});
$__System.registerDynamic('125', ['116', '121', '12f', '115', '102', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    var utils = $__require('116');
    var support = $__require('121');
    var nodejsUtils = $__require('12f');
    var GenericWorker = $__require('115');
    var _utf8len = new Array(256);
    for (var i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function (str) {
      var buf,
          c,
          c2,
          m_pos,
          i,
          str_len = str.length,
          buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | c >>> 6;
          buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | c >>> 12;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        } else {
          buf[i++] = 0xf0 | c >>> 18;
          buf[i++] = 0x80 | c >>> 12 & 0x3f;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        }
      }
      return buf;
    };
    var utf8border = function (buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var buf2string = function (buf) {
      var str, i, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 0x3f;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
          utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBuffer(str, "utf-8");
      }
      return string2buf(str);
    };
    exports.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function (chunk) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function () {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function (chunk) {
      this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports.Utf8EncodeWorker = Utf8EncodeWorker;
  })($__require('102').Buffer, $__require('96'));
});
$__System.registerDynamic('14b', ['135', '116', '129', '14a', '125', '121', '102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var readerFor = $__require('135');
    var utils = $__require('116');
    var sig = $__require('129');
    var ZipEntry = $__require('14a');
    var utf8 = $__require('125');
    var support = $__require('121');
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      checkSignature: function (expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      isSignature: function (askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      readBlockEndOfCentral: function () {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      readBlockZip64EndOfCentral: function () {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      readBlockZip64EndOfCentralLocator: function () {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      readLocalFiles: function () {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      readCentralDir: function () {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({ zip64: this.zip64 }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {}
        }
      },
      readEndOfCentral: function () {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip : can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function (data) {
        this.reader = readerFor(data);
      },
      load: function (data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module.exports = ZipEntries;
  })($__require('102').Buffer);
});
$__System.registerDynamic('115', ['96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        'data': [],
        'end': [],
        'error': []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      push: function (chunk) {
        this.emit("data", chunk);
      },
      end: function () {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      error: function (e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      on: function (name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      cleanUp: function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      emit: function (name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      pipe: function (next) {
        return next.registerPrevious(this);
      },
      registerPrevious: function (previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self = this;
        previous.on('data', function (chunk) {
          self.processChunk(chunk);
        });
        previous.on('end', function () {
          self.end();
        });
        previous.on('error', function (e) {
          self.error(e);
        });
        return this;
      },
      pause: function () {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      resume: function () {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      flush: function () {},
      processChunk: function (chunk) {
        this.push(chunk);
      },
      withStreamInfo: function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      mergeStreamInfo: function () {
        for (var key in this.extraStreamInfo) {
          if (!this.extraStreamInfo.hasOwnProperty(key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      lock: function () {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      toString: function () {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module.exports = GenericWorker;
  })($__require('96'));
});
$__System.registerDynamic('128', ['116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  function makeTable() {
    var c,
        table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }
    return crc ^ -1;
  }
  module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
});
$__System.registerDynamic('120', ['116', '121'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var support = $__require('121');
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  exports.encode = function (input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0,
        len = input.length,
        remainingBytes = len;
    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  exports.decode = function (input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0,
        resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
});
$__System.registerDynamic('14c', ['14d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('14d');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
$__System.registerDynamic('14e', ['14f', '150', '151'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('14f') && !$__require('150')(function () {
    return Object.defineProperty($__require('151')('div'), 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
$__System.registerDynamic('152', ['14d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('14d');
  module.exports = function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };
});
$__System.registerDynamic('153', ['14c', '14e', '152', '14f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('14c'),
      IE8_DOM_DEFINE = $__require('14e'),
      toPrimitive = $__require('152'),
      dP = Object.defineProperty;
  exports.f = $__require('14f') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) {}
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
});
$__System.registerDynamic("154", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
});
$__System.registerDynamic("150", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('14f', ['150'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('150')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
$__System.registerDynamic('155', ['153', '154', '14f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var dP = $__require('153'),
      createDesc = $__require('154');
  module.exports = $__require('14f') ? function (object, key, value) {
    return dP.f(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
});
$__System.registerDynamic('156', ['157', '158', '159', '155'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('157'),
      core = $__require('158'),
      ctx = $__require('159'),
      hide = $__require('155'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE],
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0:
                return new C();
              case 1:
                return new C(a);
              case 2:
                return new C(a, b);
            }
            return new C(a, b, c);
          }
          return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  module.exports = $export;
});
$__System.registerDynamic('15a', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('159', ['15a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('15a');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic("15b", [], true, function ($__require, exports, module) {
                  var global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
});
$__System.registerDynamic('15c', ['157'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('157').document && document.documentElement;
});
$__System.registerDynamic('14d', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
$__System.registerDynamic('151', ['14d', '157'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var isObject = $__require('14d'),
        document = $__require('157').document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function (it) {
        return is ? document.createElement(it) : {};
    };
});
$__System.registerDynamic('157', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic("15d", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('15e', ['159', '15b', '15c', '151', '157', '15d', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var ctx = $__require('159'),
        invoke = $__require('15b'),
        html = $__require('15c'),
        cel = $__require('151'),
        global = $__require('157'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function () {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listener = function (event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function () {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('15d')(process) == 'process') {
        defer = function (id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function (id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listener, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function (id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function (id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('96'));
});
$__System.registerDynamic('15f', ['156', '15e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('156'),
      $task = $__require('15e');
  $export($export.G + $export.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
});
$__System.registerDynamic('158', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '2.3.0' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('160', ['15f', '158'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('15f');
  module.exports = $__require('158').setImmediate;
});
$__System.registerDynamic('116', ['121', '120', '12f', '160', '122', '102', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    var support = $__require('121');
    var base64 = $__require('120');
    var nodejsUtils = $__require('12f');
    var setImmediate = $__require('160');
    var external = $__require('122');
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports.newBlob = function (parts, type) {
      exports.checkSupport("blob");
      try {
        return new Blob(parts, { type: type });
      } catch (e) {
        try {
          var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i++) {
            builder.append(parts[i]);
          }
          return builder.getBlob(type);
        } catch (e) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
      }
      return array;
    }
    var arrayToStringHelper = {
      stringifyByChunk: function (array, type, chunk) {
        var result = [],
            k = 0,
            len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      stringifyByChar: function (array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        uint8array: function () {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        nodebuffer: function () {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.newBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536,
          type = exports.getTypeOf(array),
          canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function (input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function (input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function (input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function (input) {
        return stringToArrayLike(input, nodejsUtils.newBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function (input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function (input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function (input) {
        return nodejsUtils.newBuffer(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function (input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function (input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function (input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function (input) {
        return nodejsUtils.newBuffer(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function (input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function (input) {
        var copy = new Uint8Array(input.length);
        if (input.length) {
          copy.set(input, 0);
        }
        return copy.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function (input) {
        return nodejsUtils.newBuffer(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function (input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function (input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function (input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function (outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports.getTypeOf = function (input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function (type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function (str) {
      var res = '',
          code,
          i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.delay = function (callback, args, self) {
      setImmediate(function () {
        callback.apply(self || null, args || []);
      });
    };
    exports.inherits = function (ctor, superCtor) {
      var Obj = function () {};
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports.extend = function () {
      var result = {},
          i,
          attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function (data) {
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onload = function (e) {
              resolve(e.target.result);
            };
            reader.onerror = function (e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function (data) {
        var dataType = exports.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(new Error("The data of '" + name + "' is in an unsupported format !"));
        }
        if (dataType === "arraybuffer") {
          data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  })($__require('102').Buffer, $__require('96'));
});
$__System.registerDynamic('137', ['115', '128', '116'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var GenericWorker = $__require('115');
  var crc32 = $__require('128');
  var utils = $__require('116');
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  module.exports = Crc32Probe;
});
$__System.registerDynamic("12f", ["102"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    module.exports = {
      isNode: typeof Buffer !== "undefined",
      newBuffer: function (data, encoding) {
        return new Buffer(data, encoding);
      },
      isBuffer: function (b) {
        return Buffer.isBuffer(b);
      },
      isStream: function (obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  })($__require("102").Buffer);
});
$__System.registerDynamic('161', ['116', '122', '125', '14b', '137', '12f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var utils = $__require('116');
  var external = $__require('122');
  var utf8 = $__require('125');
  var utils = $__require('116');
  var ZipEntries = $__require('14b');
  var Crc32Probe = $__require('137');
  var nodejsUtils = $__require('12f');
  function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
      var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
      worker.on("error", function (e) {
        reject(e);
      }).on("end", function () {
        if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  module.exports = function (data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf8.utf8decode
    });
    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
      return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
      var zipEntries = new ZipEntries(options);
      zipEntries.load(data);
      return zipEntries;
    }).then(function checkCRC32(zipEntries) {
      var promises = [external.Promise.resolve(zipEntries)];
      var files = zipEntries.files;
      if (options.checkCRC32) {
        for (var i = 0; i < files.length; i++) {
          promises.push(checkEntryCRC32(files[i]));
        }
      }
      return external.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries = results.shift();
      var files = zipEntries.files;
      for (var i = 0; i < files.length; i++) {
        var input = files[i];
        zip.file(input.fileNameStr, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
      }
      if (zipEntries.zipComment.length) {
        zip.comment = zipEntries.zipComment;
      }
      return zip;
    });
  };
});
$__System.registerDynamic('162', ['163', '168', '164', '165', '166', '167', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    exports = module.exports = $__require('163');
    exports.Stream = $__require('168');
    exports.Readable = exports;
    exports.Writable = $__require('164');
    exports.Duplex = $__require('165');
    exports.Transform = $__require('166');
    exports.PassThrough = $__require('167');
    if (!process.browser && process.env.READABLE_STREAM === 'disable') {
      module.exports = $__require('168');
    }
  })($__require('96'));
});
$__System.registerDynamic('169', ['164'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('164');
});
$__System.registerDynamic('16a', ['165'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('165');
});
$__System.registerDynamic('16b', ['166'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('166');
});
$__System.registerDynamic('16c', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
});
$__System.registerDynamic("16d", ["16c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("16c");
});
$__System.registerDynamic('16e', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function (n) {
    if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };

  EventEmitter.prototype.emit = function (type) {
    var er, handler, len, args, i, listeners;

    if (!this._events) this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }

    handler = this._events[type];

    if (isUndefined(handler)) return false;

    if (isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++) args[i - 1] = arguments[i];

      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++) listeners[i].apply(this, args);
    }

    return true;
  };

  EventEmitter.prototype.addListener = function (type, listener) {
    var m;

    if (!isFunction(listener)) throw TypeError('listener must be a function');

    if (!this._events) this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;else if (isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          // not supported in IE 10
          console.trace();
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function (type, listener) {
    if (!isFunction(listener)) throw TypeError('listener must be a function');

    var fired = false;

    function g() {
      this.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }

    g.listener = listener;
    this.on(type, g);

    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function (type, listener) {
    var list, position, length, i;

    if (!isFunction(listener)) throw TypeError('listener must be a function');

    if (!this._events || !this._events[type]) return this;

    list = this._events[type];
    length = list.length;
    position = -1;

    if (list === listener || isFunction(list.listener) && list.listener === listener) {
      delete this._events[type];
      if (this._events.removeListener) this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }

      if (this._events.removeListener) this.emit('removeListener', type, listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function (type) {
    var key, listeners;

    if (!this._events) return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }

    listeners = this._events[type];

    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      // LIFO order
      while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];

    return this;
  };

  EventEmitter.prototype.listeners = function (type) {
    var ret;
    if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type]) ret = 0;else if (isFunction(emitter._events[type])) ret = 1;else ret = emitter._events[type].length;
    return ret;
  };

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isUndefined(arg) {
    return arg === void 0;
  }
});
$__System.registerDynamic("16f", ["16e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("16e");
});
$__System.registerDynamic('170', ['16f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('events') : $__require('16f');
});
$__System.registerDynamic("e7", ["170"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("170");
});
$__System.registerDynamic('171', ['102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var Buffer = $__require('102').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function (encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function (encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function (buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function (buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function (buffer) {
      var res = '';
      if (buffer && buffer.length) res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })($__require('102').Buffer);
});
$__System.registerDynamic("172", ["171"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("171");
});
$__System.registerDynamic('163', ['16d', '102', 'e7', '168', '173', '119', '@empty', '165', '172', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    module.exports = Readable;
    var isArray = $__require('16d');
    var Buffer = $__require('102').Buffer;
    Readable.ReadableState = ReadableState;
    var EE = $__require('e7').EventEmitter;
    if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = $__require('168');
    var util = $__require('173');
    util.inherits = $__require('119');
    var StringDecoder;
    var debug = $__require('@empty');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = $__require('165');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = $__require('172').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = $__require('165');
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended) onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
          if (!addToFront) state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder) StringDecoder = $__require('172').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended) return 0;
      if (state.objectMode) return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
      }
      if (n <= 0) return 0;
      if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else return state.length;
      }
      return n;
    }
    Readable.prototype.read = function (n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended) state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
      if (!util.isNull(ret)) this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) process.nextTick(function () {
          emitReadable_(stream);
        });else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function () {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0) dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function (ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function () {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function () {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length) return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0) return null;
      if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
        if (stringMode) ret = list.join('');else ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode) ret = '';else ret = new Buffer(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function () {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  })($__require('102').Buffer, $__require('96'));
});
$__System.registerDynamic('164', ['102', '173', '119', '168', '165', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    module.exports = Writable;
    var Buffer = $__require('102').Buffer;
    Writable.WritableState = WritableState;
    var util = $__require('173');
    util.inherits = $__require('119');
    var Stream = $__require('168');
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = $__require('165');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function (er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = $__require('165');
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function () {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function () {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (!util.isFunction(cb)) cb = function () {};
      if (state.ended) writeAfterEnd(this, state, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function () {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function () {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));else doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync) process.nextTick(function () {
        state.pendingcb--;
        cb(er);
      });else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function () {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++) cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
    }
  })($__require('102').Buffer, $__require('96'));
});
$__System.registerDynamic('165', ['173', '119', '163', '164', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    };
    var util = $__require('173');
    util.inherits = $__require('119');
    var Readable = $__require('163');
    var Writable = $__require('164');
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function (method) {
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })($__require('96'));
});
$__System.registerDynamic('166', ['165', '173', '119', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    module.exports = Transform;
    var Duplex = $__require('165');
    var util = $__require('173');
    util.inherits = $__require('119');
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data)) stream.push(data);
      if (cb) cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function () {
        if (util.isFunction(this._flush)) this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }
    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function (n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er) return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length) throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming) throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('96'));
});
$__System.registerDynamic('174', ['102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === '[object Array]';
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === '[object Error]' || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })($__require('102').Buffer);
});
$__System.registerDynamic("173", ["174"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("174");
});
$__System.registerDynamic('175', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
});
$__System.registerDynamic("119", ["175"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("175");
});
$__System.registerDynamic('167', ['166', '173', '119'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = PassThrough;
  var Transform = $__require('166');
  var util = $__require('173');
  util.inherits = $__require('119');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };
});
$__System.registerDynamic('176', ['167'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('167');
});
$__System.registerDynamic('168', ['e7', '119', '162', '169', '16a', '16b', '176'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = Stream;
  var EE = $__require('e7').EventEmitter;
  var inherits = $__require('119');
  inherits(Stream, EE);
  Stream.Readable = $__require('162');
  Stream.Writable = $__require('169');
  Stream.Duplex = $__require('16a');
  Stream.Transform = $__require('16b');
  Stream.PassThrough = $__require('176');
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function (dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function') dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
});
$__System.registerDynamic("177", ["168"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("168");
});
$__System.registerDynamic('178', ['177'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('stream') : $__require('177');
});
$__System.registerDynamic("179", ["178"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("178");
});
$__System.registerDynamic("11e", ["179"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /*
   * This file is used by module bundlers (browserify/webpack/etc) when
   * including a stream implementation. We use "readable-stream" to get a
   * consistent behavior between nodejs versions but bundlers often have a shim
   * for "stream". Using this shim greatly improve the compatibility and greatly
   * reduce the final size of the bundle (only one stream implementation, not
   * two).
   */
  module.exports = $__require("179");
});
$__System.registerDynamic("121", ["11e", "102"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    exports.base64 = true;
    exports.array = true;
    exports.string = true;
    exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports.nodebuffer = typeof Buffer !== "undefined";
    exports.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports.blob = false;
    } else {
      var buffer = new ArrayBuffer(0);
      try {
        exports.blob = new Blob([buffer], { type: "application/zip" }).size === 0;
      } catch (e) {
        try {
          var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          var builder = new Builder();
          builder.append(buffer);
          exports.blob = builder.getBlob('application/zip').size === 0;
        } catch (e) {
          exports.blob = false;
        }
      }
    }
    try {
      exports.nodestream = !!$__require("11e").Readable;
    } catch (e) {
      exports.nodestream = false;
    }
  })($__require("102").Buffer);
});
$__System.registerDynamic('12e', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  exports.base64 = false;
  exports.binary = false;
  exports.dir = false;
  exports.createFolders = true;
  exports.date = null;
  exports.compression = null;
  exports.compressionOptions = null;
  exports.comment = null;
  exports.unixPermissions = null;
  exports.dosPermissions = null;
});
$__System.registerDynamic('17a', ['96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        var called = 0;
        var observer = new Mutation(nextTick);
        var element = global.document.createTextNode('');
        observer.observe(element, { characterData: true });
        scheduleDrain = function () {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
        var channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function () {
          channel.port2.postMessage(0);
        };
      } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
        scheduleDrain = function () {
          var scriptEl = global.document.createElement('script');
          scriptEl.onreadystatechange = function () {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function () {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function () {
        process.nextTick(nextTick);
      };
    }
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  })($__require('96'));
});
$__System.registerDynamic("17b", ["17a"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("17a");
});
$__System.registerDynamic('17c', ['17b', '96'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var immediate = $__require('17b');
    function INTERNAL() {}
    var handlers = {};
    var REJECTED = ['REJECTED'];
    var FULFILLED = ['FULFILLED'];
    var PENDING = ['PENDING'];
    if (!process.browser) {
      var UNHANDLED = ['UNHANDLED'];
    }
    module.exports = Promise;
    function Promise(resolver) {
      if (typeof resolver !== 'function') {
        throw new TypeError('resolver must be a function');
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise.prototype.catch = function (onRejected) {
      return this.then(null, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
      if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === 'function') {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === 'function') {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function (value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function (value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function (value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function (value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function () {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function (self, value) {
      var result = tryCatch(getThen, value);
      if (result.status === 'error') {
        return handlers.reject(self, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self, thenable);
      } else {
        self.state = FULFILLED;
        self.outcome = value;
        var i = -1;
        var len = self.queue.length;
        while (++i < len) {
          self.queue[i].callFulfilled(value);
        }
      }
      return self;
    };
    handlers.reject = function (self, error) {
      self.state = REJECTED;
      self.outcome = error;
      if (!process.browser) {
        if (self.handled === UNHANDLED) {
          immediate(function () {
            if (self.handled === UNHANDLED) {
              process.emit('unhandledRejection', error, self);
            }
          });
        }
      }
      var i = -1;
      var len = self.queue.length;
      while (++i < len) {
        self.queue[i].callRejected(error);
      }
      return self;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
        return function appyThen() {
          then.apply(obj, arguments);
        };
      }
    }
    function safelyResolveThenable(self, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result = tryCatch(tryToUnwrap);
      if (result.status === 'error') {
        onError(result.value);
      }
    }
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = 'success';
      } catch (e) {
        out.status = 'error';
        out.value = e;
      }
      return out;
    }
    Promise.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise.all = all;
    function all(iterable) {
      var self = this;
      if (Object.prototype.toString.call(iterable) !== '[object Array]') {
        return this.reject(new TypeError('must be an array'));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i) {
        self.resolve(value).then(resolveFromAll, function (error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
      }
    }
    Promise.race = race;
    function race(iterable) {
      var self = this;
      if (Object.prototype.toString.call(iterable) !== '[object Array]') {
        return this.reject(new TypeError('must be an array'));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self.resolve(value).then(function (response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function (error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  })($__require('96'));
});
$__System.registerDynamic("17d", ["17c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("17c");
});
$__System.registerDynamic("122", ["17d"], true, function ($__require, exports, module) {
    /* global Promise */
    'use strict';

    // load the global object first:
    // - it should be better integrated in the system (unhandledRejection in node)
    // - the environment may have a custom Promise implementation (see zone.js)

    var global = this || self,
        GLOBAL = global;
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
        ES6Promise = Promise;
    } else {
        ES6Promise = $__require("17d");
    }

    /**
     * Let the user use/change some implementations.
     */
    module.exports = {
        Promise: ES6Promise
    };
});
$__System.registerDynamic("17e", ["12d", "161", "121", "12e", "122"], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip();
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = {};
    this.comment = null;
    this.root = "";
    this.clone = function () {
      var newObj = new JSZip();
      for (var i in this) {
        if (typeof this[i] !== "function") {
          newObj[i] = this[i];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = $__require("12d");
  JSZip.prototype.loadAsync = $__require("161");
  JSZip.support = $__require("121");
  JSZip.defaults = $__require("12e");
  JSZip.version = "3.1.3";
  JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
  };
  JSZip.external = $__require("122");
  module.exports = JSZip;
});
$__System.registerDynamic("111", ["17e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("17e");
});
$__System.registerDynamic('17f', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
$__System.registerDynamic("180", ["17f"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("17f");
});
$__System.registerDynamic('181', ['180'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire ? process : $__require('180');
});
$__System.registerDynamic("96", ["181"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("181");
});
$__System.registerDynamic("182", ["111", "96"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    const JSzip = $__require("111");
    module.exports = function openzip(zipdataAsPromise, SMRS, progress) {
      "use strict";

      var data = { sims: [] };
      const simRegex = /\/([A-Z])\/sim.json$/;
      const configRegex = /\/config.json$/;
      const logRegex = /\/([A-Z])\/(\w+)\.csv$/;
      function configFromJSON(s) {
        data.config = JSON.parse(s);
      }
      function simFromJSON(path) {
        var parse = simRegex.exec(path);
        var slot;
        try {
          slot = parse[1].charCodeAt(0) - "A".charCodeAt(0);
        } catch (e) {
          slot = -1;
        }
        return function (s) {
          if (slot >= 0 && slot < 26) {
            data.sims[slot] = new SMRS.Simulation(JSON.parse(s));
          } else {
            throw new Error("simFromJSON: bad slot " + slot + " in path: " + path);
          }
        };
      }
      function isLogFile(path) {
        var slot, logname;
        var parse = logRegex.exec(path);
        if (!parse) return false;
        try {
          slot = parse[1].charCodeAt(0) - "A".charCodeAt(0);
          logname = parse[2];
        } catch (e) {}
        return slot >= 0 && slot <= 26 && typeof logname === "string" && SMRS.logNames.indexOf(logname) >= 0;
      }
      function restoreLog(path) {
        var parse = logRegex.exec(path);
        var slot = parse[1].charCodeAt(0) - "A".charCodeAt(0);
        var logname = parse[2];
        return function (s) {
          var mylog = data.sims[slot].logs[logname];
          mylog.fromString(s);
        };
      }
      return new Promise(function (resolve, reject) {
        zipdataAsPromise.then(JSzip.loadAsync).then(function (zip) {
          var stage1 = [];
          zip.forEach(function (path, zipdata) {
            if (configRegex.test(path)) stage1.push(zipdata.async("string").then(configFromJSON).then(function () {
              progress("found config.json");
            }));
            if (simRegex.test(path)) stage1.push(zipdata.async("string").then(simFromJSON(path)).then(function () {
              progress("found " + path);
            }));
          });
          Promise.all(stage1).then(function () {
            var stage2 = [];
            zip.forEach(function (path, zipdata) {
              if (isLogFile(path)) stage2.push(zipdata.async("string").then(restoreLog(path)).then(function () {
                progress("found " + path);
              }));
            });
            Promise.all(stage2).then(function () {
              resolve(data);
            }).then(function () {
              progress(" finished reading zip file, processing... ");
            }, function (e) {
              progress(" ERROR (stage 2): " + e);
              reject(e);
            });
          }, function (e) {
            progress(" ERROR (stage 1): " + e);
            reject(e);
          });
        });
      });
    };
  })($__require("96"));
});
$__System.registerDynamic("183", ["182"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("182");
});
$__System.registerDynamic('184', [], true, function ($__require, exports, module) {
	var global = this || self,
	    GLOBAL = global;
	/* */
	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var PLUS = '+'.charCodeAt(0);
		var SLASH = '/'.charCodeAt(0);
		var NUMBER = '0'.charCodeAt(0);
		var LOWER = 'a'.charCodeAt(0);
		var UPPER = 'A'.charCodeAt(0);
		var PLUS_URL_SAFE = '-'.charCodeAt(0);
		var SLASH_URL_SAFE = '_'.charCodeAt(0);

		function decode(elt) {
			var code = elt.charCodeAt(0);
			if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
			if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
			if (code < NUMBER) return -1; //no match
			if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
			if (code < UPPER + 26) return code - UPPER;
			if (code < LOWER + 26) return code - LOWER + 26;
		}

		function b64ToByteArray(b64) {
			var i, j, l, tmp, placeHolders, arr;

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4');
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length;
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders);

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length;

			var L = 0;

			function push(v) {
				arr[L++] = v;
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
				push((tmp & 0xFF0000) >> 16);
				push((tmp & 0xFF00) >> 8);
				push(tmp & 0xFF);
			}

			if (placeHolders === 2) {
				tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
				push(tmp & 0xFF);
			} else if (placeHolders === 1) {
				tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
				push(tmp >> 8 & 0xFF);
				push(tmp & 0xFF);
			}

			return arr;
		}

		function uint8ToBase64(uint8) {
			var i,
			    extraBytes = uint8.length % 3,
			    // if we have 1 byte left, pad 2 bytes
			output = "",
			    temp,
			    length;

			function encode(num) {
				return lookup.charAt(num);
			}

			function tripletToBase64(num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
				output += tripletToBase64(temp);
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1];
					output += encode(temp >> 2);
					output += encode(temp << 4 & 0x3F);
					output += '==';
					break;
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
					output += encode(temp >> 10);
					output += encode(temp >> 4 & 0x3F);
					output += encode(temp << 2 & 0x3F);
					output += '=';
					break;
			}

			return output;
		}

		exports.toByteArray = b64ToByteArray;
		exports.fromByteArray = uint8ToBase64;
	})(typeof exports === 'undefined' ? this.base64js = {} : exports);
});
$__System.registerDynamic("185", ["184"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("184");
});
$__System.registerDynamic("186", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
});
$__System.registerDynamic("187", ["186"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("186");
});
$__System.registerDynamic('188', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
});
$__System.registerDynamic("189", ["188"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("188");
});
$__System.registerDynamic('18a', ['185', '187', '189'], true, function ($__require, exports, module) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var base64 = $__require('185');
  var ieee754 = $__require('187');
  var isArray = $__require('189');

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192; // not used by this implementation

  var rootParent = {};

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
   *     on objects.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function () {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && // typed array instances can be augmented
      arr.constructor === Bar && // constructor can be set
      typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
      arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
    } catch (e) {
      return false;
    }
  }

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  /**
   * Class: Buffer
   * =============
   *
   * The Buffer constructor returns instances of `Uint8Array` that are augmented
   * with function properties for all the node `Buffer` API functions. We use
   * `Uint8Array` so that square bracket notation works as expected -- it returns
   * a single octet.
   *
   * By augmenting the instances, we can avoid modifying the `Uint8Array`
   * prototype.
   */
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
      if (arguments.length > 1) return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }

    // Common case.
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }

    // Slightly less common case.
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }

    // Unusual.
    return fromObject(this, arg);
  }

  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

    // Assumption: byteLength() return value is always < kMaxLength.
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);

    that.write(string, encoding);
    return that;
  }

  function fromObject(that, object) {
    if (Buffer.isBuffer(object)) return fromBuffer(that, object);

    if (isArray(object)) return fromArray(that, object);

    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }

    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }

    if (object.length) return fromArrayLike(that, object);

    return fromJsonObject(that, object);
  }

  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }

  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Duplicate of fromArray() to keep fromArray() monomorphic.
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    // Truncating the elements is probably not what people expect from typed
    // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
    // of the old Buffer constructor.
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }

  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
  // Returns a zero-length buffer for inputs that don't conform to the spec.
  function fromJsonObject(that, object) {
    var array;
    var length = 0;

    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    // pre-set for values that may exist in the future
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }

  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that.length = length;
      that._isBuffer = true;
    }

    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool) that.parent = rootParent;

    return that;
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }

  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }

  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;

    var x = a.length;
    var y = b.length;

    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i]) break;

      ++i;
    }

    if (i !== len) {
      x = a[i];
      y = b[i];
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

    if (list.length === 0) {
      return new Buffer(0);
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }

    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };

  function byteLength(string, encoding) {
    if (typeof string !== 'string') string = '' + string;

    var len = string.length;
    if (len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        // Deprecated
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;

    if (!encoding) encoding = 'utf8';
    if (start < 0) start = 0;
    if (end > this.length) end = this.length;
    if (end <= start) return '';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'binary':
          return binarySlice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return 0;
    return Buffer.compare(this, b);
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
    byteOffset >>= 0;

    if (this.length === 0) return -1;
    if (byteOffset >= this.length) return -1;

    // Negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

    if (typeof val === 'string') {
      if (val.length === 0) return -1; // special case: looking for empty string always fails
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }

    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }

    throw new TypeError('val must be string, number or Buffer');
  };

  // `get` is deprecated
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };

  // `set` is deprecated
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new Error('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
      // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'binary':
          return binaryWrite(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }

  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }

    if (newBuf.length) newBuf.parent = this.parent || this;

    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
    if (offset < 0) throw new RangeError('index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  // fill(value, start=0, end=buffer.length)
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value) value = 0;
    if (!start) start = 0;
    if (!end) end = this.length;

    if (end < start) throw new RangeError('end < start');

    // Fill 0 bytes; we're done
    if (end === start) return;
    if (this.length === 0) return;

    if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }

    return this;
  };

  /**
   * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
   * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
   */
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return new Buffer(this).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0, len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };

  // HELPER FUNCTIONS
  // ================

  var BP = Buffer.prototype;

  /**
   * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
   */
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;

    // save reference to original Uint8Array set method before overwriting
    arr._set = arr.set;

    // deprecated
    arr.get = BP.get;
    arr.set = BP.set;

    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;

    return arr;
  };

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;

          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0) break;

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
});
$__System.registerDynamic("18b", ["18a"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("18a");
});
$__System.registerDynamic('18c', ['18b'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('buffer') : $__require('18b');
});
$__System.registerDynamic("102", ["18c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("18c");
});
$__System.registerDynamic('18d', ['102'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var clone = function () {
      'use strict';

      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function () {};
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function () {};
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function () {};
      }
      function clone(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === 'object') {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != 'undefined';
        if (typeof circular == 'undefined') circular = true;
        if (typeof depth == 'undefined') depth = Infinity;
        function _clone(parent, depth) {
          if (parent === null) return null;
          if (depth === 0) return parent;
          var child;
          var proto;
          if (typeof parent != 'object') {
            return parent;
          }
          if (_instanceof(parent, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent, nativePromise)) {
            child = new nativePromise(function (resolve, reject) {
              parent.then(function (value) {
                resolve(_clone(value, depth - 1));
              }, function (err) {
                reject(_clone(err, depth - 1));
              });
            });
          } else if (clone.__isArray(parent)) {
            child = [];
          } else if (clone.__isRegExp(parent)) {
            child = new RegExp(parent.source, __getRegExpFlags(parent));
            if (parent.lastIndex) child.lastIndex = parent.lastIndex;
          } else if (clone.__isDate(parent)) {
            child = new Date(parent.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent)) {
            child = new Buffer(parent.length);
            parent.copy(child);
            return child;
          } else if (_instanceof(parent, Error)) {
            child = Object.create(parent);
          } else {
            if (typeof prototype == 'undefined') {
              proto = Object.getPrototypeOf(parent);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent);
            allChildren.push(child);
          }
          if (_instanceof(parent, nativeMap)) {
            parent.forEach(function (value, key) {
              var keyChild = _clone(key, depth - 1);
              var valueChild = _clone(value, depth - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent, nativeSet)) {
            parent.forEach(function (value) {
              var entryChild = _clone(value, depth - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent[i], depth - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent[symbol], depth - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, { enumerable: false });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent[propertyName], depth - 1);
              Object.defineProperty(child, propertyName, { enumerable: false });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone.clonePrototype = function clonePrototype(parent) {
        if (parent === null) return null;
        var c = function () {};
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Date]';
      }
      clone.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Array]';
      }
      clone.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
      }
      clone.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = '';
        if (re.global) flags += 'g';
        if (re.ignoreCase) flags += 'i';
        if (re.multiline) flags += 'm';
        return flags;
      }
      clone.__getRegExpFlags = __getRegExpFlags;
      return clone;
    }();
    if (typeof module === 'object' && module.exports) {
      module.exports = clone;
    }
  })($__require('102').Buffer);
});
$__System.registerDynamic("f6", ["18d"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("18d");
});
$__System.registerDynamic("18e", ["f6"], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* Copyright 2017 Paul Brewer, Economic and Financial Technology Consulting LLC */
    /* This file is open source software.  The MIT License applies to this software. */

    /* jshint browserify:true,esnext:true,eqeqeq:true,undef:true,lastsemic:true,strict:true,unused:true */

    const clone = $__require("f6");

    function pad(x) {
        "use strict";

        return x < 10 ? "0" + x : '' + x;
    }

    function myDateStamp(thedate) {
        "use strict";

        const now = thedate || new Date();
        return '' + now.getUTCFullYear() + pad(now.getUTCMonth() + 1) + pad(now.getUTCDate()) + 'T' + pad(now.getUTCHours()) + pad(now.getUTCMinutes()) + pad(now.getUTCSeconds());
    }

    module.exports.myDateStamp = myDateStamp;

    function letter(n) {
        "use strict";

        var A = "A".charCodeAt(0);
        return String.fromCharCode(A + n);
    }

    module.exports.letter = letter;

    /**
     * creates a function that clones input object, and then overrides some properties with those in a clone of obj.com
    mon
     * @param {Object} obj object with a .common property, obj.common should also be an object
     * @return {function(c: Object):Object} clone of c with properties overridden by obj.common
     */

    function commonFrom(obj) {
        "use strict";

        return function (c) {
            const result = Object.assign({}, clone(c), clone(obj.common));
            return result;
        };
    }

    module.exports.commonFrom = commonFrom;

    /**
     * Create new simulations from ~ Jan-2017 original study cfg format 
     * @param {Object} cfg The study configuration
     * @param {Array<Object>} cfg.configurations An array of SMRS.Simulation() configurations, one for each independent simulation in a study.  
     * @param {Object} cfg.common Common simulation configuration settings to be forced in all simulations. (if there is a conflict, common has priority over and overrides configurations)
     * @param {Object} Simulation A reference to the (possibly forked) single-market-robot-simulator.Simulation constructor function
     * @return {Array<Object>} array of new SMRS.Simulation - each simulation will be initialized but not running
     */

    function makeClassicSimulations(cfg, Simulation) {
        "use strict";

        if (!cfg) return [];
        if (!Array.isArray(cfg.configurations)) return [];
        return cfg.configurations.map(commonFrom(cfg)).map(s => new Simulation(s));
    }

    module.exports.makeClassicSimulations = makeClassicSimulations;
});
$__System.registerDynamic("112", ["18e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("18e");
});
$__System.registerDynamic("18f", ["f6", "113", "183", "112"], true, function ($__require, exports, module) {
    /* */
    "use strict";

    var global = this || self,
        GLOBAL = global;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.App = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _slicedToArray = function () {
        function sliceIterator(arr, i) {
            var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;_e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }return _arr;
        }return function (arr, i) {
            if (Array.isArray(arr)) {
                return arr;
            } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
            } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
        };
    }();

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }(); /* Copyright 2016, 2017 Paul Brewer, Economic and Financial Technology Consulting LLC */
    /* This file is open source software.  The MIT License applies to this software.  */

    /* global Plotly:true, window:true, $:true */

    /* eslint no-console: "off" */
    /* eslint consistent-this: ["error", "app", "that"] */

    exports.adjustTitle = adjustTitle;

    var _clone = $__require("f6");

    var _clone2 = _interopRequireDefault(_clone);

    var _singleMarketRobotSimulatorSavezip = $__require("113");

    var _singleMarketRobotSimulatorSavezip2 = _interopRequireDefault(_singleMarketRobotSimulatorSavezip);

    var _singleMarketRobotSimulatorOpenzip = $__require("183");

    var _singleMarketRobotSimulatorOpenzip2 = _interopRequireDefault(_singleMarketRobotSimulatorOpenzip);

    var _singleMarketRobotSimulatorStudy = $__require("112");

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }return arr2;
        } else {
            return Array.from(arr);
        }
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    /**
     * Change Plotly plot title by prepending, appending, or replacing existing plot title
     * @param {Array<Object>} plotParams The plot to be modified -- a two element Array of [PlotlyTraces, PlotlyLayout]
     * @param {{prepend: ?string, append: ?string, replace: ?string}} modifier modifications to title
     */

    function adjustTitle(plotParams, modifier) {
        var layout = plotParams[1];
        if (layout) {
            if (modifier.replace && modifier.replace.length > 0) layout.title = modifier.replace;
            if (layout.title) {
                if (modifier.prepend && modifier.prepend.length > 0) layout.title = modifier.prepend + layout.title;
                if (modifier.append && modifier.append.length > 0) layout.title += modifier.append;
            }
        }
    }

    var App = exports.App = function () {

        /**
         * Create App with given settings.  Many of these settings are required.
         * @param {Object} options
         * @param {Object} options.SMRS reference to either the imported module single-market-robot-simulator or a fork 
         * @param {Object} options.DB "database" instance of single-market-robot-simulator-db-local or single-market-robot-simulator-webdismay for storing simulation configurations
         * @param {Object} options.Visuals object describing visualizations of completed simulations and parameters, to be interpreted by single-market-robot-simulator-viz-plotly
         * @param {Object} options.editorConfigSchema JSON Schema object for json-editor relevant to user editing of simulation configurations
         * @param {Object} options.editorStartValue default simulation configuration for editing if none are defined
         * @param {string} options.saveList name that will open list of save configurations when passed to options.DB.openList()
         * @param {string} options.trashList name that will open trash list of abandoned configurations when passed to options.DB.openList()
         * @param {Array<Array<string>>} options.behavior click and eventmap stored as Array of 2 or 3 element arrays [jqSelector, appMethodName, [ eventType = click ] ]
         */

        function App(options) {
            _classCallCheck(this, App);

            this.SMRS = options.SMRS;
            this.DB = options.DB;
            this.Visuals = options.Visuals;
            this.editorConfigSchema = options.editorConfigSchema;
            this.editorStartValue = options.editorStartValue;
            if (this.DB) {
                this.saveList = this.DB.openList(options.saveList);
                this.trashList = this.DB.openList(options.trashList);
            }
            this.behavior = options.behavior;
            this.editor = 0;
            this.periodTimers = [];
            this.study = 0;
            this.studies = [];
            this.chosenStudyIndex = 0;
            this.sims = [];
            this.visualIndex = 0;
        }

        /**
         * Create new simulations for study 
         * @param {Object} studyConfig The study configuration
         * @param {Array<Object>} studyConfig.configurations An array of SMRS.Simulation() configurations, one for each independent simulation in a study.  
         * @param {Object} studyConfig.common Common single-market-robot-simulator configuration settings to be forced in all simulations in a study.
         * @return {Array<Object>} array of new SMRS.Simulation - each simulation will be initialized but not running
         */

        _createClass(App, [{
            key: "simulations",
            value: function simulations(studyConfig) {
                var app = this;
                return (0, _singleMarketRobotSimulatorStudy.makeClassicSimulations)(studyConfig, app.SMRS.Simulation);
            }

            /** 
             * Get current study
             * @return {Object} study configuration
             */

        }, {
            key: "getStudy",
            value: function getStudy() {
                var app = this;
                return (0, _clone2.default)(app.study);
            }

            /**
             * Set current study 
             * @param {Object} studyConfig study configuraion
             */

        }, {
            key: "setStudy",
            value: function setStudy(studyConfig) {
                var app = this;
                if (studyConfig) {
                    app.study = (0, _clone2.default)(studyConfig);
                    if (app.editor) {
                        app.editor.setValue((0, _clone2.default)(studyConfig));
                    }
                    $('#runError').html("Click >Run to run the simulation and see the new results");
                    app.timeit((0, _clone2.default)(studyConfig));
                    app.refresh();
                }
            }

            /**
             * Get number of periods for next run of study, looks in study.common.periods first or if study.common not found, looks in study.periods
             * @return {number} number of periods
             */

        }, {
            key: "getPeriods",
            value: function getPeriods() {
                var app = this;
                var study = app.study;
                return study.common ? study.common.periods : study.periods;
            }

            /**
             * Safely sets number of periods for the next run of the current study.  Affects config of cached app.study but not settings in editor.
             * @param {number} n number of periods
             */

        }, {
            key: "setPeriods",
            value: function setPeriods(n) {
                var app = this;
                var study = app.study;
                if (study && +n > 0 && +n <= 10000) {
                    if (study.common) study.common.periods = +n;else study.periods = +n;
                    app.refresh();
                }
            }

            /**
             * Plot the parameters of a simulation into a numbered slot in the UI 
             * Low level, for SMRS.Simulation --  For study level, see showParameters(conf)
             * @param {Object} sim - an instance of SMRS.Simulation
             * @param {number} slot - slot number, appended to "paramPlot" to get DOM id
             */

        }, {
            key: "plotParameters",
            value: function plotParameters(sim, slot) {
                var _Plotly;

                var app = this;
                var plotlyParams = app.Visuals.params(sim);
                plotlyParams.unshift("paramPlot" + slot);
                (_Plotly = Plotly).newPlot.apply(_Plotly, _toConsumableArray(plotlyParams));
            }

            /**
             * Clears all class .paramPlot UI elements and plots all parameters of simulations in a study. Calls app.simulations and app.plotParameters
             * @param {Object} conf A study configuration compatible with app.simulations()
             */

        }, {
            key: "showParameters",
            value: function showParameters(conf) {
                var app = this;
                $('.paramPlot').html("");
                app.simulations(conf).forEach(function (sim, slot) {
                    return app.plotParameters(sim, slot);
                });
            }

            /**
             * Updates span.estimated-running-time with estimate of required running time for the current study, given the number of periods and the cached timing run, 
             * 
             */

        }, {
            key: "guessTime",
            value: function guessTime() {
                var app = this;
                var periodTimers = this.periodTimers;
                var periods = app.getPeriods();
                var l = periodTimers.length;
                var guess = 0;
                if (periods) {
                    if (l > 2) {
                        guess = periods * (periodTimers[l - 1] - periodTimers[1]) / (l - 2) + periodTimers[1];
                    } else if (l === 2) {
                        guess = periods * periodTimers[1];
                    }
                    if (guess) {
                        var seconds = Math.round(guess / 1000.0);
                        var minutes = Math.ceil(seconds / 60);
                        $('span.estimated-running-time').text(minutes > 1 ? '~' + minutes + 'min' : '~' + seconds + 'sec');
                    } else {
                        $('span.estimated-running-time').text("?");
                    }
                }
            }

            /**
             * Updates Array<number> app.periodTimers by running a study for up to 5 periods or 5 seconds to get period finishing times. Calls guessTIme to update span.estimated-running-time
             * @param {Object} studyConfig - A studyConfig as defined by app.simulations
             */

        }, {
            key: "timeit",
            value: function timeit(studyConfig) {
                var app = this;
                var t0 = Date.now();
                var periodTimers = app.periodTimers;
                periodTimers.length = 0;
                var studyConfig2p = (0, _clone2.default)(studyConfig);
                Promise.all(app.simulations(studyConfig2p).map(function (s) {
                    return s.run({
                        update: function update(sim) {
                            var elapsed = Date.now() - t0;
                            periodTimers[sim.period] = elapsed;
                            // hack to end simulations if over 5 sec or 5 periods
                            if (elapsed > 5000 || sim.period > 5) sim.config.periods = sim.period;
                            return sim;
                        }
                    });
                })).then(function () {
                    app.guessTime();
                }).catch(function (e) {
                    return console.log(e);
                });
            }

            /**
             * Choose study n from Array app.studies if possible, send it to app.editor and app.periodsEditor if defined, then app.timeit, and then refresh UI with app.refresh
             * @param {number} n index of chosen study in app.studies[]
             */

        }, {
            key: "choose",
            value: function choose(n) {
                var app = this;
                if (Array.isArray(app.studies)) {
                    app.chosenStudyIndex = Math.max(0, Math.min(Math.floor(n), app.studies.length - 1));
                    var choice = app.studies[app.chosenStudyIndex];
                    if (choice) {
                        app.setStudy(choice);
                    }
                }
            }

            /**
             * Render #selector if it exists, by erasing all options and reading each study .title from app.studies  You should define an empty select element in index.html with id "selector"
             */

        }, {
            key: "renderConfigSelector",
            value: function renderConfigSelector() {
                var _this = this;

                var app = this;
                $("#selector > option").remove();
                app.studies.forEach(function (c, n) {
                    return $("#selector").append('<option value="' + n + '">' + c.title + '</option>');
                });
                $('#selector').on('change', function (evt) {
                    return _this.choose(evt.target.selectedIndex);
                });
            }

            /**
             * get array of visualizations appropriate to the number of periods in the current study
             * if periods<=50, returns app.Visuals.small;  if 50<periods<=500, returns app.Visuals.medium; if periods>500, returns app.Visuals.large
             * @return {Array<function>} array of visualization functions generated from single-market-robot-simulator-viz-plotly
             */

        }, {
            key: "getVisuals",
            value: function getVisuals() {
                var app = this;
                var visuals = [];
                var periods = app.getPeriods();
                if (periods <= 50) visuals = app.Visuals.small;else if (periods <= 500) visuals = app.Visuals.medium;else visuals = app.Visuals.large;
                return visuals;
            }

            /**
             * plot simulation data plot into "slot" at div with id resultPlot+slot using chosen visual; adjust plot title per sim.config.title{append,prepend,replace}
             * @param {Object} simConfig An instance of SMRS.Simulation with finished simulation data in the logs
             * @param {number} slot 
             */

        }, {
            key: "showSimulation",
            value: function showSimulation(simConfig, slot) {
                var _Plotly2;

                var app = this;
                var visuals = app.getVisuals();
                var plotParams = visuals[app.visualIndex % visuals.length](simConfig);
                var config = simConfig.config;
                adjustTitle(plotParams, {
                    prepend: config.titlePrepend,
                    append: config.titleAppend,
                    replace: config.titleReplace
                });
                plotParams.unshift('resultPlot' + slot);
                (_Plotly2 = Plotly).newPlot.apply(_Plotly2, _toConsumableArray(plotParams));
            }

            /** 
             * Render visualization options for current app.study into DOM select existing at id #vizselect 
             */

        }, {
            key: "renderVisualSelector",
            value: function renderVisualSelector() {
                var app = this;
                var visuals = app.getVisuals();
                function toSelectBox(v, i) {
                    return ['<option value="', i, '"', i === app.visualIndex ? ' selected="selected" ' : '', '>', v.meta.title || v.meta.f, '</option>'].join('');
                }
                if (Array.isArray(visuals)) {
                    var vizchoices = visuals.map(toSelectBox).join("");
                    $('#vizselect').html(vizchoices);
                } else {
                    console.log("invalid visuals", visuals);
                }
            }

            /**
             * show progress message in resultPlot slot with h1 header tag; blank message clears (no h1)
             * 
             * @param {string} message text to show as heading in div resultPlot+slot
             * @param {number} slot Location for showing message
             */

        }, {
            key: "progress",
            value: function progress(message, slot) {
                var hmsg = message && message.length > 0 ? "<h1>" + message + "</h1>" : '';
                $('#resultPlot' + slot).html(hmsg);
            }

            /**
             * asynchronously start running a simulation and when done show its plots in a slot.  stops spinning run animation when done. Deletes logs buyorder,sellorder if periods>500 to prevent out-of-memory.
             * @param {Object} simConfig An initialized SMRS.Simulation
             * @param {number} slot A slot number.  Plots appear in div with id resultPlot+slot and paramPlot+slot
             * @return {Object} running SMRS.Simulations 
             */

        }, {
            key: "runSimulation",
            value: function runSimulation(simConfig, slot) {
                // set up and run simulation

                var app = this;

                function onPeriod(sim) {
                    if (sim.period < sim.config.periods) {
                        app.progress(Math.round(100 * sim.period / sim.config.periods) + "% complete", slot);
                    } else {
                        app.progress('', slot);
                    }
                    return sim;
                }

                function uiDone() {
                    $('.spinning').removeClass('spinning'); // this is perhaps needessly done multiple times
                    $('.postrun').removeClass('disabled'); // same here
                    $('.postrun').prop('disabled', false); // and here
                }

                function onDone(sim) {
                    app.showSimulation(sim, slot);
                    uiDone();
                }

                var mysim = simConfig; // this line used to call new Simulation based on simConfig... but that is done in .simulations already 

                app.plotParameters(mysim, slot);

                mysim.run({ update: onPeriod }).then(onDone).catch(function (e) {
                    console.log(e);
                    app.progress('<span class="error">' + e + '</span>', slot);
                    uiDone();
                });
                if (mysim.config.periods > 500) {
                    delete mysim.logs.buyorder;
                    delete mysim.logs.sellorder;
                    delete mysim.logs.rejectbuyorder;
                    delete mysim.logs.rejectsellorder;
                }

                return mysim;
            }

            /**
             * Fetches current study and modifies it for expansion.
             * If the number of buyers or sellers is 1, that number is unchanged.  Otherwise, multiplies the number of buyers and sellers by xfactor.
             * .buyerValues and .sellerCosts arrays in the current study are updated using supplied function how.  " x"+factor is appended to study title. 
             * @param {function(valuesOrCosts: number[], expansionFactor: number):number[]} how Function specifying how to modify the values and costs
             */

        }, {
            key: "expand",
            value: function expand(how) {
                var app = this;
                var xfactor = +$('#xfactor').val();
                var config = app.getStudy();
                if (xfactor) {
                    config.title += ' x' + xfactor;
                    config.configurations.forEach(function (sim) {
                        sim.buyerValues = how(sim.buyerValues, xfactor);
                        sim.sellerCosts = how(sim.sellerCosts, xfactor);
                        if (sim.numberOfBuyers > 1) sim.numberOfBuyers *= xfactor;
                        if (sim.numberOfSellers > 1) sim.numberOfSellers *= xfactor;
                    });
                    app.setStudy(config);
                    app.timeit((0, _clone2.default)(config));
                    app.refresh();
                }
            }

            /** Perform additional required initialization, NOT called by constructor. Sets up (1) app.behavior with jQuery.on; (2) JSON Editor in div with id editor; (3) begins reading database for saveList 
             */

        }, {
            key: "init",
            value: function init() {
                var app = this;
                app.behavior.forEach(function (v) {
                    var _v = _slicedToArray(v, 3),
                        jqSelector = _v[0],
                        appMethod = _v[1],
                        eventName = _v[2];

                    if (typeof app[appMethod] !== 'function') throw new Error("Error initializing app behavior - method " + appMethod + " specified in event map for selector " + jqSelector + " does not exist");
                    var selection = $(jqSelector);
                    if (selection.length === 0) throw new Error("Error initializing app behavior - selector " + jqSelector + " not found in app's web page");
                    selection.on(eventName || 'click', function (evt) {
                        return app[appMethod](evt && evt.target && evt.target.value);
                    });
                });
                $('.postrun').prop('disabled', true);
                var editorElement = document.getElementById('editor');
                if (editorElement && window.JSONEditor) {
                    var editorOptions = {
                        schema: app.editorConfigSchema,
                        startval: app.editorStartValue
                    };
                    app.editor = new window.JSONEditor(editorElement, editorOptions);
                }
                if (app.DB) app.DB.promiseList(app.saveList).then(function (configs) {
                    if (Array.isArray(configs) && configs.length) {
                        app.studies = configs;
                        app.renderConfigSelector();
                        app.choose(0);
                    }
                }).catch(function (e) {
                    console.log("Error accessing simulation configuration database:" + e);
                    app.DB = null;
                });
            }

            /**
             * updates running time estimate in span.estimated-running-time , using the current study
             */

        }, {
            key: "estimateTime",
            value: function estimateTime() {
                var app = this;
                app.timeit(app.getStudy());
            }

            /**
             * refreshes a number of UI elements
             */

        }, {
            key: "refresh",
            value: function refresh() {
                var app = this;
                var study = app.getStudy();
                var periods = app.getPeriods();
                if (study) {
                    app.guessTime();
                    app.showParameters(study);
                    $('.configTitle').text(study.title);
                    if (periods) {
                        $('input.periods').val(periods);
                        $('span.periods').text(periods);
                    }
                    var sims = app.simulations(study);
                    $('#xsimbs').html("<tr>" + sims.map(function (sim, j) {
                        var data = [j, sim.numberOfBuyers, sim.numberOfSellers];
                        return "<td>" + data.join("</td><td>") + "</td>";
                    }).join('</tr><tr>') + "</tr>");
                    app.plotParameters(sims[0], "ScaleUp");
                }
            }

            /**
             * expands the current study by creating new values and costs by interpolation
             */

        }, {
            key: "interpolate",
            value: function interpolate() {
                var app = this;
                app.expand(function (a, n) {
                    var result = [];
                    for (var i = 0, l = a.length; i < l - 1; ++i) {
                        for (var j = 0; j < n; ++j) {
                            result.push((a[i] * (n - j) + a[i + 1] * j) / n);
                        }
                    }
                    var last = a[a.length - 1];
                    for (var _j = 0; _j < n; ++_j) {
                        result.push(last);
                    }return result;
                });
            }

            /**
             * expands the current study by duplicating unit costs and values 
             */

        }, {
            key: "duplicate",
            value: function duplicate() {
                var app = this;
                app.expand(function (a, n) {
                    var result = [];
                    for (var i = 0, l = a.length; i < l; ++i) {
                        for (var j = 0; j < n; ++j) {
                            result.push(a[i]);
                        }
                    }
                    return result;
                });
            }

            /**
             * abandon edits to the current study by refreshing the UI and editor from the cache
             */

        }, {
            key: "undo",
            value: function undo() {
                var app = this;
                app.choose(app.chosenStudyIndex);
            }

            /**
             * move the current study to the trash list
             */

        }, {
            key: "moveToTrash",
            value: function moveToTrash() {
                var app = this;
                var studies = app.studies,
                    chosenStudyIndex = app.chosenStudyIndex,
                    saveList = app.saveList,
                    trashList = app.trashList;

                if (app.DB) {
                    app.DB.promiseMoveItem(studies[chosenStudyIndex], saveList, trashList).then(function () {
                        studies.splice(chosenStudyIndex, 1);
                        app.renderConfigSelector();
                        app.choose(0);
                    }).catch(function (e) {
                        console.log(e);
                    });
                }
            }

            /**
             * run the current study and display a visualization 
             */

        }, {
            key: "run",
            value: function run() {
                var app = this;
                $('#runError').html("");
                $('.postrun').removeClass("disabled");
                $('.postrun').addClass("disabled");
                $('.postrun').prop('disabled', true);
                $('.paramPlot').html("");
                $('.resultPlot').html("");
                $('#runButton .glyphicon').addClass("spinning");
                app.renderVisualSelector();
                setTimeout(function () {
                    var studyConfig = app.getStudy();
                    app.sims = app.simulations(studyConfig).map(function (s, i) {
                        return app.runSimulation(s, i);
                    });
                }, 200);
            }

            /**
             * stop a run of the current study
             * should have no effect unless study is running
             */

        }, {
            key: "stop",
            value: function stop() {
                var app = this;
                // trigger normal completion
                app.sims.forEach(function (sim) {
                    sim.config.periods = sim.period;
                });
            }

            /**
             * saves the current study from the editor.  Save is to the top of the app DB saveList, if the title is changed.  Otherwise, in place (remove/save).  
             * Finally, reload the browser to give the app a clean restart.
             * 
             */

        }, {
            key: "save",
            value: function save() {
                var app = this;
                function doSave() {
                    app.DB.promiseSaveItem(app.editor.getValue(), app.saveList).then(function () {
                        return window.location.reload();
                    });
                }
                if (app.DB) {
                    if (app.studies.length > 1 && app.studies[app.chosenStudyIndex] && app.editor.getValue().title === app.studies[app.chosenStudyIndex].title) {
                        app.DB.promiseRemoveItem(app.studies[app.chosenStudyIndex], app.saveList).then(doSave);
                    } else {
                        doSave();
                    }
                }
            }

            /**
             * Select a visualization from the visualization list and refresh the UI.
             * @param {number} n Visualization index in Visuals array
             */

        }, {
            key: "setVisualNumber",
            value: function setVisualNumber(n) {
                var app = this;
                app.visualIndex = n;
                app.sims.forEach(function (s, j) {
                    return app.showSimulation(s, j);
                });
            }

            /**
             * Create  .zip file containing study and simulation configurations and data and give it to the user
             */

        }, {
            key: "downloadData",
            value: function downloadData() {
                var app = this;
                $('#downloadButton').prop('disabled', true);
                $('#downloadButton').addClass("disabled");
                $('#downloadButton .glyphicon').addClass("spinning");
                setTimeout(function () {
                    (0, _singleMarketRobotSimulatorSavezip2.default)({
                        config: app.getStudy(),
                        sims: app.sims,
                        download: true
                    }).then(function () {
                        $('#downloadButton .spinning').removeClass("spinning");
                        $('#downloadButton').removeClass("disabled");
                        $('#downloadButton').prop('disabled', false);
                    });
                }, 200);
            }

            /**
             * Create .zip file containing study and simulation configurations and data and upload it to the cloud
             */

        }, {
            key: "uploadData",
            value: function uploadData() {
                var app = this;
                $('#uploadButton').prop('disabled', true);
                $('#uploadButton').addClass('disabled');
                $('#uploadButton .glyphicon').addClass("spinning");
                setTimeout(function () {
                    (0, _singleMarketRobotSimulatorSavezip2.default)({
                        config: app.getStudy(),
                        sims: app.sims,
                        download: false }).then(function (zipBlob) {
                        app.DB.promiseUpload(zipBlob).then(function () {
                            $('#uploadButton .spinning').removeClass("spinning");
                            $('#uploadButton').removeClass("disabled");
                            $('#uploadButton').prop('disabled', false);
                        }).catch(function (e) {
                            return console.log(e);
                        });
                    });
                }, 200);
            }

            /**
             * open a .zip file previously generated by app.downloadData() and load data and configurations as current study.  Check validity.  Hackish in places.
             */

        }, {
            key: "openZipFile",
            value: function openZipFile() {
                var app = this;
                function showProgress(message) {
                    $('div.openzip-progress').append("<p>" + message + "</p>");
                }
                function showError(e) {
                    showProgress('<span class="red"> ERROR: ' + e + '</span>');
                }
                function restoreUI() {
                    $('button.openzip-button').removeClass('diosabled').prop('disabled', false);
                }
                function showSuccess() {
                    showProgress('<span class="green"> SUCCESS.  The data in the zip file has been loaded.  You may click the "App" or "Edit" tabs now.  </span>');
                    restoreUI();
                }
                function showFailure(e) {
                    if (e) showError(e);
                    showProgress('<span class="red"> FAILURE. I could not use that zip file.  You may try again, choosing a different zip file');
                    restoreUI();
                }
                function hasMissing(a) {
                    // JavaScript ignores missing elements in higher order functional operations like .some, and even .indexOf(), so we have to check this with an explicit loop
                    if (Array.isArray(a)) {
                        var i = 0,
                            l = a.length,
                            u = false;
                        while (i < l && !u) {
                            u = typeof a[i] === "undefined";
                            i++;
                        }
                        return u;
                    }
                }
                $('div.openzip-progress').html('');
                $('button.openzip-button').prop('disabled', true).addClass("disabled");
                setTimeout(function () {
                    var zipPromise = new Promise(function (resolve, reject) {
                        var zipfile = $(".openzip-file")[0].files[0];
                        var reader = new FileReader();
                        reader.onload = function (event) {
                            resolve(event.target.result);
                        };
                        reader.onerror = function (e) {
                            reject(e);
                        };
                        reader.readAsArrayBuffer(zipfile);
                    });
                    (0, _singleMarketRobotSimulatorOpenzip2.default)(zipPromise, app.SMRS, showProgress).then(function (data) {
                        if (!data.config) throw new Error("No master configuration file (config.json) was found in zip file.  Maybe this zip file is unrelated.");
                        if (!data.sims.length) throw new Error("No simulation configuration files (sim.json) in the zip file");
                        if (Array.isArray(data.config.configurations) && data.config.configurations.length !== data.sims.length) throw new Error("Missing files.  the number of configurations in config.json does not match the number of simulation directories and files I found");
                        if (hasMissing(data.sims)) throw new Error("It seems a folder has been deleted from the zip file or I could not read it. ");
                        return data;
                    }).then(function (data) {
                        app.sims = data.sims;
                        app.studies = [data.config]; // deletes local cache of DB - pulled studiess. app only sees the loaded file.
                        app.renderConfigSelector(); // app only shows one choice in config selector -- can reload to get back to imported list
                        app.choose(0); // configure app to use the loaded file as the current study
                        app.renderVisualSelector(); // can render the list of available visualization only once the study is chosen as current study           
                    }).then(showSuccess, showFailure);
                }, 200);
            }

            /**
             * render into the div with id "trashList" the first 20 discarded study configurations in the app.DB at name app.trashList.  Trash items can be clicked to restore to editor.
             */

        }, {
            key: "renderTrash",
            value: function renderTrash() {
                var app = this;
                $('#trashList').html("");
                if (app.DB) {
                    app.DB.promiseListRange(app.trashList, 0, 20).then(function (items) {
                        items.forEach(function (item) {
                            $('#trashList').append('<pre class="pre-scrollable trash-item">' + JSON.stringify(item, null, 2) + '</pre>');
                        });
                        $('pre.trash-item').click(function () {

                            // this click function needs to be a full function with its own "this", not an anonymous ()=>{block}

                            try {
                                var restoredStudy = JSON.parse($(this).text());
                                if ((typeof restoredStudy === "undefined" ? "undefined" : _typeof(restoredStudy)) === 'object' && typeof restoredStudy.title === 'string' && _typeof(restoredStudy.common) === 'object' && Array.isArray(restoredStudy.configurations)) {
                                    app.editor.setValue(restoredStudy);
                                    $('#editLink').click();
                                } else {
                                    console.log("trashed item is not a valid study");
                                }
                            } catch (e) {
                                console.log("could not send trashed item to editor: " + e);
                            }
                        });
                    });
                }
            }
        }]);

        return App;
    }();
});
$__System.registerDynamic("190", ["18f"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("18f");
});
$__System.register("191", [], function (_export) {
    "use strict";

    _export("customViz", customViz);

    function customViz() {
        return {};
    }

    return {
        setters: [],
        execute: function () {}
    };
});
$__System.registerDynamic("192", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = [{ "f": "plotOHLCTimeSeries" }, { "f": "plotBidAskTradeTimeSeries" }, { "f": "plotProfitTimeSeries" }, { "f": "plotFactory", "title": "trade volume by period", "log": "volume", "names": ["volume"], "xs": ["period"], "ys": ["volume"], "modes": ["markers"], "layout": { "yaxis": {} } }, { "f": "plotFactory", "title": "trade prices", "log": "trade", "names": ["trades"], "xs": ["t"], "ys": ["price"], "modes": ["markers+lines"] }, { "f": "plotFactory", "title": "trade profitability", "log": "trade", "names": ["trade", "unit value", "unit cost"], "xs": ["t"], "ys": ["price", "buyerValue", "sellerCost"], "modes": ["markers+lines", "markers", "markers"] }, { "f": "histogramFactory", "title": "order price distribution", "names": ["buyLimitPrice", "sellLimitPrice"], "logs": ["buyorder", "sellorder"], "vars": ["buyLimitPrice", "sellLimitPrice"] }];
});
$__System.registerDynamic("193", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = [{ "f": "histogramFactory", "title": "periods (y) by efficiency of allocation pct (x)", "names": ["efficiencyOfAllocation"], "logs": ["effalloc"], "vars": ["efficiencyOfAllocation"] }, { "f": "histogram2DFactory", "title": "close price(y) by volume(x)", "names": ["volume", "close"], "logs": ["volume", "ohlc"], "vars": ["volume", "close"] }, { "f": "histogram2DFactory", "title": "close price(y) vs open price(x)", "names": ["open", "close"], "logs": ["ohlc"], "vars": ["open", "close"] }, { "f": "histogram2DFactory", "title": "trade price(y) vs time in period (tp)", "names": ["time", "price"], "logs": ["trade"], "vars": ["tp", "price"] }, { "f": "histogramFactory", "title": "periods (y) by volume(x) histogram", "names": ["volume"], "logs": ["volume"], "vars": ["volume"] }, { "f": "histogramFactory", "title": "trades(y) by price(x) histogram", "names": ["trades"], "logs": ["trade"], "vars": ["price"] }, { "f": "histogramFactory", "title": "trades(y) by profit(x) histogram", "names": ["buyer", "seller"], "logs": ["trade"], "vars": ["buyerProfit", "sellerProfit"] }, { "f": "histogram2DFactory", "title": "sellerProfit(y) vs buyerProfit(x)", "names": ["buyerProfit", "sellerProfit"], "logs": ["trade"], "vars": ["buyerProfit", "sellerProfit"] }, { "f": "histogramFactory", "title": "trades(y) by cost/value(x) histogram", "names": ["buyer", "seller"], "logs": ["trade"], "vars": ["buyerValue", "sellerCost"] }, { "f": "histogram2DFactory", "title": "buyerValue(y) vs sellerCost(x) trade histogram", "names": ["seller", "buyer"], "logs": ["trade"], "vars": ["sellerCost", "buyerValue"] }, { "f": "histogramFactory", "title": "trades(y) by time (tp) histogram", "names": ["tp"], "logs": ["trade"], "vars": ["tp"] }, { "f": "histogramFactory", "title": "order price distribution", "names": ["buyLimitPrice", "sellLimitPrice"], "logs": ["buyorder", "sellorder"], "vars": ["buyLimitPrice", "sellLimitPrice"] }];
});
$__System.registerDynamic("194", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = { "title": "Study", "type": "object", "default": {}, "options": { "collapsed": false }, "properties": { "title": { "type": "string", "propertyOrder": 1, "description": "short title to use in selection box", "default": "" }, "common": { "title": "Common", "type": "object", "propertyOrder": 10, "description": "settings common to all items in this study", "properties": { "periods": { "type": "number", "propertyOrder": 1, "description": "Number of Periods", "default": 10 }, "periodDuration": { "type": "number", "propertyOrder": 10, "description": "Period Duration (sec):", "default": 1000 }, "L": { "type": "number", "propertyOrder": 20, "description": "minimum price for zi Agent price generation", "default": 1 }, "H": { "type": "number", "propertyOrder": 30, "description": "maximum price for zi Agent price generation", "default": 200 }, "integer": { "type": "boolean", "propertyOrder": 40, "description": "Use integer prices", "default": true }, "silent": { "type": "boolean", "propertyOrder": 50, "description": "false emits more console.log messages, true suppresses", "default": true }, "version": { "type": "number", "propertyOrder": 99999, "description": "schema version, do not change", "default": 1 } } }, "configurations": { "title": "Robot Trading Comparison", "type": "array", "format": "tabs", "default": [], "propertyOrder": 20, "options": { "collapsed": false }, "items": { "type": "object", "properties": { "titleReplace": { "type": "string", "propertyOrder": 1, "description": "Plot Title (replacement):" }, "titleAppend": { "type": "string", "propertyOrder": 2, "description": "Plot Title (append):" }, "titlePrepend": { "type": "string", "propertyOrder": 3, "description": "Plot Title (prepend):", "default": "" }, "buyerValues": { "type": "array", "items": { "type": "number" }, "format": "textarea", "flavor": "positiveNumber", "propertyOrder": 10, "description": "Aggregate Buyers Values", "default": [100, 95, 90, 85, 80, 75, 70, 60, 50, 40, 30, 20, 10] }, "sellerCosts": { "type": "array", "items": { "type": "number" }, "format": "textarea", "flavor": "positiveNumber", "propertyOrder": 20, "description": "Aggregate Sellers Costs", "default": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] }, "numberOfBuyers": { "type": "number", "propertyOrder": 30, "description": "Number of Buyers", "default": 13 }, "numberOfSellers": { "type": "number", "propertyOrder": 40, "description": "Number of Sellers", "default": 10 }, "buyerRate": { "type": "array", "items": { "type": "number" }, "format": "textarea", "flavor": "positiveNumber", "propertyOrder": 50, "description": "Individual Buyer Poisson Arrival Rates (bids/sec per agent)", "default": [0.2] }, "sellerRate": { "type": "array", "items": { "type": "number" }, "format": "textarea", "flavor": "positiveNumber", "propertyOrder": 60, "description": "Individual Seller Poisson Arrival Rates (asks/sec per agent)", "default": [0.2] }, "buyerAgentType": { "description": "Buyer Types to use in rotation when creating buyers", "propertyOrder": 70, "type": "array", "uniqueItems": false, "items": { "type": "string", "enum": ["ZIAgent", "UnitAgent", "OneupmanshipAgent", "MidpointAgent", "KaplanSniperAgent", "HoarderAgent", "TruthfulAgent"] }, "format": "table", "default": ["ZIAgent"] }, "sellerAgentType": { "description": "Seller Types to use in rotation when creating sellers", "propertyOrder": 80, "type": "array", "uniqueItems": false, "items": { "type": "string", "enum": ["ZIAgent", "UnitAgent", "OneupmanshipAgent", "MidpointAgent", "KaplanSniperAgent", "TruthfulAgent"] }, "format": "table", "default": ["ZIAgent"] }, "keepPreviousOrders": { "type": "boolean", "propertyOrder": 90, "description": "true causes agents to not request cancellation/replacement of old orders with their new order, keeping the old orders.  Setting true will lead to setlement issues with zi traders; false submits 'cancel/replace' orders which first clear orders from the same agent", "default": false }, "ignoreBudgetConstraint": { "type": "boolean", "propertyOrder": 100, "description": "false uses Marginal Cost / Marginal Value as limits for zi Agent random asks/bids; true ignores MC/MV and generates random asks/bids on [minPrice,maxPrice]", "default": false }, "xMarket": { "type": "object", "propertyOrder": 110, "title": "advanced configuration options for X market", "properties": { "buySellBookLimit": { "type": "number", "propertyOrder": 10, "description": "0 = unlimited; otherwise, truncates buy book and sell book after each trade to N orders each side", "default": 0 }, "resetAfterEachTrade": { "type": "boolean", "propertyOrder": 20, "description": "reset the market, eliminating old orders, after each trade. use this, not buySellBookLimit, to completely clear books after each trade", "default": true }, "buyImprove": { "type": "number", "propertyOrder": 30, "description": "0=off, no effect; 1=reject new buy orders priced less than or equal best buy order; 2=reject new orders that are priced lt or eq 2nd best buy order; ...", "default": 0 }, "sellImprove": { "type": "number", "propertyOrder": 40, "description": "0=off, no effect; 1=reject new sell orders priced greater than or equal best sell order; 2 = reject new orders priced gt or eq 2nd best sell order; ...", "default": 0 } } } } } } } };
});
$__System.registerDynamic("195", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = { "title": "higher price vs lower price", "common": { "periods": 100, "periodDuration": 1000, "L": 1, "H": 200, "integer": true, "silent": true, "version": 1 }, "configurations": [{ "buyerValues": [100, 95, 90, 85, 80, 75, 70, 60, 50, 40, 30, 20, 10], "sellerCosts": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], "numberOfBuyers": 10, "numberOfSellers": 10, "buyerAgentType": ["ZIAgent"], "sellerAgentType": ["ZIAgent"], "buyerRate": [0.2], "sellerRate": [0.2], "keepPreviousOrders": false, "ignoreBudgetConstraint": false, "xMarket": { "buySellBookLimit": 0, "resetAfterEachTrade": true } }, { "buyerValues": [100, 90, 80, 70, 60, 50, 40, 30, 20, 10], "sellerCosts": [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100], "numberOfBuyers": 10, "numberOfSellers": 10, "buyerAgentType": ["ZIAgent"], "sellerAgentType": ["ZIAgent"], "buyerRate": 0.2, "sellerRate": 0.2, "keepPreviousOrders": false, "ignoreBudgetConstraint": false, "xMarket": { "buySellBookLimit": 0, "resetAfterEachTrade": true } }] };
});
$__System.registerDynamic("196", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = { "name": "robot-trading-webapp", "version": "3.0.0", "description": "website generator for robot trading single page webapp", "main": " ", "dependencies": {}, "devDependencies": { "eslint": "^4.9.0", "jspm": "^0.16.39" }, "keywords": ["robot-trading", "market-simulation"], "scripts": { "make-gh-pages": "./make-gh-pages.sh", "test": "echo \"Error: no test specified\" && exit 1" }, "repository": { "type": "git", "url": "git+https://github.com/drpaulbrewer/robot-trading-webapp.git" }, "bugs": { "url": "https://github.com/drpaulbrewer/robot-trading-webapp/issues" }, "homepage": "https://github.com/drpaulbrewer/robot-trading-webapp#readme", "author": "drpaulbrewer@eaftc.com", "license": "MIT", "jspm": { "dependencies": { "clone": "npm:clone@^2.1.0", "json": "github:systemjs/plugin-json@^0.1.2", "json-editor": "npm:json-editor@^0.7.27", "json-editor-positive-number-array-textarea": "npm:json-editor-positive-number-array-textarea@^0.4.0", "single-market-robot-simulator": "npm:single-market-robot-simulator@^1", "single-market-robot-simulator-app-framework": "npm:single-market-robot-simulator-app-framework@^3", "single-market-robot-simulator-db-local": "npm:single-market-robot-simulator-db-local@^1.0.0", "single-market-robot-simulator-savezip": "npm:single-market-robot-simulator-savezip@^2", "single-market-robot-simulator-viz-plotly": "npm:single-market-robot-simulator-viz-plotly@^1", "systemjs/plugin-json": "github:systemjs/plugin-json@^0.1.2", "whatwg-fetch": "npm:whatwg-fetch@^1.0.0" }, "devDependencies": { "babel": "npm:babel-core@^5.8.24", "babel-runtime": "npm:babel-runtime@^5.8.24", "core-js": "npm:core-js@^1.1.4" } } };
});
$__System.registerDynamic("197", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = [["#vizselect", "setVisualNumber"], ["button.move-to-trash", "moveToTrash"], ["li.render-trash", "renderTrash"], ["#runButton", "run"], ["button.save-button", "save"], ["#downloadButton", "downloadData"], ["#interpolateButton", "interpolate"], ["#duplicateButton", "duplicate"], ["button.change-periods", "setPeriods"], [".change-periods", "setPeriods", "change"], ["button.undo-button", "undo"], ["span.glyphicon-time", "estimateTime"]];
});
$__System.register('1', ['10', '107', '190', '191', '192', '193', '194', '195', '196', '197', 'dc', 'de', 'e0', 'e3', 'fc', '10d'], function (_export) {
    var _Object$assign, VIZ, AF, customViz, smallDataVisualsJSON, mediumDataVisualsJSON, configSchema, examplesHighLow, packageJSON, behavior, jsonEditorPositiveNumberArrayTextarea, SMRS, DB, myVIZ, smallDataVisuals, mediumDataVisuals, largeDataJSON, largeDataVisuals, plotParamsSupplyDemand, Visuals, app;

    return {
        setters: [function (_) {
            _Object$assign = _['default'];
        }, function (_2) {
            VIZ = _2;
        }, function (_3) {
            AF = _3;
        }, function (_4) {
            customViz = _4.customViz;
        }, function (_5) {
            smallDataVisualsJSON = _5['default'];
        }, function (_6) {
            mediumDataVisualsJSON = _6['default'];
        }, function (_7) {
            configSchema = _7['default'];
        }, function (_8) {
            examplesHighLow = _8['default'];
        }, function (_9) {
            packageJSON = _9['default'];
        }, function (_10) {
            behavior = _10['default'];
        }, function (_dc) {}, function (_de) {}, function (_e0) {}, function (_e3) {
            jsonEditorPositiveNumberArrayTextarea = _e3['default'];
        }, function (_fc) {
            SMRS = _fc;
        }, function (_d) {
            DB = _d;
        }],
        execute: function () {
            /* Copyright 2016 Paul Brewer, Economic and Financial Technology Consulting LLC */
            /* This file is open source software.  The MIT License applies to this software. */

            /* eslint no-console: "off" */
            'use strict';

            // defines window.JSONEditor

            $('#version').html("<p>Software package information from package.json</p><pre>" + JSON.stringify(packageJSON, null, 4) + "</pre>");

            myVIZ = _Object$assign({}, VIZ.helpers || VIZ, customViz());

            /* enable use of twitter bootstrap 3 by json editor. requires bootstrap 3 css/js to be loaded in index.html */

            window.JSONEditor.defaults.options.theme = 'bootstrap3';
            window.JSONEditor.defaults.options.iconlib = 'bootstrap3';

            jsonEditorPositiveNumberArrayTextarea();

            smallDataVisuals = VIZ.build(smallDataVisualsJSON, myVIZ);
            mediumDataVisuals = VIZ.build(mediumDataVisualsJSON, myVIZ);
            largeDataJSON = mediumDataVisualsJSON.filter(function (V) {
                return !V.logs || V.logs.indexOf("buyorder") === -1 && V.logs.indexOf("sellorder") === -1;
            });
            largeDataVisuals = VIZ.build(largeDataJSON, myVIZ);
            plotParamsSupplyDemand = VIZ.helpers.supplyDemand();
            Visuals = {
                params: plotParamsSupplyDemand,
                small: smallDataVisuals,
                medium: mediumDataVisuals,
                large: largeDataVisuals
            };

            // set if unset

            DB.init(window.sessionStorage);
            DB.openList("saveList", [examplesHighLow]);

            app = new AF.App({
                SMRS: SMRS,
                DB: DB,
                Visuals: Visuals,
                behavior: behavior,
                saveList: "saveList",
                trashList: "trashList",
                editorConfigSchema: configSchema,
                editorStartValue: examplesHighLow
            });

            // with DB from single-robot-market-simulator-db-webdismay use $('#uploadButton').click(()=>(app.uploadData()));
            // with DB from single-robot-market-simulator-db-local upload should be disabled with an alert message.

            $('#uploadButton').click(function () {
                return window.alert("upload to private cloud unavailable in demo mode. Contact drpaulbrewer@eaftc.com to discuss private cloud simulations.");
            });

            $("a.innerurl").each(function () {
                $(this).html(this.href);
            });
            $('li a').click(function () {
                setTimeout(function () {
                    return app.refresh();
                }, 200);
            });

            $(function () {
                app.init();
            });
        }
    };
});
// Polyfill defines ES7 window.fetch
})
(function(factory) {
  factory();
});
//# sourceMappingURL=bundle.js.map